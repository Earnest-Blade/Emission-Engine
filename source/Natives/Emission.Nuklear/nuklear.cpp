// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include "nuklear.h"
#include "memory_helper.h"

using namespace System;
using namespace System::Runtime::InteropServices;

nuklear::NkColor::NkColor(struct ::nk_color* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkColor^ nuklear::NkColor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkColor((struct ::nk_color*) native.ToPointer());
}

nuklear::NkColor::NkColor(struct ::nk_color* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkColor^ nuklear::NkColor::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkColor((struct ::nk_color*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkColor::~NkColor()
{
    delete NativePtr;
}

nuklear::NkColor::!NkColor()
{
    delete NativePtr;
}

nuklear::NkColor::NkColor()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_color();
}

nuklear::NkColor::NkColor(::nuklear::NkColor^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_color*)_0->NativePtr;
    NativePtr = new struct ::nk_color(__arg0);
}

::System::IntPtr nuklear::NkColor::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkColor::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_color*)object.ToPointer();
}

unsigned char nuklear::NkColor::R::get()
{
    return NativePtr->r;
}

void nuklear::NkColor::R::set(unsigned char value)
{
    ((struct ::nk_color*)NativePtr)->r = (::nk_byte)value;
}

unsigned char nuklear::NkColor::G::get()
{
    return NativePtr->g;
}

void nuklear::NkColor::G::set(unsigned char value)
{
    ((struct ::nk_color*)NativePtr)->g = (::nk_byte)value;
}

unsigned char nuklear::NkColor::B::get()
{
    return NativePtr->b;
}

void nuklear::NkColor::B::set(unsigned char value)
{
    ((struct ::nk_color*)NativePtr)->b = (::nk_byte)value;
}

unsigned char nuklear::NkColor::A::get()
{
    return NativePtr->a;
}

void nuklear::NkColor::A::set(unsigned char value)
{
    ((struct ::nk_color*)NativePtr)->a = (::nk_byte)value;
}

nuklear::NkColorf::NkColorf(struct ::nk_colorf* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkColorf^ nuklear::NkColorf::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkColorf((struct ::nk_colorf*) native.ToPointer());
}

nuklear::NkColorf::NkColorf(struct ::nk_colorf* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkColorf^ nuklear::NkColorf::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkColorf((struct ::nk_colorf*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkColorf::~NkColorf()
{
    delete NativePtr;
}

nuklear::NkColorf::!NkColorf()
{
    delete NativePtr;
}

nuklear::NkColorf::NkColorf()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_colorf();
}

nuklear::NkColorf::NkColorf(::nuklear::NkColorf^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_colorf*)_0->NativePtr;
    NativePtr = new struct ::nk_colorf(__arg0);
}

::System::IntPtr nuklear::NkColorf::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkColorf::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_colorf*)object.ToPointer();
}

float nuklear::NkColorf::R::get()
{
    return NativePtr->r;
}

void nuklear::NkColorf::R::set(float value)
{
    ((struct ::nk_colorf*)NativePtr)->r = value;
}

float nuklear::NkColorf::G::get()
{
    return NativePtr->g;
}

void nuklear::NkColorf::G::set(float value)
{
    ((struct ::nk_colorf*)NativePtr)->g = value;
}

float nuklear::NkColorf::B::get()
{
    return NativePtr->b;
}

void nuklear::NkColorf::B::set(float value)
{
    ((struct ::nk_colorf*)NativePtr)->b = value;
}

float nuklear::NkColorf::A::get()
{
    return NativePtr->a;
}

void nuklear::NkColorf::A::set(float value)
{
    ((struct ::nk_colorf*)NativePtr)->a = value;
}

nuklear::NkVec2::NkVec2(struct ::nk_vec2* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkVec2^ nuklear::NkVec2::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkVec2((struct ::nk_vec2*) native.ToPointer());
}

nuklear::NkVec2::NkVec2(struct ::nk_vec2* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkVec2^ nuklear::NkVec2::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkVec2((struct ::nk_vec2*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkVec2::~NkVec2()
{
    delete NativePtr;
}

nuklear::NkVec2::!NkVec2()
{
    delete NativePtr;
}

nuklear::NkVec2::NkVec2()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_vec2();
}

nuklear::NkVec2::NkVec2(::nuklear::NkVec2^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_vec2*)_0->NativePtr;
    NativePtr = new struct ::nk_vec2(__arg0);
}

::System::IntPtr nuklear::NkVec2::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkVec2::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_vec2*)object.ToPointer();
}

float nuklear::NkVec2::X::get()
{
    return NativePtr->x;
}

void nuklear::NkVec2::X::set(float value)
{
    ((struct ::nk_vec2*)NativePtr)->x = value;
}

float nuklear::NkVec2::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkVec2::Y::set(float value)
{
    ((struct ::nk_vec2*)NativePtr)->y = value;
}

nuklear::NkVec2i::NkVec2i(struct ::nk_vec2i* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkVec2i^ nuklear::NkVec2i::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*) native.ToPointer());
}

nuklear::NkVec2i::NkVec2i(struct ::nk_vec2i* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkVec2i^ nuklear::NkVec2i::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkVec2i::~NkVec2i()
{
    delete NativePtr;
}

nuklear::NkVec2i::!NkVec2i()
{
    delete NativePtr;
}

nuklear::NkVec2i::NkVec2i()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_vec2i();
}

nuklear::NkVec2i::NkVec2i(::nuklear::NkVec2i^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_vec2i*)_0->NativePtr;
    NativePtr = new struct ::nk_vec2i(__arg0);
}

::System::IntPtr nuklear::NkVec2i::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkVec2i::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_vec2i*)object.ToPointer();
}

short nuklear::NkVec2i::X::get()
{
    return NativePtr->x;
}

void nuklear::NkVec2i::X::set(short value)
{
    ((struct ::nk_vec2i*)NativePtr)->x = value;
}

short nuklear::NkVec2i::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkVec2i::Y::set(short value)
{
    ((struct ::nk_vec2i*)NativePtr)->y = value;
}

nuklear::NkRect::NkRect(struct ::nk_rect* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkRect::NkRect(int x, int y, int w, int h)
{
    NativePtr = &nk_rect(x, y, w, h);
}


nuklear::NkRect^ nuklear::NkRect::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkRect((struct ::nk_rect*) native.ToPointer());
}

nuklear::NkRect::NkRect(struct ::nk_rect* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkRect^ nuklear::NkRect::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkRect((struct ::nk_rect*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkRect::~NkRect()
{
    delete NativePtr;
}

nuklear::NkRect::!NkRect()
{
    delete NativePtr;
}

nuklear::NkRect::NkRect()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_rect();
}

nuklear::NkRect::NkRect(::nuklear::NkRect^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_rect*)_0->NativePtr;
    NativePtr = new struct ::nk_rect(__arg0);
}

::System::IntPtr nuklear::NkRect::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkRect::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_rect*)object.ToPointer();
}

float nuklear::NkRect::X::get()
{
    return NativePtr->x;
}

void nuklear::NkRect::X::set(float value)
{
    ((struct ::nk_rect*)NativePtr)->x = value;
}

float nuklear::NkRect::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkRect::Y::set(float value)
{
    ((struct ::nk_rect*)NativePtr)->y = value;
}

float nuklear::NkRect::W::get()
{
    return NativePtr->w;
}

void nuklear::NkRect::W::set(float value)
{
    ((struct ::nk_rect*)NativePtr)->w = value;
}

float nuklear::NkRect::H::get()
{
    return NativePtr->h;
}

void nuklear::NkRect::H::set(float value)
{
    ((struct ::nk_rect*)NativePtr)->h = value;
}

nuklear::NkRecti::NkRecti(struct ::nk_recti* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkRecti^ nuklear::NkRecti::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkRecti((struct ::nk_recti*) native.ToPointer());
}

nuklear::NkRecti::NkRecti(struct ::nk_recti* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkRecti^ nuklear::NkRecti::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkRecti((struct ::nk_recti*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkRecti::~NkRecti()
{
    delete NativePtr;
}

nuklear::NkRecti::!NkRecti()
{
    delete NativePtr;
}

nuklear::NkRecti::NkRecti()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_recti();
}

nuklear::NkRecti::NkRecti(::nuklear::NkRecti^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_recti*)_0->NativePtr;
    NativePtr = new struct ::nk_recti(__arg0);
}

::System::IntPtr nuklear::NkRecti::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkRecti::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_recti*)object.ToPointer();
}

short nuklear::NkRecti::X::get()
{
    return NativePtr->x;
}

void nuklear::NkRecti::X::set(short value)
{
    ((struct ::nk_recti*)NativePtr)->x = value;
}

short nuklear::NkRecti::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkRecti::Y::set(short value)
{
    ((struct ::nk_recti*)NativePtr)->y = value;
}

short nuklear::NkRecti::W::get()
{
    return NativePtr->w;
}

void nuklear::NkRecti::W::set(short value)
{
    ((struct ::nk_recti*)NativePtr)->w = value;
}

short nuklear::NkRecti::H::get()
{
    return NativePtr->h;
}

void nuklear::NkRecti::H::set(short value)
{
    ((struct ::nk_recti*)NativePtr)->h = value;
}

nuklear::NkHandle::NkHandle(::nk_handle* native)
{
    __ptr = ::System::IntPtr(native->ptr);
    __id = native->id;
}

nuklear::NkHandle^ nuklear::NkHandle::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkHandle((::nk_handle*) native.ToPointer());
}

nuklear::NkHandle::NkHandle(::nk_handle* native, bool ownNativeInstance)
{
    __ptr = ::System::IntPtr(native->ptr);
    __id = native->id;
}

nuklear::NkHandle^ nuklear::NkHandle::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkHandle((::nk_handle*) native.ToPointer(), __ownsNativeInstance);
}

::System::IntPtr nuklear::NkHandle::Ptr::get()
{
    return __ptr;
}

void nuklear::NkHandle::Ptr::set(::System::IntPtr value)
{
    __ptr = value;
}

int nuklear::NkHandle::Id::get()
{
    return __id;
}

void nuklear::NkHandle::Id::set(int value)
{
    __id = value;
}

nuklear::NkImage::NkImage(struct ::nk_image* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkImage^ nuklear::NkImage::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkImage((struct ::nk_image*) native.ToPointer());
}

nuklear::NkImage::NkImage(struct ::nk_image* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkImage^ nuklear::NkImage::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkImage((struct ::nk_image*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkImage::~NkImage()
{
    delete NativePtr;
}

nuklear::NkImage::!NkImage()
{
    delete NativePtr;
}

nuklear::NkImage::NkImage()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_image();
}

nuklear::NkImage::NkImage(::nuklear::NkImage^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_image*)_0->NativePtr;
    NativePtr = new struct ::nk_image(__arg0);
}

::System::IntPtr nuklear::NkImage::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkImage::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_image*)object.ToPointer();
}

::nuklear::NkHandle nuklear::NkImage::Handle::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->handle);
}

void nuklear::NkImage::Handle::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_image*)NativePtr)->handle = _marshal0;
}

unsigned short nuklear::NkImage::W::get()
{
    return NativePtr->w;
}

void nuklear::NkImage::W::set(unsigned short value)
{
    ((struct ::nk_image*)NativePtr)->w = value;
}

unsigned short nuklear::NkImage::H::get()
{
    return NativePtr->h;
}

void nuklear::NkImage::H::set(unsigned short value)
{
    ((struct ::nk_image*)NativePtr)->h = value;
}

cli::array<unsigned short>^ nuklear::NkImage::Region::get()
{
    cli::array<unsigned short>^ __array0 = nullptr;
    if (NativePtr->region != 0)
    {
        __array0 = gcnew cli::array<unsigned short>(4);
        for (int i = 0; i < 4; i++)
            __array0[i] = NativePtr->region[i];
    }
    return __array0;
}

void nuklear::NkImage::Region::set(cli::array<unsigned short>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 4)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 4; i++)
            ((struct ::nk_image*)NativePtr)->region[i] = value[i];
    }
}

nuklear::NkCursor::NkCursor(struct ::nk_cursor* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCursor^ nuklear::NkCursor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCursor((struct ::nk_cursor*) native.ToPointer());
}

nuklear::NkCursor::NkCursor(struct ::nk_cursor* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCursor^ nuklear::NkCursor::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCursor((struct ::nk_cursor*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCursor::~NkCursor()
{
    delete NativePtr;
}

nuklear::NkCursor::!NkCursor()
{
    delete NativePtr;
}

nuklear::NkCursor::NkCursor()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_cursor();
}

nuklear::NkCursor::NkCursor(::nuklear::NkCursor^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_cursor*)_0->NativePtr;
    NativePtr = new struct ::nk_cursor(__arg0);
}

::System::IntPtr nuklear::NkCursor::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCursor::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_cursor*)object.ToPointer();
}

::nuklear::NkImage^ nuklear::NkCursor::Img::get()
{
    return (&NativePtr->img == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)&NativePtr->img);
}

void nuklear::NkCursor::Img::set(::nuklear::NkImage^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_cursor*)NativePtr)->img = *(struct ::nk_image*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkCursor::Size::get()
{
    return (&NativePtr->size == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->size);
}

void nuklear::NkCursor::Size::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_cursor*)NativePtr)->size = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkCursor::Offset::get()
{
    return (&NativePtr->offset == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->offset);
}

void nuklear::NkCursor::Offset::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_cursor*)NativePtr)->offset = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkScroll::NkScroll(struct ::nk_scroll* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkScroll^ nuklear::NkScroll::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkScroll((struct ::nk_scroll*) native.ToPointer());
}

nuklear::NkScroll::NkScroll(struct ::nk_scroll* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkScroll^ nuklear::NkScroll::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkScroll((struct ::nk_scroll*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkScroll::~NkScroll()
{
    delete NativePtr;
}

nuklear::NkScroll::!NkScroll()
{
    delete NativePtr;
}

nuklear::NkScroll::NkScroll()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_scroll();
}

nuklear::NkScroll::NkScroll(::nuklear::NkScroll^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_scroll*)_0->NativePtr;
    NativePtr = new struct ::nk_scroll(__arg0);
}

::System::IntPtr nuklear::NkScroll::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkScroll::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_scroll*)object.ToPointer();
}

unsigned int nuklear::NkScroll::X::get()
{
    return NativePtr->x;
}

void nuklear::NkScroll::X::set(unsigned int value)
{
    ((struct ::nk_scroll*)NativePtr)->x = (::nk_uint)value;
}

unsigned int nuklear::NkScroll::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkScroll::Y::set(unsigned int value)
{
    ((struct ::nk_scroll*)NativePtr)->y = (::nk_uint)value;
}

nuklear::NkAllocator::NkAllocator(struct ::nk_allocator* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkAllocator^ nuklear::NkAllocator::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkAllocator((struct ::nk_allocator*) native.ToPointer());
}

nuklear::NkAllocator::NkAllocator(struct ::nk_allocator* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkAllocator^ nuklear::NkAllocator::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkAllocator((struct ::nk_allocator*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkAllocator::~NkAllocator()
{
    delete NativePtr;
}

nuklear::NkAllocator::!NkAllocator()
{
    delete NativePtr;
}

nuklear::NkAllocator::NkAllocator()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_allocator();
}

nuklear::NkAllocator::NkAllocator(::nuklear::NkAllocator^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_allocator*)_0->NativePtr;
    NativePtr = new struct ::nk_allocator(__arg0);
}

::System::IntPtr nuklear::NkAllocator::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkAllocator::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_allocator*)object.ToPointer();
}

::nuklear::NkHandle nuklear::NkAllocator::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkAllocator::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_allocator*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkPluginAlloc^ nuklear::NkAllocator::Alloc::get()
{
    return NativePtr->alloc == nullptr ? nullptr : safe_cast<::nuklear::NkPluginAlloc^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->alloc), ::nuklear::NkPluginAlloc::typeid));
}

void nuklear::NkAllocator::Alloc::set(::nuklear::NkPluginAlloc^ value)
{
    ((struct ::nk_allocator*)NativePtr)->alloc = static_cast<::nk_plugin_alloc>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkPluginFree^ nuklear::NkAllocator::Free::get()
{
    return NativePtr->free == nullptr ? nullptr : safe_cast<::nuklear::NkPluginFree^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->free), ::nuklear::NkPluginFree::typeid));
}

void nuklear::NkAllocator::Free::set(::nuklear::NkPluginFree^ value)
{
    ((struct ::nk_allocator*)NativePtr)->free = static_cast<::nk_plugin_free>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkDrawNullTexture::NkDrawNullTexture(struct ::nk_draw_null_texture* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkDrawNullTexture^ nuklear::NkDrawNullTexture::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkDrawNullTexture((struct ::nk_draw_null_texture*) native.ToPointer());
}

nuklear::NkDrawNullTexture::NkDrawNullTexture(struct ::nk_draw_null_texture* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkDrawNullTexture^ nuklear::NkDrawNullTexture::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkDrawNullTexture((struct ::nk_draw_null_texture*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkDrawNullTexture::~NkDrawNullTexture()
{
    delete NativePtr;
}

nuklear::NkDrawNullTexture::!NkDrawNullTexture()
{
    delete NativePtr;
}

nuklear::NkDrawNullTexture::NkDrawNullTexture()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_draw_null_texture();
}

nuklear::NkDrawNullTexture::NkDrawNullTexture(::nuklear::NkDrawNullTexture^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_draw_null_texture*)_0->NativePtr;
    NativePtr = new struct ::nk_draw_null_texture(__arg0);
}

::System::IntPtr nuklear::NkDrawNullTexture::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkDrawNullTexture::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_draw_null_texture*)object.ToPointer();
}

::nuklear::NkHandle nuklear::NkDrawNullTexture::Texture::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->texture);
}

void nuklear::NkDrawNullTexture::Texture::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_draw_null_texture*)NativePtr)->texture = _marshal0;
}

::nuklear::NkVec2^ nuklear::NkDrawNullTexture::Uv::get()
{
    return (&NativePtr->uv == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->uv);
}

void nuklear::NkDrawNullTexture::Uv::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_draw_null_texture*)NativePtr)->uv = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkConvertConfig::NkConvertConfig(struct ::nk_convert_config* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConvertConfig^ nuklear::NkConvertConfig::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConvertConfig((struct ::nk_convert_config*) native.ToPointer());
}

nuklear::NkConvertConfig::NkConvertConfig(struct ::nk_convert_config* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConvertConfig^ nuklear::NkConvertConfig::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConvertConfig((struct ::nk_convert_config*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConvertConfig::~NkConvertConfig()
{
    delete NativePtr;
}

nuklear::NkConvertConfig::!NkConvertConfig()
{
    delete NativePtr;
}

nuklear::NkConvertConfig::NkConvertConfig()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_convert_config();
}

nuklear::NkConvertConfig::NkConvertConfig(::nuklear::NkConvertConfig^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_convert_config*)_0->NativePtr;
    NativePtr = new struct ::nk_convert_config(__arg0);
}

::System::IntPtr nuklear::NkConvertConfig::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConvertConfig::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_convert_config*)object.ToPointer();
}

float nuklear::NkConvertConfig::GlobalAlpha::get()
{
    return NativePtr->global_alpha;
}

void nuklear::NkConvertConfig::GlobalAlpha::set(float value)
{
    ((struct ::nk_convert_config*)NativePtr)->global_alpha = value;
}

::nuklear::NkAntiAliasing nuklear::NkConvertConfig::LineAA::get()
{
    return (::nuklear::NkAntiAliasing)NativePtr->line_AA;
}

void nuklear::NkConvertConfig::LineAA::set(::nuklear::NkAntiAliasing value)
{
    ((struct ::nk_convert_config*)NativePtr)->line_AA = (enum ::nk_anti_aliasing)value;
}

::nuklear::NkAntiAliasing nuklear::NkConvertConfig::ShapeAA::get()
{
    return (::nuklear::NkAntiAliasing)NativePtr->shape_AA;
}

void nuklear::NkConvertConfig::ShapeAA::set(::nuklear::NkAntiAliasing value)
{
    ((struct ::nk_convert_config*)NativePtr)->shape_AA = (enum ::nk_anti_aliasing)value;
}

unsigned int nuklear::NkConvertConfig::CircleSegmentCount::get()
{
    return NativePtr->circle_segment_count;
}

void nuklear::NkConvertConfig::CircleSegmentCount::set(unsigned int value)
{
    ((struct ::nk_convert_config*)NativePtr)->circle_segment_count = value;
}

unsigned int nuklear::NkConvertConfig::ArcSegmentCount::get()
{
    return NativePtr->arc_segment_count;
}

void nuklear::NkConvertConfig::ArcSegmentCount::set(unsigned int value)
{
    ((struct ::nk_convert_config*)NativePtr)->arc_segment_count = value;
}

unsigned int nuklear::NkConvertConfig::CurveSegmentCount::get()
{
    return NativePtr->curve_segment_count;
}

void nuklear::NkConvertConfig::CurveSegmentCount::set(unsigned int value)
{
    ((struct ::nk_convert_config*)NativePtr)->curve_segment_count = value;
}

::nuklear::NkDrawNullTexture^ nuklear::NkConvertConfig::Null::get()
{
    return (&NativePtr->null == nullptr) ? nullptr : gcnew ::nuklear::NkDrawNullTexture((struct ::nk_draw_null_texture*)&NativePtr->null);
}

void nuklear::NkConvertConfig::Null::set(::nuklear::NkDrawNullTexture^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_convert_config*)NativePtr)->null = *(struct ::nk_draw_null_texture*)value->NativePtr;
}

unsigned long long nuklear::NkConvertConfig::VertexSize::get()
{
    return NativePtr->vertex_size;
}

void nuklear::NkConvertConfig::VertexSize::set(unsigned long long value)
{
    ((struct ::nk_convert_config*)NativePtr)->vertex_size = (::nk_size)value;
}

unsigned long long nuklear::NkConvertConfig::VertexAlignment::get()
{
    return NativePtr->vertex_alignment;
}

void nuklear::NkConvertConfig::VertexAlignment::set(unsigned long long value)
{
    ((struct ::nk_convert_config*)NativePtr)->vertex_alignment = (::nk_size)value;
}

nuklear::NkListView::NkListView(struct ::nk_list_view* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkListView^ nuklear::NkListView::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkListView((struct ::nk_list_view*) native.ToPointer());
}

nuklear::NkListView::NkListView(struct ::nk_list_view* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkListView^ nuklear::NkListView::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkListView((struct ::nk_list_view*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkListView::~NkListView()
{
    delete NativePtr;
}

nuklear::NkListView::!NkListView()
{
    delete NativePtr;
}

nuklear::NkListView::NkListView()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_list_view();
}

nuklear::NkListView::NkListView(::nuklear::NkListView^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_list_view*)_0->NativePtr;
    NativePtr = new struct ::nk_list_view(__arg0);
}

::System::IntPtr nuklear::NkListView::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkListView::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_list_view*)object.ToPointer();
}

int nuklear::NkListView::Begin::get()
{
    return NativePtr->begin;
}

void nuklear::NkListView::Begin::set(int value)
{
    ((struct ::nk_list_view*)NativePtr)->begin = value;
}

int nuklear::NkListView::End::get()
{
    return NativePtr->end;
}

void nuklear::NkListView::End::set(int value)
{
    ((struct ::nk_list_view*)NativePtr)->end = value;
}

int nuklear::NkListView::Count::get()
{
    return NativePtr->count;
}

void nuklear::NkListView::Count::set(int value)
{
    ((struct ::nk_list_view*)NativePtr)->count = value;
}

int nuklear::NkListView::TotalHeight::get()
{
    return NativePtr->total_height;
}

void nuklear::NkListView::TotalHeight::set(int value)
{
    ((struct ::nk_list_view*)NativePtr)->total_height = value;
}

::nuklear::NkContext^ nuklear::NkListView::Ctx::get()
{
    return (NativePtr->ctx == nullptr) ? nullptr : gcnew ::nuklear::NkContext((struct ::nk_context*)NativePtr->ctx);
}

void nuklear::NkListView::Ctx::set(::nuklear::NkContext^ value)
{
    ((struct ::nk_list_view*)NativePtr)->ctx = (struct ::nk_context*)value->NativePtr;
}

unsigned int* nuklear::NkListView::ScrollPointer::get()
{
    return reinterpret_cast<unsigned int*>(NativePtr->scroll_pointer);
}

void nuklear::NkListView::ScrollPointer::set(unsigned int* value)
{
    ((struct ::nk_list_view*)NativePtr)->scroll_pointer = (nk_uint*)value;
}

unsigned int nuklear::NkListView::ScrollValue::get()
{
    return NativePtr->scroll_value;
}

void nuklear::NkListView::ScrollValue::set(unsigned int value)
{
    ((struct ::nk_list_view*)NativePtr)->scroll_value = (::nk_uint)value;
}

nuklear::NkUserFont::NkUserFont(struct ::nk_user_font* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkUserFont^ nuklear::NkUserFont::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkUserFont((struct ::nk_user_font*) native.ToPointer());
}

nuklear::NkUserFont::NkUserFont(struct ::nk_user_font* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkUserFont^ nuklear::NkUserFont::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkUserFont((struct ::nk_user_font*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkUserFont::~NkUserFont()
{
    delete NativePtr;
}

nuklear::NkUserFont::!NkUserFont()
{
    delete NativePtr;
}

nuklear::NkUserFont::NkUserFont()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_user_font();
}

nuklear::NkUserFont::NkUserFont(::nuklear::NkUserFont^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_user_font*)_0->NativePtr;
    NativePtr = new struct ::nk_user_font(__arg0);
}

::System::IntPtr nuklear::NkUserFont::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkUserFont::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_user_font*)object.ToPointer();
}

::nuklear::NkHandle nuklear::NkUserFont::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkUserFont::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_user_font*)NativePtr)->userdata = _marshal0;
}

float nuklear::NkUserFont::Height::get()
{
    return NativePtr->height;
}

void nuklear::NkUserFont::Height::set(float value)
{
    ((struct ::nk_user_font*)NativePtr)->height = value;
}

::nuklear::NkTextWidthF^ nuklear::NkUserFont::Width::get()
{
    return NativePtr->width == nullptr ? nullptr : safe_cast<::nuklear::NkTextWidthF^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->width), ::nuklear::NkTextWidthF::typeid));
}

void nuklear::NkUserFont::Width::set(::nuklear::NkTextWidthF^ value)
{
    ((struct ::nk_user_font*)NativePtr)->width = static_cast<::nk_text_width_f>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkMemoryStatus::NkMemoryStatus(struct ::nk_memory_status* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkMemoryStatus^ nuklear::NkMemoryStatus::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkMemoryStatus((struct ::nk_memory_status*) native.ToPointer());
}

nuklear::NkMemoryStatus::NkMemoryStatus(struct ::nk_memory_status* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkMemoryStatus^ nuklear::NkMemoryStatus::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkMemoryStatus((struct ::nk_memory_status*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkMemoryStatus::~NkMemoryStatus()
{
    delete NativePtr;
}

nuklear::NkMemoryStatus::!NkMemoryStatus()
{
    delete NativePtr;
}

nuklear::NkMemoryStatus::NkMemoryStatus()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_memory_status();
}

nuklear::NkMemoryStatus::NkMemoryStatus(::nuklear::NkMemoryStatus^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_memory_status*)_0->NativePtr;
    NativePtr = new struct ::nk_memory_status(__arg0);
}

::System::IntPtr nuklear::NkMemoryStatus::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkMemoryStatus::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_memory_status*)object.ToPointer();
}

::System::IntPtr nuklear::NkMemoryStatus::Memory::get()
{
    return ::System::IntPtr(NativePtr->memory);
}

void nuklear::NkMemoryStatus::Memory::set(::System::IntPtr value)
{
    ((struct ::nk_memory_status*)NativePtr)->memory = (void*)value;
}

unsigned int nuklear::NkMemoryStatus::Type::get()
{
    return NativePtr->type;
}

void nuklear::NkMemoryStatus::Type::set(unsigned int value)
{
    ((struct ::nk_memory_status*)NativePtr)->type = value;
}

unsigned long long nuklear::NkMemoryStatus::Size::get()
{
    return NativePtr->size;
}

void nuklear::NkMemoryStatus::Size::set(unsigned long long value)
{
    ((struct ::nk_memory_status*)NativePtr)->size = (::nk_size)value;
}

unsigned long long nuklear::NkMemoryStatus::Allocated::get()
{
    return NativePtr->allocated;
}

void nuklear::NkMemoryStatus::Allocated::set(unsigned long long value)
{
    ((struct ::nk_memory_status*)NativePtr)->allocated = (::nk_size)value;
}

unsigned long long nuklear::NkMemoryStatus::Needed::get()
{
    return NativePtr->needed;
}

void nuklear::NkMemoryStatus::Needed::set(unsigned long long value)
{
    ((struct ::nk_memory_status*)NativePtr)->needed = (::nk_size)value;
}

unsigned long long nuklear::NkMemoryStatus::Calls::get()
{
    return NativePtr->calls;
}

void nuklear::NkMemoryStatus::Calls::set(unsigned long long value)
{
    ((struct ::nk_memory_status*)NativePtr)->calls = (::nk_size)value;
}

nuklear::NkBufferMarker::NkBufferMarker(struct ::nk_buffer_marker* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkBufferMarker^ nuklear::NkBufferMarker::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkBufferMarker((struct ::nk_buffer_marker*) native.ToPointer());
}

nuklear::NkBufferMarker::NkBufferMarker(struct ::nk_buffer_marker* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkBufferMarker^ nuklear::NkBufferMarker::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkBufferMarker((struct ::nk_buffer_marker*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkBufferMarker::~NkBufferMarker()
{
    delete NativePtr;
}

nuklear::NkBufferMarker::!NkBufferMarker()
{
    delete NativePtr;
}

nuklear::NkBufferMarker::NkBufferMarker()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_buffer_marker();
}

nuklear::NkBufferMarker::NkBufferMarker(::nuklear::NkBufferMarker^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_buffer_marker*)_0->NativePtr;
    NativePtr = new struct ::nk_buffer_marker(__arg0);
}

::System::IntPtr nuklear::NkBufferMarker::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkBufferMarker::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_buffer_marker*)object.ToPointer();
}

int nuklear::NkBufferMarker::Active::get()
{
    return NativePtr->active;
}

void nuklear::NkBufferMarker::Active::set(int value)
{
    ((struct ::nk_buffer_marker*)NativePtr)->active = value;
}

unsigned long long nuklear::NkBufferMarker::Offset::get()
{
    return NativePtr->offset;
}

void nuklear::NkBufferMarker::Offset::set(unsigned long long value)
{
    ((struct ::nk_buffer_marker*)NativePtr)->offset = (::nk_size)value;
}

nuklear::NkMemory::NkMemory(struct ::nk_memory* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkMemory^ nuklear::NkMemory::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkMemory((struct ::nk_memory*) native.ToPointer());
}

nuklear::NkMemory::NkMemory(struct ::nk_memory* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkMemory^ nuklear::NkMemory::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkMemory((struct ::nk_memory*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkMemory::~NkMemory()
{
    delete NativePtr;
}

nuklear::NkMemory::!NkMemory()
{
    delete NativePtr;
}

nuklear::NkMemory::NkMemory()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_memory();
}

nuklear::NkMemory::NkMemory(::nuklear::NkMemory^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_memory*)_0->NativePtr;
    NativePtr = new struct ::nk_memory(__arg0);
}

::System::IntPtr nuklear::NkMemory::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkMemory::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_memory*)object.ToPointer();
}

::System::IntPtr nuklear::NkMemory::Ptr::get()
{
    return ::System::IntPtr(NativePtr->ptr);
}

void nuklear::NkMemory::Ptr::set(::System::IntPtr value)
{
    ((struct ::nk_memory*)NativePtr)->ptr = (void*)value;
}

unsigned long long nuklear::NkMemory::Size::get()
{
    return NativePtr->size;
}

void nuklear::NkMemory::Size::set(unsigned long long value)
{
    ((struct ::nk_memory*)NativePtr)->size = (::nk_size)value;
}

nuklear::NkBuffer::NkBuffer(struct ::nk_buffer* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkBuffer^ nuklear::NkBuffer::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkBuffer((struct ::nk_buffer*) native.ToPointer());
}

nuklear::NkBuffer::NkBuffer(struct ::nk_buffer* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkBuffer^ nuklear::NkBuffer::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkBuffer((struct ::nk_buffer*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkBuffer::~NkBuffer()
{
    delete NativePtr;
}

nuklear::NkBuffer::!NkBuffer()
{
    delete NativePtr;
}

nuklear::NkBuffer::NkBuffer()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_buffer();
}

nuklear::NkBuffer::NkBuffer(::nuklear::NkBuffer^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_buffer*)_0->NativePtr;
    NativePtr = new struct ::nk_buffer(__arg0);
}

::System::IntPtr nuklear::NkBuffer::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkBuffer::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_buffer*)object.ToPointer();
}

cli::array<::nuklear::NkBufferMarker^>^ nuklear::NkBuffer::Marker::get()
{
    cli::array<::nuklear::NkBufferMarker^>^ __array0 = nullptr;
    if (NativePtr->marker != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkBufferMarker^>(2);
        for (int i = 0; i < 2; i++)
            __array0[i] = gcnew ::nuklear::NkBufferMarker(&NativePtr->marker[i]);
    }
    return __array0;
}

void nuklear::NkBuffer::Marker::set(cli::array<::nuklear::NkBufferMarker^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 2)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 2; i++)
            ((struct ::nk_buffer*)NativePtr)->marker[i] = *value[i]->NativePtr;
    }
}

::nuklear::NkAllocator^ nuklear::NkBuffer::Pool::get()
{
    return (&NativePtr->pool == nullptr) ? nullptr : gcnew ::nuklear::NkAllocator((struct ::nk_allocator*)&NativePtr->pool);
}

void nuklear::NkBuffer::Pool::set(::nuklear::NkAllocator^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_buffer*)NativePtr)->pool = *(struct ::nk_allocator*)value->NativePtr;
}

::nuklear::NkAllocationType nuklear::NkBuffer::Type::get()
{
    return (::nuklear::NkAllocationType)NativePtr->type;
}

void nuklear::NkBuffer::Type::set(::nuklear::NkAllocationType value)
{
    ((struct ::nk_buffer*)NativePtr)->type = (enum ::nk_allocation_type)value;
}

::nuklear::NkMemory^ nuklear::NkBuffer::Memory::get()
{
    return (&NativePtr->memory == nullptr) ? nullptr : gcnew ::nuklear::NkMemory((struct ::nk_memory*)&NativePtr->memory);
}

void nuklear::NkBuffer::Memory::set(::nuklear::NkMemory^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_buffer*)NativePtr)->memory = *(struct ::nk_memory*)value->NativePtr;
}

float nuklear::NkBuffer::GrowFactor::get()
{
    return NativePtr->grow_factor;
}

void nuklear::NkBuffer::GrowFactor::set(float value)
{
    ((struct ::nk_buffer*)NativePtr)->grow_factor = value;
}

unsigned long long nuklear::NkBuffer::Allocated::get()
{
    return NativePtr->allocated;
}

void nuklear::NkBuffer::Allocated::set(unsigned long long value)
{
    ((struct ::nk_buffer*)NativePtr)->allocated = (::nk_size)value;
}

unsigned long long nuklear::NkBuffer::Needed::get()
{
    return NativePtr->needed;
}

void nuklear::NkBuffer::Needed::set(unsigned long long value)
{
    ((struct ::nk_buffer*)NativePtr)->needed = (::nk_size)value;
}

unsigned long long nuklear::NkBuffer::Calls::get()
{
    return NativePtr->calls;
}

void nuklear::NkBuffer::Calls::set(unsigned long long value)
{
    ((struct ::nk_buffer*)NativePtr)->calls = (::nk_size)value;
}

unsigned long long nuklear::NkBuffer::Size::get()
{
    return NativePtr->size;
}

void nuklear::NkBuffer::Size::set(unsigned long long value)
{
    ((struct ::nk_buffer*)NativePtr)->size = (::nk_size)value;
}

nuklear::NkStr::NkStr(struct ::nk_str* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStr^ nuklear::NkStr::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStr((struct ::nk_str*) native.ToPointer());
}

nuklear::NkStr::NkStr(struct ::nk_str* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStr^ nuklear::NkStr::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStr((struct ::nk_str*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStr::~NkStr()
{
    delete NativePtr;
}

nuklear::NkStr::!NkStr()
{
    delete NativePtr;
}

nuklear::NkStr::NkStr()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_str();
}

nuklear::NkStr::NkStr(::nuklear::NkStr^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_str*)_0->NativePtr;
    NativePtr = new struct ::nk_str(__arg0);
}

::System::IntPtr nuklear::NkStr::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStr::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_str*)object.ToPointer();
}

::nuklear::NkBuffer^ nuklear::NkStr::Buffer::get()
{
    return (&NativePtr->buffer == nullptr) ? nullptr : gcnew ::nuklear::NkBuffer((struct ::nk_buffer*)&NativePtr->buffer);
}

void nuklear::NkStr::Buffer::set(::nuklear::NkBuffer^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_str*)NativePtr)->buffer = *(struct ::nk_buffer*)value->NativePtr;
}

int nuklear::NkStr::Len::get()
{
    return NativePtr->len;
}

void nuklear::NkStr::Len::set(int value)
{
    ((struct ::nk_str*)NativePtr)->len = value;
}

nuklear::NkClipboard::NkClipboard(struct ::nk_clipboard* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkClipboard^ nuklear::NkClipboard::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkClipboard((struct ::nk_clipboard*) native.ToPointer());
}

nuklear::NkClipboard::NkClipboard(struct ::nk_clipboard* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkClipboard^ nuklear::NkClipboard::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkClipboard((struct ::nk_clipboard*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkClipboard::~NkClipboard()
{
    delete NativePtr;
}

nuklear::NkClipboard::!NkClipboard()
{
    delete NativePtr;
}

nuklear::NkClipboard::NkClipboard()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_clipboard();
}

nuklear::NkClipboard::NkClipboard(::nuklear::NkClipboard^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_clipboard*)_0->NativePtr;
    NativePtr = new struct ::nk_clipboard(__arg0);
}

::System::IntPtr nuklear::NkClipboard::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkClipboard::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_clipboard*)object.ToPointer();
}

::nuklear::NkHandle nuklear::NkClipboard::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkClipboard::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_clipboard*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkPluginPaste^ nuklear::NkClipboard::Paste::get()
{
    return NativePtr->paste == nullptr ? nullptr : safe_cast<::nuklear::NkPluginPaste^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->paste), ::nuklear::NkPluginPaste::typeid));
}

void nuklear::NkClipboard::Paste::set(::nuklear::NkPluginPaste^ value)
{
    ((struct ::nk_clipboard*)NativePtr)->paste = static_cast<::nk_plugin_paste>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkPluginCopy^ nuklear::NkClipboard::Copy::get()
{
    return NativePtr->copy == nullptr ? nullptr : safe_cast<::nuklear::NkPluginCopy^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->copy), ::nuklear::NkPluginCopy::typeid));
}

void nuklear::NkClipboard::Copy::set(::nuklear::NkPluginCopy^ value)
{
    ((struct ::nk_clipboard*)NativePtr)->copy = static_cast<::nk_plugin_copy>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkTextUndoRecord::NkTextUndoRecord(struct ::nk_text_undo_record* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkTextUndoRecord^ nuklear::NkTextUndoRecord::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkTextUndoRecord((struct ::nk_text_undo_record*) native.ToPointer());
}

nuklear::NkTextUndoRecord::NkTextUndoRecord(struct ::nk_text_undo_record* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkTextUndoRecord^ nuklear::NkTextUndoRecord::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkTextUndoRecord((struct ::nk_text_undo_record*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkTextUndoRecord::~NkTextUndoRecord()
{
    delete NativePtr;
}

nuklear::NkTextUndoRecord::!NkTextUndoRecord()
{
    delete NativePtr;
}

nuklear::NkTextUndoRecord::NkTextUndoRecord()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_text_undo_record();
}

nuklear::NkTextUndoRecord::NkTextUndoRecord(::nuklear::NkTextUndoRecord^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_text_undo_record*)_0->NativePtr;
    NativePtr = new struct ::nk_text_undo_record(__arg0);
}

::System::IntPtr nuklear::NkTextUndoRecord::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkTextUndoRecord::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_text_undo_record*)object.ToPointer();
}

int nuklear::NkTextUndoRecord::Where::get()
{
    return NativePtr->where;
}

void nuklear::NkTextUndoRecord::Where::set(int value)
{
    ((struct ::nk_text_undo_record*)NativePtr)->where = value;
}

short nuklear::NkTextUndoRecord::InsertLength::get()
{
    return NativePtr->insert_length;
}

void nuklear::NkTextUndoRecord::InsertLength::set(short value)
{
    ((struct ::nk_text_undo_record*)NativePtr)->insert_length = value;
}

short nuklear::NkTextUndoRecord::DeleteLength::get()
{
    return NativePtr->delete_length;
}

void nuklear::NkTextUndoRecord::DeleteLength::set(short value)
{
    ((struct ::nk_text_undo_record*)NativePtr)->delete_length = value;
}

short nuklear::NkTextUndoRecord::CharStorage::get()
{
    return NativePtr->char_storage;
}

void nuklear::NkTextUndoRecord::CharStorage::set(short value)
{
    ((struct ::nk_text_undo_record*)NativePtr)->char_storage = value;
}

nuklear::NkTextUndoState::NkTextUndoState(struct ::nk_text_undo_state* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkTextUndoState^ nuklear::NkTextUndoState::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkTextUndoState((struct ::nk_text_undo_state*) native.ToPointer());
}

nuklear::NkTextUndoState::NkTextUndoState(struct ::nk_text_undo_state* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkTextUndoState^ nuklear::NkTextUndoState::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkTextUndoState((struct ::nk_text_undo_state*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkTextUndoState::~NkTextUndoState()
{
    delete NativePtr;
}

nuklear::NkTextUndoState::!NkTextUndoState()
{
    delete NativePtr;
}

nuklear::NkTextUndoState::NkTextUndoState()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_text_undo_state();
}

nuklear::NkTextUndoState::NkTextUndoState(::nuklear::NkTextUndoState^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_text_undo_state*)_0->NativePtr;
    NativePtr = new struct ::nk_text_undo_state(__arg0);
}

::System::IntPtr nuklear::NkTextUndoState::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkTextUndoState::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_text_undo_state*)object.ToPointer();
}

cli::array<::nuklear::NkTextUndoRecord^>^ nuklear::NkTextUndoState::UndoRec::get()
{
    cli::array<::nuklear::NkTextUndoRecord^>^ __array0 = nullptr;
    if (NativePtr->undo_rec != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkTextUndoRecord^>(99);
        for (int i = 0; i < 99; i++)
            __array0[i] = gcnew ::nuklear::NkTextUndoRecord(&NativePtr->undo_rec[i]);
    }
    return __array0;
}

void nuklear::NkTextUndoState::UndoRec::set(cli::array<::nuklear::NkTextUndoRecord^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 99)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 99; i++)
            ((struct ::nk_text_undo_state*)NativePtr)->undo_rec[i] = *value[i]->NativePtr;
    }
}

cli::array<unsigned int>^ nuklear::NkTextUndoState::UndoChar::get()
{
    cli::array<unsigned int>^ __array0 = nullptr;
    if (NativePtr->undo_char != 0)
    {
        __array0 = gcnew cli::array<unsigned int>(999);
        for (int i = 0; i < 999; i++)
            __array0[i] = NativePtr->undo_char[i];
    }
    return __array0;
}

void nuklear::NkTextUndoState::UndoChar::set(cli::array<unsigned int>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 999)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 999; i++)
            ((struct ::nk_text_undo_state*)NativePtr)->undo_char[i] = value[i];
    }
}

short nuklear::NkTextUndoState::UndoPoint::get()
{
    return NativePtr->undo_point;
}

void nuklear::NkTextUndoState::UndoPoint::set(short value)
{
    ((struct ::nk_text_undo_state*)NativePtr)->undo_point = value;
}

short nuklear::NkTextUndoState::RedoPoint::get()
{
    return NativePtr->redo_point;
}

void nuklear::NkTextUndoState::RedoPoint::set(short value)
{
    ((struct ::nk_text_undo_state*)NativePtr)->redo_point = value;
}

short nuklear::NkTextUndoState::UndoCharPoint::get()
{
    return NativePtr->undo_char_point;
}

void nuklear::NkTextUndoState::UndoCharPoint::set(short value)
{
    ((struct ::nk_text_undo_state*)NativePtr)->undo_char_point = value;
}

short nuklear::NkTextUndoState::RedoCharPoint::get()
{
    return NativePtr->redo_char_point;
}

void nuklear::NkTextUndoState::RedoCharPoint::set(short value)
{
    ((struct ::nk_text_undo_state*)NativePtr)->redo_char_point = value;
}

nuklear::NkTextEdit::NkTextEdit(struct ::nk_text_edit* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkTextEdit^ nuklear::NkTextEdit::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkTextEdit((struct ::nk_text_edit*) native.ToPointer());
}

nuklear::NkTextEdit::NkTextEdit(struct ::nk_text_edit* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkTextEdit^ nuklear::NkTextEdit::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkTextEdit((struct ::nk_text_edit*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkTextEdit::~NkTextEdit()
{
    delete NativePtr;
}

nuklear::NkTextEdit::!NkTextEdit()
{
    delete NativePtr;
}

nuklear::NkTextEdit::NkTextEdit()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_text_edit();
}

nuklear::NkTextEdit::NkTextEdit(::nuklear::NkTextEdit^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_text_edit*)_0->NativePtr;
    NativePtr = new struct ::nk_text_edit(__arg0);
}

::System::IntPtr nuklear::NkTextEdit::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkTextEdit::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_text_edit*)object.ToPointer();
}

::nuklear::NkClipboard^ nuklear::NkTextEdit::Clip::get()
{
    return (&NativePtr->clip == nullptr) ? nullptr : gcnew ::nuklear::NkClipboard((struct ::nk_clipboard*)&NativePtr->clip);
}

void nuklear::NkTextEdit::Clip::set(::nuklear::NkClipboard^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_text_edit*)NativePtr)->clip = *(struct ::nk_clipboard*)value->NativePtr;
}

::nuklear::NkStr^ nuklear::NkTextEdit::String::get()
{
    return (&NativePtr->string == nullptr) ? nullptr : gcnew ::nuklear::NkStr((struct ::nk_str*)&NativePtr->string);
}

void nuklear::NkTextEdit::String::set(::nuklear::NkStr^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_text_edit*)NativePtr)->string = *(struct ::nk_str*)value->NativePtr;
}

::nuklear::NkPluginFilter^ nuklear::NkTextEdit::Filter::get()
{
    return NativePtr->filter == nullptr ? nullptr : safe_cast<::nuklear::NkPluginFilter^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->filter), ::nuklear::NkPluginFilter::typeid));
}

void nuklear::NkTextEdit::Filter::set(::nuklear::NkPluginFilter^ value)
{
    ((struct ::nk_text_edit*)NativePtr)->filter = static_cast<::nk_plugin_filter>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkVec2^ nuklear::NkTextEdit::Scrollbar::get()
{
    return (&NativePtr->scrollbar == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->scrollbar);
}

void nuklear::NkTextEdit::Scrollbar::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_text_edit*)NativePtr)->scrollbar = *(struct ::nk_vec2*)value->NativePtr;
}

int nuklear::NkTextEdit::Cursor::get()
{
    return NativePtr->cursor;
}

void nuklear::NkTextEdit::Cursor::set(int value)
{
    ((struct ::nk_text_edit*)NativePtr)->cursor = value;
}

int nuklear::NkTextEdit::SelectStart::get()
{
    return NativePtr->select_start;
}

void nuklear::NkTextEdit::SelectStart::set(int value)
{
    ((struct ::nk_text_edit*)NativePtr)->select_start = value;
}

int nuklear::NkTextEdit::SelectEnd::get()
{
    return NativePtr->select_end;
}

void nuklear::NkTextEdit::SelectEnd::set(int value)
{
    ((struct ::nk_text_edit*)NativePtr)->select_end = value;
}

unsigned char nuklear::NkTextEdit::Mode::get()
{
    return NativePtr->mode;
}

void nuklear::NkTextEdit::Mode::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->mode = value;
}

unsigned char nuklear::NkTextEdit::CursorAtEndOfLine::get()
{
    return NativePtr->cursor_at_end_of_line;
}

void nuklear::NkTextEdit::CursorAtEndOfLine::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->cursor_at_end_of_line = value;
}

unsigned char nuklear::NkTextEdit::Initialized::get()
{
    return NativePtr->initialized;
}

void nuklear::NkTextEdit::Initialized::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->initialized = value;
}

unsigned char nuklear::NkTextEdit::HasPreferredX::get()
{
    return NativePtr->has_preferred_x;
}

void nuklear::NkTextEdit::HasPreferredX::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->has_preferred_x = value;
}

unsigned char nuklear::NkTextEdit::SingleLine::get()
{
    return NativePtr->single_line;
}

void nuklear::NkTextEdit::SingleLine::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->single_line = value;
}

unsigned char nuklear::NkTextEdit::Active::get()
{
    return NativePtr->active;
}

void nuklear::NkTextEdit::Active::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->active = value;
}

unsigned char nuklear::NkTextEdit::Padding1::get()
{
    return NativePtr->padding1;
}

void nuklear::NkTextEdit::Padding1::set(unsigned char value)
{
    ((struct ::nk_text_edit*)NativePtr)->padding1 = value;
}

float nuklear::NkTextEdit::PreferredX::get()
{
    return NativePtr->preferred_x;
}

void nuklear::NkTextEdit::PreferredX::set(float value)
{
    ((struct ::nk_text_edit*)NativePtr)->preferred_x = value;
}

::nuklear::NkTextUndoState^ nuklear::NkTextEdit::Undo::get()
{
    return (&NativePtr->undo == nullptr) ? nullptr : gcnew ::nuklear::NkTextUndoState((struct ::nk_text_undo_state*)&NativePtr->undo);
}

void nuklear::NkTextEdit::Undo::set(::nuklear::NkTextUndoState^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_text_edit*)NativePtr)->undo = *(struct ::nk_text_undo_state*)value->NativePtr;
}

nuklear::NkCommand::NkCommand(struct ::nk_command* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommand^ nuklear::NkCommand::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommand((struct ::nk_command*) native.ToPointer());
}

nuklear::NkCommand::NkCommand(struct ::nk_command* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommand^ nuklear::NkCommand::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommand((struct ::nk_command*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommand::~NkCommand()
{
    delete NativePtr;
}

nuklear::NkCommand::!NkCommand()
{
    delete NativePtr;
}

nuklear::NkCommand::NkCommand()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command();
}

nuklear::NkCommand::NkCommand(::nuklear::NkCommand^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command*)_0->NativePtr;
    NativePtr = new struct ::nk_command(__arg0);
}

::System::IntPtr nuklear::NkCommand::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommand::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command*)object.ToPointer();
}

::nuklear::NkCommandType nuklear::NkCommand::Type::get()
{
    return (::nuklear::NkCommandType)NativePtr->type;
}

void nuklear::NkCommand::Type::set(::nuklear::NkCommandType value)
{
    ((struct ::nk_command*)NativePtr)->type = (enum ::nk_command_type)value;
}

unsigned long long nuklear::NkCommand::Next::get()
{
    return NativePtr->next;
}

void nuklear::NkCommand::Next::set(unsigned long long value)
{
    ((struct ::nk_command*)NativePtr)->next = (::nk_size)value;
}

nuklear::NkCommandScissor::NkCommandScissor(struct ::nk_command_scissor* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandScissor^ nuklear::NkCommandScissor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandScissor((struct ::nk_command_scissor*) native.ToPointer());
}

nuklear::NkCommandScissor::NkCommandScissor(struct ::nk_command_scissor* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandScissor^ nuklear::NkCommandScissor::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandScissor((struct ::nk_command_scissor*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandScissor::~NkCommandScissor()
{
    delete NativePtr;
}

nuklear::NkCommandScissor::!NkCommandScissor()
{
    delete NativePtr;
}

nuklear::NkCommandScissor::NkCommandScissor()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_scissor();
}

nuklear::NkCommandScissor::NkCommandScissor(::nuklear::NkCommandScissor^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_scissor*)_0->NativePtr;
    NativePtr = new struct ::nk_command_scissor(__arg0);
}

::System::IntPtr nuklear::NkCommandScissor::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandScissor::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_scissor*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandScissor::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandScissor::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_scissor*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandScissor::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandScissor::X::set(short value)
{
    ((struct ::nk_command_scissor*)NativePtr)->x = value;
}

short nuklear::NkCommandScissor::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandScissor::Y::set(short value)
{
    ((struct ::nk_command_scissor*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandScissor::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandScissor::W::set(unsigned short value)
{
    ((struct ::nk_command_scissor*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandScissor::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandScissor::H::set(unsigned short value)
{
    ((struct ::nk_command_scissor*)NativePtr)->h = value;
}

nuklear::NkCommandLine::NkCommandLine(struct ::nk_command_line* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandLine^ nuklear::NkCommandLine::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandLine((struct ::nk_command_line*) native.ToPointer());
}

nuklear::NkCommandLine::NkCommandLine(struct ::nk_command_line* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandLine^ nuklear::NkCommandLine::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandLine((struct ::nk_command_line*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandLine::~NkCommandLine()
{
    delete NativePtr;
}

nuklear::NkCommandLine::!NkCommandLine()
{
    delete NativePtr;
}

nuklear::NkCommandLine::NkCommandLine()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_line();
}

nuklear::NkCommandLine::NkCommandLine(::nuklear::NkCommandLine^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_line*)_0->NativePtr;
    NativePtr = new struct ::nk_command_line(__arg0);
}

::System::IntPtr nuklear::NkCommandLine::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandLine::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_line*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandLine::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandLine::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_line*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

unsigned short nuklear::NkCommandLine::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandLine::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_line*)NativePtr)->line_thickness = value;
}

::nuklear::NkVec2i^ nuklear::NkCommandLine::Begin::get()
{
    return (&NativePtr->begin == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->begin);
}

void nuklear::NkCommandLine::Begin::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_line*)NativePtr)->begin = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandLine::End::get()
{
    return (&NativePtr->end == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->end);
}

void nuklear::NkCommandLine::End::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_line*)NativePtr)->end = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandLine::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandLine::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_line*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandCurve::NkCommandCurve(struct ::nk_command_curve* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandCurve^ nuklear::NkCommandCurve::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandCurve((struct ::nk_command_curve*) native.ToPointer());
}

nuklear::NkCommandCurve::NkCommandCurve(struct ::nk_command_curve* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandCurve^ nuklear::NkCommandCurve::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandCurve((struct ::nk_command_curve*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandCurve::~NkCommandCurve()
{
    delete NativePtr;
}

nuklear::NkCommandCurve::!NkCommandCurve()
{
    delete NativePtr;
}

nuklear::NkCommandCurve::NkCommandCurve()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_curve();
}

nuklear::NkCommandCurve::NkCommandCurve(::nuklear::NkCommandCurve^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_curve*)_0->NativePtr;
    NativePtr = new struct ::nk_command_curve(__arg0);
}

::System::IntPtr nuklear::NkCommandCurve::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandCurve::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_curve*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandCurve::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandCurve::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_curve*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

unsigned short nuklear::NkCommandCurve::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandCurve::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_curve*)NativePtr)->line_thickness = value;
}

::nuklear::NkVec2i^ nuklear::NkCommandCurve::Begin::get()
{
    return (&NativePtr->begin == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->begin);
}

void nuklear::NkCommandCurve::Begin::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_curve*)NativePtr)->begin = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandCurve::End::get()
{
    return (&NativePtr->end == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->end);
}

void nuklear::NkCommandCurve::End::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_curve*)NativePtr)->end = *(struct ::nk_vec2i*)value->NativePtr;
}

cli::array<::nuklear::NkVec2i^>^ nuklear::NkCommandCurve::Ctrl::get()
{
    cli::array<::nuklear::NkVec2i^>^ __array0 = nullptr;
    if (NativePtr->ctrl != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkVec2i^>(2);
        for (int i = 0; i < 2; i++)
            __array0[i] = gcnew ::nuklear::NkVec2i(&NativePtr->ctrl[i]);
    }
    return __array0;
}

void nuklear::NkCommandCurve::Ctrl::set(cli::array<::nuklear::NkVec2i^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 2)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 2; i++)
            ((struct ::nk_command_curve*)NativePtr)->ctrl[i] = *value[i]->NativePtr;
    }
}

::nuklear::NkColor^ nuklear::NkCommandCurve::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandCurve::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_curve*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandRect::NkCommandRect(struct ::nk_command_rect* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandRect^ nuklear::NkCommandRect::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandRect((struct ::nk_command_rect*) native.ToPointer());
}

nuklear::NkCommandRect::NkCommandRect(struct ::nk_command_rect* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandRect^ nuklear::NkCommandRect::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandRect((struct ::nk_command_rect*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandRect::~NkCommandRect()
{
    delete NativePtr;
}

nuklear::NkCommandRect::!NkCommandRect()
{
    delete NativePtr;
}

nuklear::NkCommandRect::NkCommandRect()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_rect();
}

nuklear::NkCommandRect::NkCommandRect(::nuklear::NkCommandRect^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_rect*)_0->NativePtr;
    NativePtr = new struct ::nk_command_rect(__arg0);
}

::System::IntPtr nuklear::NkCommandRect::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandRect::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_rect*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandRect::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandRect::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

unsigned short nuklear::NkCommandRect::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkCommandRect::Rounding::set(unsigned short value)
{
    ((struct ::nk_command_rect*)NativePtr)->rounding = value;
}

unsigned short nuklear::NkCommandRect::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandRect::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_rect*)NativePtr)->line_thickness = value;
}

short nuklear::NkCommandRect::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandRect::X::set(short value)
{
    ((struct ::nk_command_rect*)NativePtr)->x = value;
}

short nuklear::NkCommandRect::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandRect::Y::set(short value)
{
    ((struct ::nk_command_rect*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandRect::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandRect::W::set(unsigned short value)
{
    ((struct ::nk_command_rect*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandRect::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandRect::H::set(unsigned short value)
{
    ((struct ::nk_command_rect*)NativePtr)->h = value;
}

::nuklear::NkColor^ nuklear::NkCommandRect::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandRect::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandRectFilled::NkCommandRectFilled(struct ::nk_command_rect_filled* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandRectFilled^ nuklear::NkCommandRectFilled::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandRectFilled((struct ::nk_command_rect_filled*) native.ToPointer());
}

nuklear::NkCommandRectFilled::NkCommandRectFilled(struct ::nk_command_rect_filled* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandRectFilled^ nuklear::NkCommandRectFilled::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandRectFilled((struct ::nk_command_rect_filled*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandRectFilled::~NkCommandRectFilled()
{
    delete NativePtr;
}

nuklear::NkCommandRectFilled::!NkCommandRectFilled()
{
    delete NativePtr;
}

nuklear::NkCommandRectFilled::NkCommandRectFilled()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_rect_filled();
}

nuklear::NkCommandRectFilled::NkCommandRectFilled(::nuklear::NkCommandRectFilled^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_rect_filled*)_0->NativePtr;
    NativePtr = new struct ::nk_command_rect_filled(__arg0);
}

::System::IntPtr nuklear::NkCommandRectFilled::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandRectFilled::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_rect_filled*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandRectFilled::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandRectFilled::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_filled*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

unsigned short nuklear::NkCommandRectFilled::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkCommandRectFilled::Rounding::set(unsigned short value)
{
    ((struct ::nk_command_rect_filled*)NativePtr)->rounding = value;
}

short nuklear::NkCommandRectFilled::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandRectFilled::X::set(short value)
{
    ((struct ::nk_command_rect_filled*)NativePtr)->x = value;
}

short nuklear::NkCommandRectFilled::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandRectFilled::Y::set(short value)
{
    ((struct ::nk_command_rect_filled*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandRectFilled::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandRectFilled::W::set(unsigned short value)
{
    ((struct ::nk_command_rect_filled*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandRectFilled::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandRectFilled::H::set(unsigned short value)
{
    ((struct ::nk_command_rect_filled*)NativePtr)->h = value;
}

::nuklear::NkColor^ nuklear::NkCommandRectFilled::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandRectFilled::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_filled*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandRectMultiColor::NkCommandRectMultiColor(struct ::nk_command_rect_multi_color* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandRectMultiColor^ nuklear::NkCommandRectMultiColor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandRectMultiColor((struct ::nk_command_rect_multi_color*) native.ToPointer());
}

nuklear::NkCommandRectMultiColor::NkCommandRectMultiColor(struct ::nk_command_rect_multi_color* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandRectMultiColor^ nuklear::NkCommandRectMultiColor::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandRectMultiColor((struct ::nk_command_rect_multi_color*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandRectMultiColor::~NkCommandRectMultiColor()
{
    delete NativePtr;
}

nuklear::NkCommandRectMultiColor::!NkCommandRectMultiColor()
{
    delete NativePtr;
}

nuklear::NkCommandRectMultiColor::NkCommandRectMultiColor()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_rect_multi_color();
}

nuklear::NkCommandRectMultiColor::NkCommandRectMultiColor(::nuklear::NkCommandRectMultiColor^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_rect_multi_color*)_0->NativePtr;
    NativePtr = new struct ::nk_command_rect_multi_color(__arg0);
}

::System::IntPtr nuklear::NkCommandRectMultiColor::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandRectMultiColor::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_rect_multi_color*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandRectMultiColor::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandRectMultiColor::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_multi_color*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandRectMultiColor::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandRectMultiColor::X::set(short value)
{
    ((struct ::nk_command_rect_multi_color*)NativePtr)->x = value;
}

short nuklear::NkCommandRectMultiColor::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandRectMultiColor::Y::set(short value)
{
    ((struct ::nk_command_rect_multi_color*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandRectMultiColor::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandRectMultiColor::W::set(unsigned short value)
{
    ((struct ::nk_command_rect_multi_color*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandRectMultiColor::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandRectMultiColor::H::set(unsigned short value)
{
    ((struct ::nk_command_rect_multi_color*)NativePtr)->h = value;
}

::nuklear::NkColor^ nuklear::NkCommandRectMultiColor::Left::get()
{
    return (&NativePtr->left == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->left);
}

void nuklear::NkCommandRectMultiColor::Left::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_multi_color*)NativePtr)->left = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandRectMultiColor::Top::get()
{
    return (&NativePtr->top == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->top);
}

void nuklear::NkCommandRectMultiColor::Top::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_multi_color*)NativePtr)->top = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandRectMultiColor::Bottom::get()
{
    return (&NativePtr->bottom == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->bottom);
}

void nuklear::NkCommandRectMultiColor::Bottom::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_multi_color*)NativePtr)->bottom = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandRectMultiColor::Right::get()
{
    return (&NativePtr->right == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->right);
}

void nuklear::NkCommandRectMultiColor::Right::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_rect_multi_color*)NativePtr)->right = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandTriangle::NkCommandTriangle(struct ::nk_command_triangle* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandTriangle^ nuklear::NkCommandTriangle::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandTriangle((struct ::nk_command_triangle*) native.ToPointer());
}

nuklear::NkCommandTriangle::NkCommandTriangle(struct ::nk_command_triangle* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandTriangle^ nuklear::NkCommandTriangle::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandTriangle((struct ::nk_command_triangle*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandTriangle::~NkCommandTriangle()
{
    delete NativePtr;
}

nuklear::NkCommandTriangle::!NkCommandTriangle()
{
    delete NativePtr;
}

nuklear::NkCommandTriangle::NkCommandTriangle()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_triangle();
}

nuklear::NkCommandTriangle::NkCommandTriangle(::nuklear::NkCommandTriangle^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_triangle*)_0->NativePtr;
    NativePtr = new struct ::nk_command_triangle(__arg0);
}

::System::IntPtr nuklear::NkCommandTriangle::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandTriangle::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_triangle*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandTriangle::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandTriangle::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

unsigned short nuklear::NkCommandTriangle::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandTriangle::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_triangle*)NativePtr)->line_thickness = value;
}

::nuklear::NkVec2i^ nuklear::NkCommandTriangle::A::get()
{
    return (&NativePtr->a == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->a);
}

void nuklear::NkCommandTriangle::A::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle*)NativePtr)->a = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandTriangle::B::get()
{
    return (&NativePtr->b == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->b);
}

void nuklear::NkCommandTriangle::B::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle*)NativePtr)->b = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandTriangle::C::get()
{
    return (&NativePtr->c == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->c);
}

void nuklear::NkCommandTriangle::C::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle*)NativePtr)->c = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandTriangle::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandTriangle::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandTriangleFilled::NkCommandTriangleFilled(struct ::nk_command_triangle_filled* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandTriangleFilled^ nuklear::NkCommandTriangleFilled::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandTriangleFilled((struct ::nk_command_triangle_filled*) native.ToPointer());
}

nuklear::NkCommandTriangleFilled::NkCommandTriangleFilled(struct ::nk_command_triangle_filled* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandTriangleFilled^ nuklear::NkCommandTriangleFilled::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandTriangleFilled((struct ::nk_command_triangle_filled*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandTriangleFilled::~NkCommandTriangleFilled()
{
    delete NativePtr;
}

nuklear::NkCommandTriangleFilled::!NkCommandTriangleFilled()
{
    delete NativePtr;
}

nuklear::NkCommandTriangleFilled::NkCommandTriangleFilled()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_triangle_filled();
}

nuklear::NkCommandTriangleFilled::NkCommandTriangleFilled(::nuklear::NkCommandTriangleFilled^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_triangle_filled*)_0->NativePtr;
    NativePtr = new struct ::nk_command_triangle_filled(__arg0);
}

::System::IntPtr nuklear::NkCommandTriangleFilled::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandTriangleFilled::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_triangle_filled*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandTriangleFilled::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandTriangleFilled::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle_filled*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandTriangleFilled::A::get()
{
    return (&NativePtr->a == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->a);
}

void nuklear::NkCommandTriangleFilled::A::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle_filled*)NativePtr)->a = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandTriangleFilled::B::get()
{
    return (&NativePtr->b == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->b);
}

void nuklear::NkCommandTriangleFilled::B::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle_filled*)NativePtr)->b = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkVec2i^ nuklear::NkCommandTriangleFilled::C::get()
{
    return (&NativePtr->c == nullptr) ? nullptr : gcnew ::nuklear::NkVec2i((struct ::nk_vec2i*)&NativePtr->c);
}

void nuklear::NkCommandTriangleFilled::C::set(::nuklear::NkVec2i^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle_filled*)NativePtr)->c = *(struct ::nk_vec2i*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandTriangleFilled::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandTriangleFilled::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_triangle_filled*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandCircle::NkCommandCircle(struct ::nk_command_circle* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandCircle^ nuklear::NkCommandCircle::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandCircle((struct ::nk_command_circle*) native.ToPointer());
}

nuklear::NkCommandCircle::NkCommandCircle(struct ::nk_command_circle* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandCircle^ nuklear::NkCommandCircle::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandCircle((struct ::nk_command_circle*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandCircle::~NkCommandCircle()
{
    delete NativePtr;
}

nuklear::NkCommandCircle::!NkCommandCircle()
{
    delete NativePtr;
}

nuklear::NkCommandCircle::NkCommandCircle()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_circle();
}

nuklear::NkCommandCircle::NkCommandCircle(::nuklear::NkCommandCircle^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_circle*)_0->NativePtr;
    NativePtr = new struct ::nk_command_circle(__arg0);
}

::System::IntPtr nuklear::NkCommandCircle::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandCircle::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_circle*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandCircle::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandCircle::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_circle*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandCircle::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandCircle::X::set(short value)
{
    ((struct ::nk_command_circle*)NativePtr)->x = value;
}

short nuklear::NkCommandCircle::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandCircle::Y::set(short value)
{
    ((struct ::nk_command_circle*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandCircle::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandCircle::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_circle*)NativePtr)->line_thickness = value;
}

unsigned short nuklear::NkCommandCircle::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandCircle::W::set(unsigned short value)
{
    ((struct ::nk_command_circle*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandCircle::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandCircle::H::set(unsigned short value)
{
    ((struct ::nk_command_circle*)NativePtr)->h = value;
}

::nuklear::NkColor^ nuklear::NkCommandCircle::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandCircle::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_circle*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandCircleFilled::NkCommandCircleFilled(struct ::nk_command_circle_filled* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandCircleFilled^ nuklear::NkCommandCircleFilled::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandCircleFilled((struct ::nk_command_circle_filled*) native.ToPointer());
}

nuklear::NkCommandCircleFilled::NkCommandCircleFilled(struct ::nk_command_circle_filled* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandCircleFilled^ nuklear::NkCommandCircleFilled::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandCircleFilled((struct ::nk_command_circle_filled*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandCircleFilled::~NkCommandCircleFilled()
{
    delete NativePtr;
}

nuklear::NkCommandCircleFilled::!NkCommandCircleFilled()
{
    delete NativePtr;
}

nuklear::NkCommandCircleFilled::NkCommandCircleFilled()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_circle_filled();
}

nuklear::NkCommandCircleFilled::NkCommandCircleFilled(::nuklear::NkCommandCircleFilled^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_circle_filled*)_0->NativePtr;
    NativePtr = new struct ::nk_command_circle_filled(__arg0);
}

::System::IntPtr nuklear::NkCommandCircleFilled::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandCircleFilled::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_circle_filled*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandCircleFilled::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandCircleFilled::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_circle_filled*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandCircleFilled::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandCircleFilled::X::set(short value)
{
    ((struct ::nk_command_circle_filled*)NativePtr)->x = value;
}

short nuklear::NkCommandCircleFilled::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandCircleFilled::Y::set(short value)
{
    ((struct ::nk_command_circle_filled*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandCircleFilled::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandCircleFilled::W::set(unsigned short value)
{
    ((struct ::nk_command_circle_filled*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandCircleFilled::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandCircleFilled::H::set(unsigned short value)
{
    ((struct ::nk_command_circle_filled*)NativePtr)->h = value;
}

::nuklear::NkColor^ nuklear::NkCommandCircleFilled::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandCircleFilled::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_circle_filled*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandArc::NkCommandArc(struct ::nk_command_arc* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandArc^ nuklear::NkCommandArc::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandArc((struct ::nk_command_arc*) native.ToPointer());
}

nuklear::NkCommandArc::NkCommandArc(struct ::nk_command_arc* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandArc^ nuklear::NkCommandArc::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandArc((struct ::nk_command_arc*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandArc::~NkCommandArc()
{
    delete NativePtr;
}

nuklear::NkCommandArc::!NkCommandArc()
{
    delete NativePtr;
}

nuklear::NkCommandArc::NkCommandArc()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_arc();
}

nuklear::NkCommandArc::NkCommandArc(::nuklear::NkCommandArc^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_arc*)_0->NativePtr;
    NativePtr = new struct ::nk_command_arc(__arg0);
}

::System::IntPtr nuklear::NkCommandArc::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandArc::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_arc*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandArc::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandArc::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_arc*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandArc::Cx::get()
{
    return NativePtr->cx;
}

void nuklear::NkCommandArc::Cx::set(short value)
{
    ((struct ::nk_command_arc*)NativePtr)->cx = value;
}

short nuklear::NkCommandArc::Cy::get()
{
    return NativePtr->cy;
}

void nuklear::NkCommandArc::Cy::set(short value)
{
    ((struct ::nk_command_arc*)NativePtr)->cy = value;
}

unsigned short nuklear::NkCommandArc::R::get()
{
    return NativePtr->r;
}

void nuklear::NkCommandArc::R::set(unsigned short value)
{
    ((struct ::nk_command_arc*)NativePtr)->r = value;
}

unsigned short nuklear::NkCommandArc::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandArc::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_arc*)NativePtr)->line_thickness = value;
}

cli::array<float>^ nuklear::NkCommandArc::A::get()
{
    cli::array<float>^ __array0 = nullptr;
    if (NativePtr->a != 0)
    {
        __array0 = gcnew cli::array<float>(2);
        for (int i = 0; i < 2; i++)
            __array0[i] = NativePtr->a[i];
    }
    return __array0;
}

void nuklear::NkCommandArc::A::set(cli::array<float>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 2)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 2; i++)
            ((struct ::nk_command_arc*)NativePtr)->a[i] = value[i];
    }
}

::nuklear::NkColor^ nuklear::NkCommandArc::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandArc::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_arc*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandArcFilled::NkCommandArcFilled(struct ::nk_command_arc_filled* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandArcFilled^ nuklear::NkCommandArcFilled::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandArcFilled((struct ::nk_command_arc_filled*) native.ToPointer());
}

nuklear::NkCommandArcFilled::NkCommandArcFilled(struct ::nk_command_arc_filled* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandArcFilled^ nuklear::NkCommandArcFilled::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandArcFilled((struct ::nk_command_arc_filled*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandArcFilled::~NkCommandArcFilled()
{
    delete NativePtr;
}

nuklear::NkCommandArcFilled::!NkCommandArcFilled()
{
    delete NativePtr;
}

nuklear::NkCommandArcFilled::NkCommandArcFilled()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_arc_filled();
}

nuklear::NkCommandArcFilled::NkCommandArcFilled(::nuklear::NkCommandArcFilled^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_arc_filled*)_0->NativePtr;
    NativePtr = new struct ::nk_command_arc_filled(__arg0);
}

::System::IntPtr nuklear::NkCommandArcFilled::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandArcFilled::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_arc_filled*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandArcFilled::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandArcFilled::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_arc_filled*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandArcFilled::Cx::get()
{
    return NativePtr->cx;
}

void nuklear::NkCommandArcFilled::Cx::set(short value)
{
    ((struct ::nk_command_arc_filled*)NativePtr)->cx = value;
}

short nuklear::NkCommandArcFilled::Cy::get()
{
    return NativePtr->cy;
}

void nuklear::NkCommandArcFilled::Cy::set(short value)
{
    ((struct ::nk_command_arc_filled*)NativePtr)->cy = value;
}

unsigned short nuklear::NkCommandArcFilled::R::get()
{
    return NativePtr->r;
}

void nuklear::NkCommandArcFilled::R::set(unsigned short value)
{
    ((struct ::nk_command_arc_filled*)NativePtr)->r = value;
}

cli::array<float>^ nuklear::NkCommandArcFilled::A::get()
{
    cli::array<float>^ __array0 = nullptr;
    if (NativePtr->a != 0)
    {
        __array0 = gcnew cli::array<float>(2);
        for (int i = 0; i < 2; i++)
            __array0[i] = NativePtr->a[i];
    }
    return __array0;
}

void nuklear::NkCommandArcFilled::A::set(cli::array<float>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 2)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 2; i++)
            ((struct ::nk_command_arc_filled*)NativePtr)->a[i] = value[i];
    }
}

::nuklear::NkColor^ nuklear::NkCommandArcFilled::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandArcFilled::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_arc_filled*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandPolygon::NkCommandPolygon(struct ::nk_command_polygon* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandPolygon^ nuklear::NkCommandPolygon::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandPolygon((struct ::nk_command_polygon*) native.ToPointer());
}

nuklear::NkCommandPolygon::NkCommandPolygon(struct ::nk_command_polygon* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandPolygon^ nuklear::NkCommandPolygon::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandPolygon((struct ::nk_command_polygon*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandPolygon::~NkCommandPolygon()
{
    delete NativePtr;
}

nuklear::NkCommandPolygon::!NkCommandPolygon()
{
    delete NativePtr;
}

nuklear::NkCommandPolygon::NkCommandPolygon()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_polygon();
}

nuklear::NkCommandPolygon::NkCommandPolygon(::nuklear::NkCommandPolygon^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_polygon*)_0->NativePtr;
    NativePtr = new struct ::nk_command_polygon(__arg0);
}

::System::IntPtr nuklear::NkCommandPolygon::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandPolygon::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_polygon*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandPolygon::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandPolygon::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_polygon*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandPolygon::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandPolygon::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_polygon*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

unsigned short nuklear::NkCommandPolygon::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandPolygon::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_polygon*)NativePtr)->line_thickness = value;
}

unsigned short nuklear::NkCommandPolygon::PointCount::get()
{
    return NativePtr->point_count;
}

void nuklear::NkCommandPolygon::PointCount::set(unsigned short value)
{
    ((struct ::nk_command_polygon*)NativePtr)->point_count = value;
}

cli::array<::nuklear::NkVec2i^>^ nuklear::NkCommandPolygon::Points::get()
{
    cli::array<::nuklear::NkVec2i^>^ __array0 = nullptr;
    if (NativePtr->points != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkVec2i^>(1);
        for (int i = 0; i < 1; i++)
            __array0[i] = gcnew ::nuklear::NkVec2i(&NativePtr->points[i]);
    }
    return __array0;
}

void nuklear::NkCommandPolygon::Points::set(cli::array<::nuklear::NkVec2i^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 1)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 1; i++)
            ((struct ::nk_command_polygon*)NativePtr)->points[i] = *value[i]->NativePtr;
    }
}

nuklear::NkCommandPolygonFilled::NkCommandPolygonFilled(struct ::nk_command_polygon_filled* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandPolygonFilled^ nuklear::NkCommandPolygonFilled::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandPolygonFilled((struct ::nk_command_polygon_filled*) native.ToPointer());
}

nuklear::NkCommandPolygonFilled::NkCommandPolygonFilled(struct ::nk_command_polygon_filled* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandPolygonFilled^ nuklear::NkCommandPolygonFilled::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandPolygonFilled((struct ::nk_command_polygon_filled*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandPolygonFilled::~NkCommandPolygonFilled()
{
    delete NativePtr;
}

nuklear::NkCommandPolygonFilled::!NkCommandPolygonFilled()
{
    delete NativePtr;
}

nuklear::NkCommandPolygonFilled::NkCommandPolygonFilled()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_polygon_filled();
}

nuklear::NkCommandPolygonFilled::NkCommandPolygonFilled(::nuklear::NkCommandPolygonFilled^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_polygon_filled*)_0->NativePtr;
    NativePtr = new struct ::nk_command_polygon_filled(__arg0);
}

::System::IntPtr nuklear::NkCommandPolygonFilled::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandPolygonFilled::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_polygon_filled*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandPolygonFilled::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandPolygonFilled::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_polygon_filled*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandPolygonFilled::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandPolygonFilled::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_polygon_filled*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

unsigned short nuklear::NkCommandPolygonFilled::PointCount::get()
{
    return NativePtr->point_count;
}

void nuklear::NkCommandPolygonFilled::PointCount::set(unsigned short value)
{
    ((struct ::nk_command_polygon_filled*)NativePtr)->point_count = value;
}

cli::array<::nuklear::NkVec2i^>^ nuklear::NkCommandPolygonFilled::Points::get()
{
    cli::array<::nuklear::NkVec2i^>^ __array0 = nullptr;
    if (NativePtr->points != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkVec2i^>(1);
        for (int i = 0; i < 1; i++)
            __array0[i] = gcnew ::nuklear::NkVec2i(&NativePtr->points[i]);
    }
    return __array0;
}

void nuklear::NkCommandPolygonFilled::Points::set(cli::array<::nuklear::NkVec2i^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 1)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 1; i++)
            ((struct ::nk_command_polygon_filled*)NativePtr)->points[i] = *value[i]->NativePtr;
    }
}

nuklear::NkCommandPolyline::NkCommandPolyline(struct ::nk_command_polyline* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandPolyline^ nuklear::NkCommandPolyline::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandPolyline((struct ::nk_command_polyline*) native.ToPointer());
}

nuklear::NkCommandPolyline::NkCommandPolyline(struct ::nk_command_polyline* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandPolyline^ nuklear::NkCommandPolyline::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandPolyline((struct ::nk_command_polyline*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandPolyline::~NkCommandPolyline()
{
    delete NativePtr;
}

nuklear::NkCommandPolyline::!NkCommandPolyline()
{
    delete NativePtr;
}

nuklear::NkCommandPolyline::NkCommandPolyline()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_polyline();
}

nuklear::NkCommandPolyline::NkCommandPolyline(::nuklear::NkCommandPolyline^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_polyline*)_0->NativePtr;
    NativePtr = new struct ::nk_command_polyline(__arg0);
}

::System::IntPtr nuklear::NkCommandPolyline::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandPolyline::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_polyline*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandPolyline::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandPolyline::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_polyline*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandPolyline::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkCommandPolyline::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_polyline*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

unsigned short nuklear::NkCommandPolyline::LineThickness::get()
{
    return NativePtr->line_thickness;
}

void nuklear::NkCommandPolyline::LineThickness::set(unsigned short value)
{
    ((struct ::nk_command_polyline*)NativePtr)->line_thickness = value;
}

unsigned short nuklear::NkCommandPolyline::PointCount::get()
{
    return NativePtr->point_count;
}

void nuklear::NkCommandPolyline::PointCount::set(unsigned short value)
{
    ((struct ::nk_command_polyline*)NativePtr)->point_count = value;
}

cli::array<::nuklear::NkVec2i^>^ nuklear::NkCommandPolyline::Points::get()
{
    cli::array<::nuklear::NkVec2i^>^ __array0 = nullptr;
    if (NativePtr->points != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkVec2i^>(1);
        for (int i = 0; i < 1; i++)
            __array0[i] = gcnew ::nuklear::NkVec2i(&NativePtr->points[i]);
    }
    return __array0;
}

void nuklear::NkCommandPolyline::Points::set(cli::array<::nuklear::NkVec2i^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 1)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 1; i++)
            ((struct ::nk_command_polyline*)NativePtr)->points[i] = *value[i]->NativePtr;
    }
}

nuklear::NkCommandImage::NkCommandImage(struct ::nk_command_image* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandImage^ nuklear::NkCommandImage::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandImage((struct ::nk_command_image*) native.ToPointer());
}

nuklear::NkCommandImage::NkCommandImage(struct ::nk_command_image* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandImage^ nuklear::NkCommandImage::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandImage((struct ::nk_command_image*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandImage::~NkCommandImage()
{
    delete NativePtr;
}

nuklear::NkCommandImage::!NkCommandImage()
{
    delete NativePtr;
}

nuklear::NkCommandImage::NkCommandImage()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_image();
}

nuklear::NkCommandImage::NkCommandImage(::nuklear::NkCommandImage^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_image*)_0->NativePtr;
    NativePtr = new struct ::nk_command_image(__arg0);
}

::System::IntPtr nuklear::NkCommandImage::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandImage::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_image*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandImage::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandImage::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_image*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandImage::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandImage::X::set(short value)
{
    ((struct ::nk_command_image*)NativePtr)->x = value;
}

short nuklear::NkCommandImage::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandImage::Y::set(short value)
{
    ((struct ::nk_command_image*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandImage::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandImage::W::set(unsigned short value)
{
    ((struct ::nk_command_image*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandImage::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandImage::H::set(unsigned short value)
{
    ((struct ::nk_command_image*)NativePtr)->h = value;
}

::nuklear::NkImage^ nuklear::NkCommandImage::Img::get()
{
    return (&NativePtr->img == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)&NativePtr->img);
}

void nuklear::NkCommandImage::Img::set(::nuklear::NkImage^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_image*)NativePtr)->img = *(struct ::nk_image*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandImage::Col::get()
{
    return (&NativePtr->col == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->col);
}

void nuklear::NkCommandImage::Col::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_image*)NativePtr)->col = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkCommandCustom::NkCommandCustom(struct ::nk_command_custom* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandCustom^ nuklear::NkCommandCustom::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandCustom((struct ::nk_command_custom*) native.ToPointer());
}

nuklear::NkCommandCustom::NkCommandCustom(struct ::nk_command_custom* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandCustom^ nuklear::NkCommandCustom::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandCustom((struct ::nk_command_custom*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandCustom::~NkCommandCustom()
{
    delete NativePtr;
}

nuklear::NkCommandCustom::!NkCommandCustom()
{
    delete NativePtr;
}

nuklear::NkCommandCustom::NkCommandCustom()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_custom();
}

nuklear::NkCommandCustom::NkCommandCustom(::nuklear::NkCommandCustom^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_custom*)_0->NativePtr;
    NativePtr = new struct ::nk_command_custom(__arg0);
}

::System::IntPtr nuklear::NkCommandCustom::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandCustom::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_custom*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandCustom::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandCustom::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_custom*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

short nuklear::NkCommandCustom::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandCustom::X::set(short value)
{
    ((struct ::nk_command_custom*)NativePtr)->x = value;
}

short nuklear::NkCommandCustom::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandCustom::Y::set(short value)
{
    ((struct ::nk_command_custom*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandCustom::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandCustom::W::set(unsigned short value)
{
    ((struct ::nk_command_custom*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandCustom::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandCustom::H::set(unsigned short value)
{
    ((struct ::nk_command_custom*)NativePtr)->h = value;
}

::nuklear::NkHandle nuklear::NkCommandCustom::CallbackData::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->callback_data);
}

void nuklear::NkCommandCustom::CallbackData::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_command_custom*)NativePtr)->callback_data = _marshal0;
}

::nuklear::NkCommandCustomCallback^ nuklear::NkCommandCustom::Callback::get()
{
    return NativePtr->callback == nullptr ? nullptr : safe_cast<::nuklear::NkCommandCustomCallback^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->callback), ::nuklear::NkCommandCustomCallback::typeid));
}

void nuklear::NkCommandCustom::Callback::set(::nuklear::NkCommandCustomCallback^ value)
{
    ((struct ::nk_command_custom*)NativePtr)->callback = static_cast<::nk_command_custom_callback>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkCommandText::NkCommandText(struct ::nk_command_text* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandText^ nuklear::NkCommandText::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandText((struct ::nk_command_text*) native.ToPointer());
}

nuklear::NkCommandText::NkCommandText(struct ::nk_command_text* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandText^ nuklear::NkCommandText::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandText((struct ::nk_command_text*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandText::~NkCommandText()
{
    delete NativePtr;
}

nuklear::NkCommandText::!NkCommandText()
{
    delete NativePtr;
}

nuklear::NkCommandText::NkCommandText()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_text();
}

nuklear::NkCommandText::NkCommandText(::nuklear::NkCommandText^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_text*)_0->NativePtr;
    NativePtr = new struct ::nk_command_text(__arg0);
}

::System::IntPtr nuklear::NkCommandText::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandText::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_text*)object.ToPointer();
}

::nuklear::NkCommand^ nuklear::NkCommandText::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)&NativePtr->header);
}

void nuklear::NkCommandText::Header::set(::nuklear::NkCommand^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_text*)NativePtr)->header = *(struct ::nk_command*)value->NativePtr;
}

::nuklear::NkUserFont^ nuklear::NkCommandText::Font::get()
{
    return (NativePtr->font == nullptr) ? nullptr : gcnew ::nuklear::NkUserFont((struct ::nk_user_font*)NativePtr->font);
}

::nuklear::NkColor^ nuklear::NkCommandText::Background::get()
{
    return (&NativePtr->background == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->background);
}

void nuklear::NkCommandText::Background::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_text*)NativePtr)->background = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkCommandText::Foreground::get()
{
    return (&NativePtr->foreground == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->foreground);
}

void nuklear::NkCommandText::Foreground::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_text*)NativePtr)->foreground = *(struct ::nk_color*)value->NativePtr;
}

short nuklear::NkCommandText::X::get()
{
    return NativePtr->x;
}

void nuklear::NkCommandText::X::set(short value)
{
    ((struct ::nk_command_text*)NativePtr)->x = value;
}

short nuklear::NkCommandText::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkCommandText::Y::set(short value)
{
    ((struct ::nk_command_text*)NativePtr)->y = value;
}

unsigned short nuklear::NkCommandText::W::get()
{
    return NativePtr->w;
}

void nuklear::NkCommandText::W::set(unsigned short value)
{
    ((struct ::nk_command_text*)NativePtr)->w = value;
}

unsigned short nuklear::NkCommandText::H::get()
{
    return NativePtr->h;
}

void nuklear::NkCommandText::H::set(unsigned short value)
{
    ((struct ::nk_command_text*)NativePtr)->h = value;
}

float nuklear::NkCommandText::Height::get()
{
    return NativePtr->height;
}

void nuklear::NkCommandText::Height::set(float value)
{
    ((struct ::nk_command_text*)NativePtr)->height = value;
}

int nuklear::NkCommandText::Length::get()
{
    return NativePtr->length;
}

void nuklear::NkCommandText::Length::set(int value)
{
    ((struct ::nk_command_text*)NativePtr)->length = value;
}

cli::array<char>^ nuklear::NkCommandText::String::get()
{
    cli::array<char>^ __array0 = nullptr;
    if (NativePtr->string != 0)
    {
        __array0 = gcnew cli::array<char>(1);
        for (int i = 0; i < 1; i++)
            __array0[i] = NativePtr->string[i];
    }
    return __array0;
}

void nuklear::NkCommandText::String::set(cli::array<char>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 1)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 1; i++)
            ((struct ::nk_command_text*)NativePtr)->string[i] = value[i];
    }
}

nuklear::NkCommandBuffer::NkCommandBuffer(struct ::nk_command_buffer* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkCommandBuffer^ nuklear::NkCommandBuffer::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkCommandBuffer((struct ::nk_command_buffer*) native.ToPointer());
}

nuklear::NkCommandBuffer::NkCommandBuffer(struct ::nk_command_buffer* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkCommandBuffer^ nuklear::NkCommandBuffer::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkCommandBuffer((struct ::nk_command_buffer*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkCommandBuffer::~NkCommandBuffer()
{
    delete NativePtr;
}

nuklear::NkCommandBuffer::!NkCommandBuffer()
{
    delete NativePtr;
}

nuklear::NkCommandBuffer::NkCommandBuffer()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_command_buffer();
}

nuklear::NkCommandBuffer::NkCommandBuffer(::nuklear::NkCommandBuffer^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_command_buffer*)_0->NativePtr;
    NativePtr = new struct ::nk_command_buffer(__arg0);
}

::System::IntPtr nuklear::NkCommandBuffer::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkCommandBuffer::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_command_buffer*)object.ToPointer();
}

::nuklear::NkBuffer^ nuklear::NkCommandBuffer::Base::get()
{
    return (NativePtr->base == nullptr) ? nullptr : gcnew ::nuklear::NkBuffer((struct ::nk_buffer*)NativePtr->base);
}

void nuklear::NkCommandBuffer::Base::set(::nuklear::NkBuffer^ value)
{
    ((struct ::nk_command_buffer*)NativePtr)->base = (struct ::nk_buffer*)value->NativePtr;
}

::nuklear::NkRect^ nuklear::NkCommandBuffer::Clip::get()
{
    return (&NativePtr->clip == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)&NativePtr->clip);
}

void nuklear::NkCommandBuffer::Clip::set(::nuklear::NkRect^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_command_buffer*)NativePtr)->clip = *(struct ::nk_rect*)value->NativePtr;
}

int nuklear::NkCommandBuffer::UseClipping::get()
{
    return NativePtr->use_clipping;
}

void nuklear::NkCommandBuffer::UseClipping::set(int value)
{
    ((struct ::nk_command_buffer*)NativePtr)->use_clipping = value;
}

::nuklear::NkHandle nuklear::NkCommandBuffer::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkCommandBuffer::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_command_buffer*)NativePtr)->userdata = _marshal0;
}

unsigned long long nuklear::NkCommandBuffer::Begin::get()
{
    return NativePtr->begin;
}

void nuklear::NkCommandBuffer::Begin::set(unsigned long long value)
{
    ((struct ::nk_command_buffer*)NativePtr)->begin = (::nk_size)value;
}

unsigned long long nuklear::NkCommandBuffer::End::get()
{
    return NativePtr->end;
}

void nuklear::NkCommandBuffer::End::set(unsigned long long value)
{
    ((struct ::nk_command_buffer*)NativePtr)->end = (::nk_size)value;
}

unsigned long long nuklear::NkCommandBuffer::Last::get()
{
    return NativePtr->last;
}

void nuklear::NkCommandBuffer::Last::set(unsigned long long value)
{
    ((struct ::nk_command_buffer*)NativePtr)->last = (::nk_size)value;
}

nuklear::NkMouseButton::NkMouseButton(struct ::nk_mouse_button* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkMouseButton^ nuklear::NkMouseButton::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkMouseButton((struct ::nk_mouse_button*) native.ToPointer());
}

nuklear::NkMouseButton::NkMouseButton(struct ::nk_mouse_button* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkMouseButton^ nuklear::NkMouseButton::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkMouseButton((struct ::nk_mouse_button*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkMouseButton::~NkMouseButton()
{
    delete NativePtr;
}

nuklear::NkMouseButton::!NkMouseButton()
{
    delete NativePtr;
}

nuklear::NkMouseButton::NkMouseButton()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_mouse_button();
}

nuklear::NkMouseButton::NkMouseButton(::nuklear::NkMouseButton^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_mouse_button*)_0->NativePtr;
    NativePtr = new struct ::nk_mouse_button(__arg0);
}

::System::IntPtr nuklear::NkMouseButton::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkMouseButton::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_mouse_button*)object.ToPointer();
}

int nuklear::NkMouseButton::Down::get()
{
    return NativePtr->down;
}

void nuklear::NkMouseButton::Down::set(int value)
{
    ((struct ::nk_mouse_button*)NativePtr)->down = value;
}

unsigned int nuklear::NkMouseButton::Clicked::get()
{
    return NativePtr->clicked;
}

void nuklear::NkMouseButton::Clicked::set(unsigned int value)
{
    ((struct ::nk_mouse_button*)NativePtr)->clicked = value;
}

::nuklear::NkVec2^ nuklear::NkMouseButton::ClickedPos::get()
{
    return (&NativePtr->clicked_pos == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->clicked_pos);
}

void nuklear::NkMouseButton::ClickedPos::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_mouse_button*)NativePtr)->clicked_pos = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkMouse::NkMouse(struct ::nk_mouse* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkMouse^ nuklear::NkMouse::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkMouse((struct ::nk_mouse*) native.ToPointer());
}

nuklear::NkMouse::NkMouse(struct ::nk_mouse* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkMouse^ nuklear::NkMouse::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkMouse((struct ::nk_mouse*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkMouse::~NkMouse()
{
    delete NativePtr;
}

nuklear::NkMouse::!NkMouse()
{
    delete NativePtr;
}

nuklear::NkMouse::NkMouse()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_mouse();
}

nuklear::NkMouse::NkMouse(::nuklear::NkMouse^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_mouse*)_0->NativePtr;
    NativePtr = new struct ::nk_mouse(__arg0);
}

::System::IntPtr nuklear::NkMouse::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkMouse::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_mouse*)object.ToPointer();
}

cli::array<::nuklear::NkMouseButton^>^ nuklear::NkMouse::Buttons::get()
{
    cli::array<::nuklear::NkMouseButton^>^ __array0 = nullptr;
    if (NativePtr->buttons != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkMouseButton^>(4);
        for (int i = 0; i < 4; i++)
            __array0[i] = gcnew ::nuklear::NkMouseButton(&NativePtr->buttons[i]);
    }
    return __array0;
}

void nuklear::NkMouse::Buttons::set(cli::array<::nuklear::NkMouseButton^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 4)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 4; i++)
            ((struct ::nk_mouse*)NativePtr)->buttons[i] = *value[i]->NativePtr;
    }
}

::nuklear::NkVec2^ nuklear::NkMouse::Pos::get()
{
    return (&NativePtr->pos == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->pos);
}

void nuklear::NkMouse::Pos::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_mouse*)NativePtr)->pos = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkMouse::Prev::get()
{
    return (&NativePtr->prev == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->prev);
}

void nuklear::NkMouse::Prev::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_mouse*)NativePtr)->prev = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkMouse::Delta::get()
{
    return (&NativePtr->delta == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->delta);
}

void nuklear::NkMouse::Delta::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_mouse*)NativePtr)->delta = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkMouse::ScrollDelta::get()
{
    return (&NativePtr->scroll_delta == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->scroll_delta);
}

void nuklear::NkMouse::ScrollDelta::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_mouse*)NativePtr)->scroll_delta = *(struct ::nk_vec2*)value->NativePtr;
}

unsigned char nuklear::NkMouse::Grab::get()
{
    return NativePtr->grab;
}

void nuklear::NkMouse::Grab::set(unsigned char value)
{
    ((struct ::nk_mouse*)NativePtr)->grab = value;
}

unsigned char nuklear::NkMouse::Grabbed::get()
{
    return NativePtr->grabbed;
}

void nuklear::NkMouse::Grabbed::set(unsigned char value)
{
    ((struct ::nk_mouse*)NativePtr)->grabbed = value;
}

unsigned char nuklear::NkMouse::Ungrab::get()
{
    return NativePtr->ungrab;
}

void nuklear::NkMouse::Ungrab::set(unsigned char value)
{
    ((struct ::nk_mouse*)NativePtr)->ungrab = value;
}

nuklear::NkKey::NkKey(struct ::nk_key* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkKey^ nuklear::NkKey::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkKey((struct ::nk_key*) native.ToPointer());
}

nuklear::NkKey::NkKey(struct ::nk_key* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkKey^ nuklear::NkKey::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkKey((struct ::nk_key*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkKey::~NkKey()
{
    delete NativePtr;
}

nuklear::NkKey::!NkKey()
{
    delete NativePtr;
}

nuklear::NkKey::NkKey()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_key();
}

nuklear::NkKey::NkKey(::nuklear::NkKey^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_key*)_0->NativePtr;
    NativePtr = new struct ::nk_key(__arg0);
}

::System::IntPtr nuklear::NkKey::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkKey::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_key*)object.ToPointer();
}

int nuklear::NkKey::Down::get()
{
    return NativePtr->down;
}

void nuklear::NkKey::Down::set(int value)
{
    ((struct ::nk_key*)NativePtr)->down = value;
}

unsigned int nuklear::NkKey::Clicked::get()
{
    return NativePtr->clicked;
}

void nuklear::NkKey::Clicked::set(unsigned int value)
{
    ((struct ::nk_key*)NativePtr)->clicked = value;
}

nuklear::NkKeyboard::NkKeyboard(struct ::nk_keyboard* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkKeyboard^ nuklear::NkKeyboard::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkKeyboard((struct ::nk_keyboard*) native.ToPointer());
}

nuklear::NkKeyboard::NkKeyboard(struct ::nk_keyboard* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkKeyboard^ nuklear::NkKeyboard::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkKeyboard((struct ::nk_keyboard*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkKeyboard::~NkKeyboard()
{
    delete NativePtr;
}

nuklear::NkKeyboard::!NkKeyboard()
{
    delete NativePtr;
}

nuklear::NkKeyboard::NkKeyboard()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_keyboard();
}

nuklear::NkKeyboard::NkKeyboard(::nuklear::NkKeyboard^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_keyboard*)_0->NativePtr;
    NativePtr = new struct ::nk_keyboard(__arg0);
}

::System::IntPtr nuklear::NkKeyboard::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkKeyboard::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_keyboard*)object.ToPointer();
}

cli::array<::nuklear::NkKey^>^ nuklear::NkKeyboard::Keys::get()
{
    cli::array<::nuklear::NkKey^>^ __array0 = nullptr;
    if (NativePtr->keys != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkKey^>(30);
        for (int i = 0; i < 30; i++)
            __array0[i] = gcnew ::nuklear::NkKey(&NativePtr->keys[i]);
    }
    return __array0;
}

void nuklear::NkKeyboard::Keys::set(cli::array<::nuklear::NkKey^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 30)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 30; i++)
            ((struct ::nk_keyboard*)NativePtr)->keys[i] = *value[i]->NativePtr;
    }
}

cli::array<char>^ nuklear::NkKeyboard::Text::get()
{
    cli::array<char>^ __array0 = nullptr;
    if (NativePtr->text != 0)
    {
        __array0 = gcnew cli::array<char>(16);
        for (int i = 0; i < 16; i++)
            __array0[i] = NativePtr->text[i];
    }
    return __array0;
}

void nuklear::NkKeyboard::Text::set(cli::array<char>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 16)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 16; i++)
            ((struct ::nk_keyboard*)NativePtr)->text[i] = value[i];
    }
}

int nuklear::NkKeyboard::TextLen::get()
{
    return NativePtr->text_len;
}

void nuklear::NkKeyboard::TextLen::set(int value)
{
    ((struct ::nk_keyboard*)NativePtr)->text_len = value;
}

nuklear::NkInput::NkInput(struct ::nk_input* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkInput^ nuklear::NkInput::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkInput((struct ::nk_input*) native.ToPointer());
}

nuklear::NkInput::NkInput(struct ::nk_input* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkInput^ nuklear::NkInput::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkInput((struct ::nk_input*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkInput::~NkInput()
{
    delete NativePtr;
}

nuklear::NkInput::!NkInput()
{
    delete NativePtr;
}

nuklear::NkInput::NkInput()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_input();
}

nuklear::NkInput::NkInput(::nuklear::NkInput^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_input*)_0->NativePtr;
    NativePtr = new struct ::nk_input(__arg0);
}

::System::IntPtr nuklear::NkInput::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkInput::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_input*)object.ToPointer();
}

::nuklear::NkKeyboard^ nuklear::NkInput::Keyboard::get()
{
    return (&NativePtr->keyboard == nullptr) ? nullptr : gcnew ::nuklear::NkKeyboard((struct ::nk_keyboard*)&NativePtr->keyboard);
}

void nuklear::NkInput::Keyboard::set(::nuklear::NkKeyboard^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_input*)NativePtr)->keyboard = *(struct ::nk_keyboard*)value->NativePtr;
}

::nuklear::NkMouse^ nuklear::NkInput::Mouse::get()
{
    return (&NativePtr->mouse == nullptr) ? nullptr : gcnew ::nuklear::NkMouse((struct ::nk_mouse*)&NativePtr->mouse);
}

void nuklear::NkInput::Mouse::set(::nuklear::NkMouse^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_input*)NativePtr)->mouse = *(struct ::nk_mouse*)value->NativePtr;
}

nuklear::NkStyleItemData::NkStyleItemData(::nk_style_item_data* native)
{
    __image = (&native->image == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)&native->image);
    __color = (&native->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&native->color);
}

nuklear::NkStyleItemData^ nuklear::NkStyleItemData::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleItemData((::nk_style_item_data*) native.ToPointer());
}

nuklear::NkStyleItemData::NkStyleItemData(::nk_style_item_data* native, bool ownNativeInstance)
{
    __image = (&native->image == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)&native->image);
    __color = (&native->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&native->color);
}

nuklear::NkStyleItemData^ nuklear::NkStyleItemData::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleItemData((::nk_style_item_data*) native.ToPointer(), __ownsNativeInstance);
}

::nuklear::NkImage^ nuklear::NkStyleItemData::Image::get()
{
    return __image;
}

void nuklear::NkStyleItemData::Image::set(::nuklear::NkImage^ value)
{
    __image = value;
}

::nuklear::NkColor^ nuklear::NkStyleItemData::Color::get()
{
    return __color;
}

void nuklear::NkStyleItemData::Color::set(::nuklear::NkColor^ value)
{
    __color = value;
}

nuklear::NkStyleItem::NkStyleItem(struct ::nk_style_item* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleItem^ nuklear::NkStyleItem::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*) native.ToPointer());
}

nuklear::NkStyleItem::NkStyleItem(struct ::nk_style_item* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleItem^ nuklear::NkStyleItem::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleItem::~NkStyleItem()
{
    delete NativePtr;
}

nuklear::NkStyleItem::!NkStyleItem()
{
    delete NativePtr;
}

nuklear::NkStyleItem::NkStyleItem()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_item();
}

nuklear::NkStyleItem::NkStyleItem(::nuklear::NkStyleItem^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_item*)_0->NativePtr;
    NativePtr = new struct ::nk_style_item(__arg0);
}

::System::IntPtr nuklear::NkStyleItem::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleItem::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_item*)object.ToPointer();
}

::nuklear::NkStyleItemType nuklear::NkStyleItem::Type::get()
{
    return (::nuklear::NkStyleItemType)NativePtr->type;
}

void nuklear::NkStyleItem::Type::set(::nuklear::NkStyleItemType value)
{
    ((struct ::nk_style_item*)NativePtr)->type = (enum ::nk_style_item_type)value;
}

::nuklear::NkStyleItemData nuklear::NkStyleItem::Data::get()
{
    return ::nuklear::NkStyleItemData((::nk_style_item_data*)&NativePtr->data);
}

void nuklear::NkStyleItem::Data::set(::nuklear::NkStyleItemData value)
{
    auto _marshal0 = ::nk_style_item_data();
    if (ReferenceEquals(value.Image, nullptr))
        throw gcnew ::System::ArgumentNullException("value.Image", "Cannot be null because it is passed by value.");
    _marshal0.image = *(struct ::nk_image*)value.Image->NativePtr;
    if (ReferenceEquals(value.Color, nullptr))
        throw gcnew ::System::ArgumentNullException("value.Color", "Cannot be null because it is passed by value.");
    _marshal0.color = *(struct ::nk_color*)value.Color->NativePtr;
    ((struct ::nk_style_item*)NativePtr)->data = _marshal0;
}

nuklear::NkStyleText::NkStyleText(struct ::nk_style_text* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleText^ nuklear::NkStyleText::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleText((struct ::nk_style_text*) native.ToPointer());
}

nuklear::NkStyleText::NkStyleText(struct ::nk_style_text* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleText^ nuklear::NkStyleText::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleText((struct ::nk_style_text*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleText::~NkStyleText()
{
    delete NativePtr;
}

nuklear::NkStyleText::!NkStyleText()
{
    delete NativePtr;
}

nuklear::NkStyleText::NkStyleText()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_text();
}

nuklear::NkStyleText::NkStyleText(::nuklear::NkStyleText^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_text*)_0->NativePtr;
    NativePtr = new struct ::nk_style_text(__arg0);
}

::System::IntPtr nuklear::NkStyleText::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleText::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_text*)object.ToPointer();
}

::nuklear::NkColor^ nuklear::NkStyleText::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkStyleText::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_text*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleText::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleText::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_text*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkStyleButton::NkStyleButton(struct ::nk_style_button* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

::nuklear::NkStyleButton^ ::nuklear::NkStyleButton::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*) native.ToPointer());
}

::nuklear::NkStyleButton::NkStyleButton(struct ::nk_style_button* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

::nuklear::NkStyleButton^ ::nuklear::NkStyleButton::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*) native.ToPointer(), __ownsNativeInstance);
}

::nuklear::NkStyleButton::~NkStyleButton()
{
    delete NativePtr;
}

::nuklear::NkStyleButton::!NkStyleButton()
{
    delete NativePtr;
}

::nuklear::NkStyleButton::NkStyleButton()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_button();
}

::nuklear::NkStyleButton::NkStyleButton(::nuklear::NkStyleButton^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_button*)_0->NativePtr;
    NativePtr = new struct ::nk_style_button(__arg0);
}

::System::IntPtr nuklear::NkStyleButton::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void ::nuklear::NkStyleButton::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_button*)object.ToPointer();
}

::nuklear::NkStyleItem^ ::nuklear::NkStyleButton::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void ::nuklear::NkStyleButton::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ ::nuklear::NkStyleButton::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void ::nuklear::NkStyleButton::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ ::nuklear::NkStyleButton::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void ::nuklear::NkStyleButton::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ ::nuklear::NkStyleButton::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void ::nuklear::NkStyleButton::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ ::nuklear::NkStyleButton::TextBackground::get()
{
    return (&NativePtr->text_background == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_background);
}

void ::nuklear::NkStyleButton::TextBackground::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->text_background = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ ::nuklear::NkStyleButton::TextNormal::get()
{
    return (&NativePtr->text_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_normal);
}

void ::nuklear::NkStyleButton::TextNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->text_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ ::nuklear::NkStyleButton::TextHover::get()
{
    return (&NativePtr->text_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_hover);
}

void ::nuklear::NkStyleButton::TextHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->text_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ ::nuklear::NkStyleButton::TextActive::get()
{
    return (&NativePtr->text_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_active);
}

void ::nuklear::NkStyleButton::TextActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->text_active = *(struct ::nk_color*)value->NativePtr;
}

unsigned int ::nuklear::NkStyleButton::TextAlignment::get()
{
    return NativePtr->text_alignment;
}

void ::nuklear::NkStyleButton::TextAlignment::set(unsigned int value)
{
    ((struct ::nk_style_button*)NativePtr)->text_alignment = (::nk_flags)(::nk_uint)value;
}

float ::nuklear::NkStyleButton::Border::get()
{
    return NativePtr->border;
}

void ::nuklear::NkStyleButton::Border::set(float value)
{
    ((struct ::nk_style_button*)NativePtr)->border = value;
}

float ::nuklear::NkStyleButton::Rounding::get()
{
    return NativePtr->rounding;
}

void ::nuklear::NkStyleButton::Rounding::set(float value)
{
    ((struct ::nk_style_button*)NativePtr)->rounding = value;
}

::nuklear::NkVec2^ ::nuklear::NkStyleButton::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void ::nuklear::NkStyleButton::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ ::nuklear::NkStyleButton::ImagePadding::get()
{
    return (&NativePtr->image_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->image_padding);
}

void ::nuklear::NkStyleButton::ImagePadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->image_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ ::nuklear::NkStyleButton::TouchPadding::get()
{
    return (&NativePtr->touch_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->touch_padding);
}

void ::nuklear::NkStyleButton::TouchPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_button*)NativePtr)->touch_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkHandle nuklear::NkStyleButton::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void ::nuklear::NkStyleButton::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_button*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ ::nuklear::NkStyleButton::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void ::nuklear::NkStyleButton::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_button*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ ::nuklear::NkStyleButton::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void ::nuklear::NkStyleButton::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_button*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleToggle::NkStyleToggle(struct ::nk_style_toggle* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleToggle^ nuklear::NkStyleToggle::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleToggle((struct ::nk_style_toggle*) native.ToPointer());
}

nuklear::NkStyleToggle::NkStyleToggle(struct ::nk_style_toggle* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleToggle^ nuklear::NkStyleToggle::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleToggle((struct ::nk_style_toggle*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleToggle::~NkStyleToggle()
{
    delete NativePtr;
}

nuklear::NkStyleToggle::!NkStyleToggle()
{
    delete NativePtr;
}

nuklear::NkStyleToggle::NkStyleToggle()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_toggle();
}

nuklear::NkStyleToggle::NkStyleToggle(::nuklear::NkStyleToggle^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_toggle*)_0->NativePtr;
    NativePtr = new struct ::nk_style_toggle(__arg0);
}

::System::IntPtr nuklear::NkStyleToggle::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleToggle::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_toggle*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleToggle::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleToggle::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleToggle::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleToggle::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleToggle::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleToggle::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleToggle::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleToggle::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleToggle::CursorNormal::get()
{
    return (&NativePtr->cursor_normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_normal);
}

void nuklear::NkStyleToggle::CursorNormal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->cursor_normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleToggle::CursorHover::get()
{
    return (&NativePtr->cursor_hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_hover);
}

void nuklear::NkStyleToggle::CursorHover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->cursor_hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleToggle::TextNormal::get()
{
    return (&NativePtr->text_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_normal);
}

void nuklear::NkStyleToggle::TextNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->text_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleToggle::TextHover::get()
{
    return (&NativePtr->text_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_hover);
}

void nuklear::NkStyleToggle::TextHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->text_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleToggle::TextActive::get()
{
    return (&NativePtr->text_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_active);
}

void nuklear::NkStyleToggle::TextActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->text_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleToggle::TextBackground::get()
{
    return (&NativePtr->text_background == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_background);
}

void nuklear::NkStyleToggle::TextBackground::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->text_background = *(struct ::nk_color*)value->NativePtr;
}

unsigned int nuklear::NkStyleToggle::TextAlignment::get()
{
    return NativePtr->text_alignment;
}

void nuklear::NkStyleToggle::TextAlignment::set(unsigned int value)
{
    ((struct ::nk_style_toggle*)NativePtr)->text_alignment = (::nk_flags)(::nk_uint)value;
}

::nuklear::NkVec2^ nuklear::NkStyleToggle::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleToggle::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleToggle::TouchPadding::get()
{
    return (&NativePtr->touch_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->touch_padding);
}

void nuklear::NkStyleToggle::TouchPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_toggle*)NativePtr)->touch_padding = *(struct ::nk_vec2*)value->NativePtr;
}

float nuklear::NkStyleToggle::Spacing::get()
{
    return NativePtr->spacing;
}

void nuklear::NkStyleToggle::Spacing::set(float value)
{
    ((struct ::nk_style_toggle*)NativePtr)->spacing = value;
}

float nuklear::NkStyleToggle::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleToggle::Border::set(float value)
{
    ((struct ::nk_style_toggle*)NativePtr)->border = value;
}

::nuklear::NkHandle nuklear::NkStyleToggle::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkStyleToggle::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_toggle*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleToggle::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleToggle::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_toggle*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleToggle::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleToggle::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_toggle*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleSelectable::NkStyleSelectable(struct ::nk_style_selectable* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleSelectable^ nuklear::NkStyleSelectable::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleSelectable((struct ::nk_style_selectable*) native.ToPointer());
}

nuklear::NkStyleSelectable::NkStyleSelectable(struct ::nk_style_selectable* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleSelectable^ nuklear::NkStyleSelectable::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleSelectable((struct ::nk_style_selectable*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleSelectable::~NkStyleSelectable()
{
    delete NativePtr;
}

nuklear::NkStyleSelectable::!NkStyleSelectable()
{
    delete NativePtr;
}

nuklear::NkStyleSelectable::NkStyleSelectable()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_selectable();
}

nuklear::NkStyleSelectable::NkStyleSelectable(::nuklear::NkStyleSelectable^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_selectable*)_0->NativePtr;
    NativePtr = new struct ::nk_style_selectable(__arg0);
}

::System::IntPtr nuklear::NkStyleSelectable::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleSelectable::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_selectable*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleSelectable::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleSelectable::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSelectable::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleSelectable::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSelectable::Pressed::get()
{
    return (&NativePtr->pressed == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->pressed);
}

void nuklear::NkStyleSelectable::Pressed::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->pressed = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSelectable::NormalActive::get()
{
    return (&NativePtr->normal_active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal_active);
}

void nuklear::NkStyleSelectable::NormalActive::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->normal_active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSelectable::HoverActive::get()
{
    return (&NativePtr->hover_active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover_active);
}

void nuklear::NkStyleSelectable::HoverActive::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->hover_active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSelectable::PressedActive::get()
{
    return (&NativePtr->pressed_active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->pressed_active);
}

void nuklear::NkStyleSelectable::PressedActive::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->pressed_active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextNormal::get()
{
    return (&NativePtr->text_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_normal);
}

void nuklear::NkStyleSelectable::TextNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextHover::get()
{
    return (&NativePtr->text_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_hover);
}

void nuklear::NkStyleSelectable::TextHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextPressed::get()
{
    return (&NativePtr->text_pressed == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_pressed);
}

void nuklear::NkStyleSelectable::TextPressed::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_pressed = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextNormalActive::get()
{
    return (&NativePtr->text_normal_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_normal_active);
}

void nuklear::NkStyleSelectable::TextNormalActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_normal_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextHoverActive::get()
{
    return (&NativePtr->text_hover_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_hover_active);
}

void nuklear::NkStyleSelectable::TextHoverActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_hover_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextPressedActive::get()
{
    return (&NativePtr->text_pressed_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_pressed_active);
}

void nuklear::NkStyleSelectable::TextPressedActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_pressed_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSelectable::TextBackground::get()
{
    return (&NativePtr->text_background == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_background);
}

void nuklear::NkStyleSelectable::TextBackground::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->text_background = *(struct ::nk_color*)value->NativePtr;
}

unsigned int nuklear::NkStyleSelectable::TextAlignment::get()
{
    return NativePtr->text_alignment;
}

void nuklear::NkStyleSelectable::TextAlignment::set(unsigned int value)
{
    ((struct ::nk_style_selectable*)NativePtr)->text_alignment = (::nk_flags)(::nk_uint)value;
}

float nuklear::NkStyleSelectable::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleSelectable::Rounding::set(float value)
{
    ((struct ::nk_style_selectable*)NativePtr)->rounding = value;
}

::nuklear::NkVec2^ nuklear::NkStyleSelectable::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleSelectable::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleSelectable::TouchPadding::get()
{
    return (&NativePtr->touch_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->touch_padding);
}

void nuklear::NkStyleSelectable::TouchPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->touch_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleSelectable::ImagePadding::get()
{
    return (&NativePtr->image_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->image_padding);
}

void nuklear::NkStyleSelectable::ImagePadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_selectable*)NativePtr)->image_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkHandle nuklear::NkStyleSelectable::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkStyleSelectable::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_selectable*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleSelectable::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleSelectable::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_selectable*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleSelectable::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleSelectable::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_selectable*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleSlider::NkStyleSlider(struct ::nk_style_slider* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleSlider^ nuklear::NkStyleSlider::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleSlider((struct ::nk_style_slider*) native.ToPointer());
}

nuklear::NkStyleSlider::NkStyleSlider(struct ::nk_style_slider* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleSlider^ nuklear::NkStyleSlider::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleSlider((struct ::nk_style_slider*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleSlider::~NkStyleSlider()
{
    delete NativePtr;
}

nuklear::NkStyleSlider::!NkStyleSlider()
{
    delete NativePtr;
}

nuklear::NkStyleSlider::NkStyleSlider()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_slider();
}

nuklear::NkStyleSlider::NkStyleSlider(::nuklear::NkStyleSlider^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_slider*)_0->NativePtr;
    NativePtr = new struct ::nk_style_slider(__arg0);
}

::System::IntPtr nuklear::NkStyleSlider::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleSlider::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_slider*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleSlider::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleSlider::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSlider::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleSlider::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSlider::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleSlider::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSlider::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleSlider::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSlider::BarNormal::get()
{
    return (&NativePtr->bar_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->bar_normal);
}

void nuklear::NkStyleSlider::BarNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->bar_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSlider::BarHover::get()
{
    return (&NativePtr->bar_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->bar_hover);
}

void nuklear::NkStyleSlider::BarHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->bar_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSlider::BarActive::get()
{
    return (&NativePtr->bar_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->bar_active);
}

void nuklear::NkStyleSlider::BarActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->bar_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleSlider::BarFilled::get()
{
    return (&NativePtr->bar_filled == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->bar_filled);
}

void nuklear::NkStyleSlider::BarFilled::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->bar_filled = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSlider::CursorNormal::get()
{
    return (&NativePtr->cursor_normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_normal);
}

void nuklear::NkStyleSlider::CursorNormal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->cursor_normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSlider::CursorHover::get()
{
    return (&NativePtr->cursor_hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_hover);
}

void nuklear::NkStyleSlider::CursorHover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->cursor_hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleSlider::CursorActive::get()
{
    return (&NativePtr->cursor_active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_active);
}

void nuklear::NkStyleSlider::CursorActive::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->cursor_active = *(struct ::nk_style_item*)value->NativePtr;
}

float nuklear::NkStyleSlider::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleSlider::Border::set(float value)
{
    ((struct ::nk_style_slider*)NativePtr)->border = value;
}

float nuklear::NkStyleSlider::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleSlider::Rounding::set(float value)
{
    ((struct ::nk_style_slider*)NativePtr)->rounding = value;
}

float nuklear::NkStyleSlider::BarHeight::get()
{
    return NativePtr->bar_height;
}

void nuklear::NkStyleSlider::BarHeight::set(float value)
{
    ((struct ::nk_style_slider*)NativePtr)->bar_height = value;
}

::nuklear::NkVec2^ nuklear::NkStyleSlider::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleSlider::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleSlider::Spacing::get()
{
    return (&NativePtr->spacing == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->spacing);
}

void nuklear::NkStyleSlider::Spacing::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->spacing = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleSlider::CursorSize::get()
{
    return (&NativePtr->cursor_size == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->cursor_size);
}

void nuklear::NkStyleSlider::CursorSize::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->cursor_size = *(struct ::nk_vec2*)value->NativePtr;
}

int nuklear::NkStyleSlider::ShowButtons::get()
{
    return NativePtr->show_buttons;
}

void nuklear::NkStyleSlider::ShowButtons::set(int value)
{
    ((struct ::nk_style_slider*)NativePtr)->show_buttons = value;
}

::nuklear::NkStyleButton^ nuklear::NkStyleSlider::IncButton::get()
{
    return (&NativePtr->inc_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->inc_button);
}

void nuklear::NkStyleSlider::IncButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->inc_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleSlider::DecButton::get()
{
    return (&NativePtr->dec_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->dec_button);
}

void nuklear::NkStyleSlider::DecButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_slider*)NativePtr)->dec_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkSymbolType nuklear::NkStyleSlider::IncSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->inc_symbol;
}

void nuklear::NkStyleSlider::IncSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_slider*)NativePtr)->inc_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleSlider::DecSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->dec_symbol;
}

void nuklear::NkStyleSlider::DecSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_slider*)NativePtr)->dec_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkHandle nuklear::NkStyleSlider::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkStyleSlider::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_slider*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleSlider::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleSlider::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_slider*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleSlider::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleSlider::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_slider*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleProgress::NkStyleProgress(struct ::nk_style_progress* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleProgress^ nuklear::NkStyleProgress::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleProgress((struct ::nk_style_progress*) native.ToPointer());
}

nuklear::NkStyleProgress::NkStyleProgress(struct ::nk_style_progress* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleProgress^ nuklear::NkStyleProgress::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleProgress((struct ::nk_style_progress*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleProgress::~NkStyleProgress()
{
    delete NativePtr;
}

nuklear::NkStyleProgress::!NkStyleProgress()
{
    delete NativePtr;
}

nuklear::NkStyleProgress::NkStyleProgress()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_progress();
}

nuklear::NkStyleProgress::NkStyleProgress(::nuklear::NkStyleProgress^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_progress*)_0->NativePtr;
    NativePtr = new struct ::nk_style_progress(__arg0);
}

::System::IntPtr nuklear::NkStyleProgress::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleProgress::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_progress*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleProgress::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleProgress::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProgress::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleProgress::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProgress::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleProgress::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleProgress::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleProgress::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProgress::CursorNormal::get()
{
    return (&NativePtr->cursor_normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_normal);
}

void nuklear::NkStyleProgress::CursorNormal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->cursor_normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProgress::CursorHover::get()
{
    return (&NativePtr->cursor_hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_hover);
}

void nuklear::NkStyleProgress::CursorHover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->cursor_hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProgress::CursorActive::get()
{
    return (&NativePtr->cursor_active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_active);
}

void nuklear::NkStyleProgress::CursorActive::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->cursor_active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleProgress::CursorBorderColor::get()
{
    return (&NativePtr->cursor_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->cursor_border_color);
}

void nuklear::NkStyleProgress::CursorBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->cursor_border_color = *(struct ::nk_color*)value->NativePtr;
}

float nuklear::NkStyleProgress::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleProgress::Rounding::set(float value)
{
    ((struct ::nk_style_progress*)NativePtr)->rounding = value;
}

float nuklear::NkStyleProgress::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleProgress::Border::set(float value)
{
    ((struct ::nk_style_progress*)NativePtr)->border = value;
}

float nuklear::NkStyleProgress::CursorBorder::get()
{
    return NativePtr->cursor_border;
}

void nuklear::NkStyleProgress::CursorBorder::set(float value)
{
    ((struct ::nk_style_progress*)NativePtr)->cursor_border = value;
}

float nuklear::NkStyleProgress::CursorRounding::get()
{
    return NativePtr->cursor_rounding;
}

void nuklear::NkStyleProgress::CursorRounding::set(float value)
{
    ((struct ::nk_style_progress*)NativePtr)->cursor_rounding = value;
}

::nuklear::NkVec2^ nuklear::NkStyleProgress::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleProgress::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_progress*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkHandle nuklear::NkStyleProgress::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkStyleProgress::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_progress*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleProgress::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleProgress::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_progress*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleProgress::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleProgress::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_progress*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleScrollbar::NkStyleScrollbar(struct ::nk_style_scrollbar* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleScrollbar^ nuklear::NkStyleScrollbar::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleScrollbar((struct ::nk_style_scrollbar*) native.ToPointer());
}

nuklear::NkStyleScrollbar::NkStyleScrollbar(struct ::nk_style_scrollbar* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleScrollbar^ nuklear::NkStyleScrollbar::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleScrollbar((struct ::nk_style_scrollbar*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleScrollbar::~NkStyleScrollbar()
{
    delete NativePtr;
}

nuklear::NkStyleScrollbar::!NkStyleScrollbar()
{
    delete NativePtr;
}

nuklear::NkStyleScrollbar::NkStyleScrollbar()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_scrollbar();
}

nuklear::NkStyleScrollbar::NkStyleScrollbar(::nuklear::NkStyleScrollbar^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_scrollbar*)_0->NativePtr;
    NativePtr = new struct ::nk_style_scrollbar(__arg0);
}

::System::IntPtr nuklear::NkStyleScrollbar::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleScrollbar::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_scrollbar*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleScrollbar::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleScrollbar::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleScrollbar::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleScrollbar::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleScrollbar::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleScrollbar::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleScrollbar::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleScrollbar::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleScrollbar::CursorNormal::get()
{
    return (&NativePtr->cursor_normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_normal);
}

void nuklear::NkStyleScrollbar::CursorNormal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->cursor_normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleScrollbar::CursorHover::get()
{
    return (&NativePtr->cursor_hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_hover);
}

void nuklear::NkStyleScrollbar::CursorHover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->cursor_hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleScrollbar::CursorActive::get()
{
    return (&NativePtr->cursor_active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->cursor_active);
}

void nuklear::NkStyleScrollbar::CursorActive::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->cursor_active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleScrollbar::CursorBorderColor::get()
{
    return (&NativePtr->cursor_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->cursor_border_color);
}

void nuklear::NkStyleScrollbar::CursorBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->cursor_border_color = *(struct ::nk_color*)value->NativePtr;
}

float nuklear::NkStyleScrollbar::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleScrollbar::Border::set(float value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->border = value;
}

float nuklear::NkStyleScrollbar::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleScrollbar::Rounding::set(float value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->rounding = value;
}

float nuklear::NkStyleScrollbar::BorderCursor::get()
{
    return NativePtr->border_cursor;
}

void nuklear::NkStyleScrollbar::BorderCursor::set(float value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->border_cursor = value;
}

float nuklear::NkStyleScrollbar::RoundingCursor::get()
{
    return NativePtr->rounding_cursor;
}

void nuklear::NkStyleScrollbar::RoundingCursor::set(float value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->rounding_cursor = value;
}

::nuklear::NkVec2^ nuklear::NkStyleScrollbar::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleScrollbar::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

int nuklear::NkStyleScrollbar::ShowButtons::get()
{
    return NativePtr->show_buttons;
}

void nuklear::NkStyleScrollbar::ShowButtons::set(int value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->show_buttons = value;
}

::nuklear::NkStyleButton^ nuklear::NkStyleScrollbar::IncButton::get()
{
    return (&NativePtr->inc_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->inc_button);
}

void nuklear::NkStyleScrollbar::IncButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->inc_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleScrollbar::DecButton::get()
{
    return (&NativePtr->dec_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->dec_button);
}

void nuklear::NkStyleScrollbar::DecButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_scrollbar*)NativePtr)->dec_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkSymbolType nuklear::NkStyleScrollbar::IncSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->inc_symbol;
}

void nuklear::NkStyleScrollbar::IncSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->inc_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleScrollbar::DecSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->dec_symbol;
}

void nuklear::NkStyleScrollbar::DecSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->dec_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkHandle nuklear::NkStyleScrollbar::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkStyleScrollbar::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_scrollbar*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleScrollbar::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleScrollbar::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleScrollbar::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleScrollbar::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_scrollbar*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleEdit::NkStyleEdit(struct ::nk_style_edit* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleEdit^ nuklear::NkStyleEdit::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleEdit((struct ::nk_style_edit*) native.ToPointer());
}

nuklear::NkStyleEdit::NkStyleEdit(struct ::nk_style_edit* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleEdit^ nuklear::NkStyleEdit::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleEdit((struct ::nk_style_edit*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleEdit::~NkStyleEdit()
{
    delete NativePtr;
}

nuklear::NkStyleEdit::!NkStyleEdit()
{
    delete NativePtr;
}

nuklear::NkStyleEdit::NkStyleEdit()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_edit();
}

nuklear::NkStyleEdit::NkStyleEdit(::nuklear::NkStyleEdit^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_edit*)_0->NativePtr;
    NativePtr = new struct ::nk_style_edit(__arg0);
}

::System::IntPtr nuklear::NkStyleEdit::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleEdit::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_edit*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleEdit::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleEdit::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleEdit::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleEdit::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleEdit::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleEdit::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleEdit::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleScrollbar^ nuklear::NkStyleEdit::Scrollbar::get()
{
    return (&NativePtr->scrollbar == nullptr) ? nullptr : gcnew ::nuklear::NkStyleScrollbar((struct ::nk_style_scrollbar*)&NativePtr->scrollbar);
}

void nuklear::NkStyleEdit::Scrollbar::set(::nuklear::NkStyleScrollbar^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->scrollbar = *(struct ::nk_style_scrollbar*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::CursorNormal::get()
{
    return (&NativePtr->cursor_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->cursor_normal);
}

void nuklear::NkStyleEdit::CursorNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->cursor_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::CursorHover::get()
{
    return (&NativePtr->cursor_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->cursor_hover);
}

void nuklear::NkStyleEdit::CursorHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->cursor_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::CursorTextNormal::get()
{
    return (&NativePtr->cursor_text_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->cursor_text_normal);
}

void nuklear::NkStyleEdit::CursorTextNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->cursor_text_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::CursorTextHover::get()
{
    return (&NativePtr->cursor_text_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->cursor_text_hover);
}

void nuklear::NkStyleEdit::CursorTextHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->cursor_text_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::TextNormal::get()
{
    return (&NativePtr->text_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_normal);
}

void nuklear::NkStyleEdit::TextNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->text_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::TextHover::get()
{
    return (&NativePtr->text_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_hover);
}

void nuklear::NkStyleEdit::TextHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->text_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::TextActive::get()
{
    return (&NativePtr->text_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text_active);
}

void nuklear::NkStyleEdit::TextActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->text_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::SelectedNormal::get()
{
    return (&NativePtr->selected_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->selected_normal);
}

void nuklear::NkStyleEdit::SelectedNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->selected_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::SelectedHover::get()
{
    return (&NativePtr->selected_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->selected_hover);
}

void nuklear::NkStyleEdit::SelectedHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->selected_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::SelectedTextNormal::get()
{
    return (&NativePtr->selected_text_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->selected_text_normal);
}

void nuklear::NkStyleEdit::SelectedTextNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->selected_text_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleEdit::SelectedTextHover::get()
{
    return (&NativePtr->selected_text_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->selected_text_hover);
}

void nuklear::NkStyleEdit::SelectedTextHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->selected_text_hover = *(struct ::nk_color*)value->NativePtr;
}

float nuklear::NkStyleEdit::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleEdit::Border::set(float value)
{
    ((struct ::nk_style_edit*)NativePtr)->border = value;
}

float nuklear::NkStyleEdit::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleEdit::Rounding::set(float value)
{
    ((struct ::nk_style_edit*)NativePtr)->rounding = value;
}

float nuklear::NkStyleEdit::CursorSize::get()
{
    return NativePtr->cursor_size;
}

void nuklear::NkStyleEdit::CursorSize::set(float value)
{
    ((struct ::nk_style_edit*)NativePtr)->cursor_size = value;
}

::nuklear::NkVec2^ nuklear::NkStyleEdit::ScrollbarSize::get()
{
    return (&NativePtr->scrollbar_size == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->scrollbar_size);
}

void nuklear::NkStyleEdit::ScrollbarSize::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->scrollbar_size = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleEdit::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleEdit::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_edit*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

float nuklear::NkStyleEdit::RowPadding::get()
{
    return NativePtr->row_padding;
}

void nuklear::NkStyleEdit::RowPadding::set(float value)
{
    ((struct ::nk_style_edit*)NativePtr)->row_padding = value;
}

nuklear::NkStyleProperty::NkStyleProperty(struct ::nk_style_property* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleProperty^ nuklear::NkStyleProperty::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleProperty((struct ::nk_style_property*) native.ToPointer());
}

nuklear::NkStyleProperty::NkStyleProperty(struct ::nk_style_property* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleProperty^ nuklear::NkStyleProperty::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleProperty((struct ::nk_style_property*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleProperty::~NkStyleProperty()
{
    delete NativePtr;
}

nuklear::NkStyleProperty::!NkStyleProperty()
{
    delete NativePtr;
}

nuklear::NkStyleProperty::NkStyleProperty()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_property();
}

nuklear::NkStyleProperty::NkStyleProperty(::nuklear::NkStyleProperty^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_property*)_0->NativePtr;
    NativePtr = new struct ::nk_style_property(__arg0);
}

::System::IntPtr nuklear::NkStyleProperty::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleProperty::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_property*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleProperty::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleProperty::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProperty::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleProperty::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleProperty::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleProperty::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleProperty::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleProperty::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleProperty::LabelNormal::get()
{
    return (&NativePtr->label_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_normal);
}

void nuklear::NkStyleProperty::LabelNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->label_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleProperty::LabelHover::get()
{
    return (&NativePtr->label_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_hover);
}

void nuklear::NkStyleProperty::LabelHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->label_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleProperty::LabelActive::get()
{
    return (&NativePtr->label_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_active);
}

void nuklear::NkStyleProperty::LabelActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->label_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkSymbolType nuklear::NkStyleProperty::SymLeft::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_left;
}

void nuklear::NkStyleProperty::SymLeft::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_property*)NativePtr)->sym_left = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleProperty::SymRight::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_right;
}

void nuklear::NkStyleProperty::SymRight::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_property*)NativePtr)->sym_right = (enum ::nk_symbol_type)value;
}

float nuklear::NkStyleProperty::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleProperty::Border::set(float value)
{
    ((struct ::nk_style_property*)NativePtr)->border = value;
}

float nuklear::NkStyleProperty::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleProperty::Rounding::set(float value)
{
    ((struct ::nk_style_property*)NativePtr)->rounding = value;
}

::nuklear::NkVec2^ nuklear::NkStyleProperty::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleProperty::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkStyleEdit^ nuklear::NkStyleProperty::Edit::get()
{
    return (&NativePtr->edit == nullptr) ? nullptr : gcnew ::nuklear::NkStyleEdit((struct ::nk_style_edit*)&NativePtr->edit);
}

void nuklear::NkStyleProperty::Edit::set(::nuklear::NkStyleEdit^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->edit = *(struct ::nk_style_edit*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleProperty::IncButton::get()
{
    return (&NativePtr->inc_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->inc_button);
}

void nuklear::NkStyleProperty::IncButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->inc_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleProperty::DecButton::get()
{
    return (&NativePtr->dec_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->dec_button);
}

void nuklear::NkStyleProperty::DecButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_property*)NativePtr)->dec_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkHandle nuklear::NkStyleProperty::Userdata::get()
{
    return ::nuklear::NkHandle((::nk_handle*)&NativePtr->userdata);
}

void nuklear::NkStyleProperty::Userdata::set(::nuklear::NkHandle value)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)value.Ptr;
    _marshal0.id = value.Id;
    ((struct ::nk_style_property*)NativePtr)->userdata = _marshal0;
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleProperty::DrawBegin::get()
{
    return NativePtr->draw_begin == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_begin), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleProperty::DrawBegin::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_property*)NativePtr)->draw_begin = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ nuklear::NkStyleProperty::DrawEnd::get()
{
    return NativePtr->draw_end == nullptr ? nullptr : safe_cast<::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^>(::System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(::System::IntPtr(NativePtr->draw_end), ::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal::typeid));
}

void nuklear::NkStyleProperty::DrawEnd::set(::nuklear::NkStyleButton::Action___IntPtr_nuklear_nk_handle___Internal^ value)
{
    ((struct ::nk_style_property*)NativePtr)->draw_end = static_cast<void (*)(::nk_command_buffer*, nk_handle)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

nuklear::NkStyleChart::NkStyleChart(struct ::nk_style_chart* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleChart^ nuklear::NkStyleChart::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleChart((struct ::nk_style_chart*) native.ToPointer());
}

nuklear::NkStyleChart::NkStyleChart(struct ::nk_style_chart* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleChart^ nuklear::NkStyleChart::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleChart((struct ::nk_style_chart*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleChart::~NkStyleChart()
{
    delete NativePtr;
}

nuklear::NkStyleChart::!NkStyleChart()
{
    delete NativePtr;
}

nuklear::NkStyleChart::NkStyleChart()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_chart();
}

nuklear::NkStyleChart::NkStyleChart(::nuklear::NkStyleChart^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_chart*)_0->NativePtr;
    NativePtr = new struct ::nk_style_chart(__arg0);
}

::System::IntPtr nuklear::NkStyleChart::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleChart::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_chart*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleChart::Background::get()
{
    return (&NativePtr->background == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->background);
}

void nuklear::NkStyleChart::Background::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_chart*)NativePtr)->background = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleChart::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleChart::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_chart*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleChart::SelectedColor::get()
{
    return (&NativePtr->selected_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->selected_color);
}

void nuklear::NkStyleChart::SelectedColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_chart*)NativePtr)->selected_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleChart::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkStyleChart::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_chart*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

float nuklear::NkStyleChart::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleChart::Border::set(float value)
{
    ((struct ::nk_style_chart*)NativePtr)->border = value;
}

float nuklear::NkStyleChart::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleChart::Rounding::set(float value)
{
    ((struct ::nk_style_chart*)NativePtr)->rounding = value;
}

::nuklear::NkVec2^ nuklear::NkStyleChart::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleChart::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_chart*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkStyleCombo::NkStyleCombo(struct ::nk_style_combo* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleCombo^ nuklear::NkStyleCombo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleCombo((struct ::nk_style_combo*) native.ToPointer());
}

nuklear::NkStyleCombo::NkStyleCombo(struct ::nk_style_combo* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleCombo^ nuklear::NkStyleCombo::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleCombo((struct ::nk_style_combo*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleCombo::~NkStyleCombo()
{
    delete NativePtr;
}

nuklear::NkStyleCombo::!NkStyleCombo()
{
    delete NativePtr;
}

nuklear::NkStyleCombo::NkStyleCombo()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_combo();
}

nuklear::NkStyleCombo::NkStyleCombo(::nuklear::NkStyleCombo^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_combo*)_0->NativePtr;
    NativePtr = new struct ::nk_style_combo(__arg0);
}

::System::IntPtr nuklear::NkStyleCombo::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleCombo::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_combo*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleCombo::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleCombo::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleCombo::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleCombo::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleCombo::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleCombo::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleCombo::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::LabelNormal::get()
{
    return (&NativePtr->label_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_normal);
}

void nuklear::NkStyleCombo::LabelNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->label_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::LabelHover::get()
{
    return (&NativePtr->label_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_hover);
}

void nuklear::NkStyleCombo::LabelHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->label_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::LabelActive::get()
{
    return (&NativePtr->label_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_active);
}

void nuklear::NkStyleCombo::LabelActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->label_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::SymbolNormal::get()
{
    return (&NativePtr->symbol_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->symbol_normal);
}

void nuklear::NkStyleCombo::SymbolNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->symbol_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::SymbolHover::get()
{
    return (&NativePtr->symbol_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->symbol_hover);
}

void nuklear::NkStyleCombo::SymbolHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->symbol_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleCombo::SymbolActive::get()
{
    return (&NativePtr->symbol_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->symbol_active);
}

void nuklear::NkStyleCombo::SymbolActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->symbol_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleCombo::Button::get()
{
    return (&NativePtr->button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->button);
}

void nuklear::NkStyleCombo::Button::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkSymbolType nuklear::NkStyleCombo::SymNormal::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_normal;
}

void nuklear::NkStyleCombo::SymNormal::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_combo*)NativePtr)->sym_normal = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleCombo::SymHover::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_hover;
}

void nuklear::NkStyleCombo::SymHover::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_combo*)NativePtr)->sym_hover = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleCombo::SymActive::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_active;
}

void nuklear::NkStyleCombo::SymActive::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_combo*)NativePtr)->sym_active = (enum ::nk_symbol_type)value;
}

float nuklear::NkStyleCombo::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleCombo::Border::set(float value)
{
    ((struct ::nk_style_combo*)NativePtr)->border = value;
}

float nuklear::NkStyleCombo::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleCombo::Rounding::set(float value)
{
    ((struct ::nk_style_combo*)NativePtr)->rounding = value;
}

::nuklear::NkVec2^ nuklear::NkStyleCombo::ContentPadding::get()
{
    return (&NativePtr->content_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->content_padding);
}

void nuklear::NkStyleCombo::ContentPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->content_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleCombo::ButtonPadding::get()
{
    return (&NativePtr->button_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->button_padding);
}

void nuklear::NkStyleCombo::ButtonPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->button_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleCombo::Spacing::get()
{
    return (&NativePtr->spacing == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->spacing);
}

void nuklear::NkStyleCombo::Spacing::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_combo*)NativePtr)->spacing = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkStyleTab::NkStyleTab(struct ::nk_style_tab* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleTab^ nuklear::NkStyleTab::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleTab((struct ::nk_style_tab*) native.ToPointer());
}

nuklear::NkStyleTab::NkStyleTab(struct ::nk_style_tab* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleTab^ nuklear::NkStyleTab::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleTab((struct ::nk_style_tab*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleTab::~NkStyleTab()
{
    delete NativePtr;
}

nuklear::NkStyleTab::!NkStyleTab()
{
    delete NativePtr;
}

nuklear::NkStyleTab::NkStyleTab()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_tab();
}

nuklear::NkStyleTab::NkStyleTab(::nuklear::NkStyleTab^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_tab*)_0->NativePtr;
    NativePtr = new struct ::nk_style_tab(__arg0);
}

::System::IntPtr nuklear::NkStyleTab::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleTab::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_tab*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleTab::Background::get()
{
    return (&NativePtr->background == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->background);
}

void nuklear::NkStyleTab::Background::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->background = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleTab::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleTab::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleTab::Text::get()
{
    return (&NativePtr->text == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->text);
}

void nuklear::NkStyleTab::Text::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->text = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleTab::TabMaximizeButton::get()
{
    return (&NativePtr->tab_maximize_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->tab_maximize_button);
}

void nuklear::NkStyleTab::TabMaximizeButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->tab_maximize_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleTab::TabMinimizeButton::get()
{
    return (&NativePtr->tab_minimize_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->tab_minimize_button);
}

void nuklear::NkStyleTab::TabMinimizeButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->tab_minimize_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleTab::NodeMaximizeButton::get()
{
    return (&NativePtr->node_maximize_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->node_maximize_button);
}

void nuklear::NkStyleTab::NodeMaximizeButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->node_maximize_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleTab::NodeMinimizeButton::get()
{
    return (&NativePtr->node_minimize_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->node_minimize_button);
}

void nuklear::NkStyleTab::NodeMinimizeButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->node_minimize_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkSymbolType nuklear::NkStyleTab::SymMinimize::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_minimize;
}

void nuklear::NkStyleTab::SymMinimize::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_tab*)NativePtr)->sym_minimize = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleTab::SymMaximize::get()
{
    return (::nuklear::NkSymbolType)NativePtr->sym_maximize;
}

void nuklear::NkStyleTab::SymMaximize::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_tab*)NativePtr)->sym_maximize = (enum ::nk_symbol_type)value;
}

float nuklear::NkStyleTab::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleTab::Border::set(float value)
{
    ((struct ::nk_style_tab*)NativePtr)->border = value;
}

float nuklear::NkStyleTab::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleTab::Rounding::set(float value)
{
    ((struct ::nk_style_tab*)NativePtr)->rounding = value;
}

float nuklear::NkStyleTab::Indent::get()
{
    return NativePtr->indent;
}

void nuklear::NkStyleTab::Indent::set(float value)
{
    ((struct ::nk_style_tab*)NativePtr)->indent = value;
}

::nuklear::NkVec2^ nuklear::NkStyleTab::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleTab::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleTab::Spacing::get()
{
    return (&NativePtr->spacing == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->spacing);
}

void nuklear::NkStyleTab::Spacing::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_tab*)NativePtr)->spacing = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkStyleWindowHeader::NkStyleWindowHeader(struct ::nk_style_window_header* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleWindowHeader^ nuklear::NkStyleWindowHeader::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleWindowHeader((struct ::nk_style_window_header*) native.ToPointer());
}

nuklear::NkStyleWindowHeader::NkStyleWindowHeader(struct ::nk_style_window_header* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleWindowHeader^ nuklear::NkStyleWindowHeader::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleWindowHeader((struct ::nk_style_window_header*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleWindowHeader::~NkStyleWindowHeader()
{
    delete NativePtr;
}

nuklear::NkStyleWindowHeader::!NkStyleWindowHeader()
{
    delete NativePtr;
}

nuklear::NkStyleWindowHeader::NkStyleWindowHeader()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_window_header();
}

nuklear::NkStyleWindowHeader::NkStyleWindowHeader(::nuklear::NkStyleWindowHeader^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_window_header*)_0->NativePtr;
    NativePtr = new struct ::nk_style_window_header(__arg0);
}

::System::IntPtr nuklear::NkStyleWindowHeader::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleWindowHeader::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_window_header*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkStyleWindowHeader::Normal::get()
{
    return (&NativePtr->normal == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->normal);
}

void nuklear::NkStyleWindowHeader::Normal::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->normal = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleWindowHeader::Hover::get()
{
    return (&NativePtr->hover == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->hover);
}

void nuklear::NkStyleWindowHeader::Hover::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->hover = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleWindowHeader::Active::get()
{
    return (&NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->active);
}

void nuklear::NkStyleWindowHeader::Active::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->active = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleWindowHeader::CloseButton::get()
{
    return (&NativePtr->close_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->close_button);
}

void nuklear::NkStyleWindowHeader::CloseButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->close_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyleWindowHeader::MinimizeButton::get()
{
    return (&NativePtr->minimize_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->minimize_button);
}

void nuklear::NkStyleWindowHeader::MinimizeButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->minimize_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkSymbolType nuklear::NkStyleWindowHeader::CloseSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->close_symbol;
}

void nuklear::NkStyleWindowHeader::CloseSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_window_header*)NativePtr)->close_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleWindowHeader::MinimizeSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->minimize_symbol;
}

void nuklear::NkStyleWindowHeader::MinimizeSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_window_header*)NativePtr)->minimize_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkSymbolType nuklear::NkStyleWindowHeader::MaximizeSymbol::get()
{
    return (::nuklear::NkSymbolType)NativePtr->maximize_symbol;
}

void nuklear::NkStyleWindowHeader::MaximizeSymbol::set(::nuklear::NkSymbolType value)
{
    ((struct ::nk_style_window_header*)NativePtr)->maximize_symbol = (enum ::nk_symbol_type)value;
}

::nuklear::NkColor^ nuklear::NkStyleWindowHeader::LabelNormal::get()
{
    return (&NativePtr->label_normal == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_normal);
}

void nuklear::NkStyleWindowHeader::LabelNormal::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->label_normal = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindowHeader::LabelHover::get()
{
    return (&NativePtr->label_hover == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_hover);
}

void nuklear::NkStyleWindowHeader::LabelHover::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->label_hover = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindowHeader::LabelActive::get()
{
    return (&NativePtr->label_active == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->label_active);
}

void nuklear::NkStyleWindowHeader::LabelActive::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->label_active = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleHeaderAlign nuklear::NkStyleWindowHeader::Align::get()
{
    return (::nuklear::NkStyleHeaderAlign)NativePtr->align;
}

void nuklear::NkStyleWindowHeader::Align::set(::nuklear::NkStyleHeaderAlign value)
{
    ((struct ::nk_style_window_header*)NativePtr)->align = (enum ::nk_style_header_align)value;
}

::nuklear::NkVec2^ nuklear::NkStyleWindowHeader::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleWindowHeader::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindowHeader::LabelPadding::get()
{
    return (&NativePtr->label_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->label_padding);
}

void nuklear::NkStyleWindowHeader::LabelPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->label_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindowHeader::Spacing::get()
{
    return (&NativePtr->spacing == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->spacing);
}

void nuklear::NkStyleWindowHeader::Spacing::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window_header*)NativePtr)->spacing = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkStyleWindow::NkStyleWindow(struct ::nk_style_window* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyleWindow^ nuklear::NkStyleWindow::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyleWindow((struct ::nk_style_window*) native.ToPointer());
}

nuklear::NkStyleWindow::NkStyleWindow(struct ::nk_style_window* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyleWindow^ nuklear::NkStyleWindow::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyleWindow((struct ::nk_style_window*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyleWindow::~NkStyleWindow()
{
    delete NativePtr;
}

nuklear::NkStyleWindow::!NkStyleWindow()
{
    delete NativePtr;
}

nuklear::NkStyleWindow::NkStyleWindow()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style_window();
}

nuklear::NkStyleWindow::NkStyleWindow(::nuklear::NkStyleWindow^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style_window*)_0->NativePtr;
    NativePtr = new struct ::nk_style_window(__arg0);
}

::System::IntPtr nuklear::NkStyleWindow::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyleWindow::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style_window*)object.ToPointer();
}

::nuklear::NkStyleWindowHeader^ nuklear::NkStyleWindow::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkStyleWindowHeader((struct ::nk_style_window_header*)&NativePtr->header);
}

void nuklear::NkStyleWindow::Header::set(::nuklear::NkStyleWindowHeader^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->header = *(struct ::nk_style_window_header*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleWindow::FixedBackground::get()
{
    return (&NativePtr->fixed_background == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->fixed_background);
}

void nuklear::NkStyleWindow::FixedBackground::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->fixed_background = *(struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::Background::get()
{
    return (&NativePtr->background == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->background);
}

void nuklear::NkStyleWindow::Background::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->background = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::BorderColor::get()
{
    return (&NativePtr->border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->border_color);
}

void nuklear::NkStyleWindow::BorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::PopupBorderColor::get()
{
    return (&NativePtr->popup_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->popup_border_color);
}

void nuklear::NkStyleWindow::PopupBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->popup_border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::ComboBorderColor::get()
{
    return (&NativePtr->combo_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->combo_border_color);
}

void nuklear::NkStyleWindow::ComboBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->combo_border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::ContextualBorderColor::get()
{
    return (&NativePtr->contextual_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->contextual_border_color);
}

void nuklear::NkStyleWindow::ContextualBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->contextual_border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::MenuBorderColor::get()
{
    return (&NativePtr->menu_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->menu_border_color);
}

void nuklear::NkStyleWindow::MenuBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->menu_border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::GroupBorderColor::get()
{
    return (&NativePtr->group_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->group_border_color);
}

void nuklear::NkStyleWindow::GroupBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->group_border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkStyleWindow::TooltipBorderColor::get()
{
    return (&NativePtr->tooltip_border_color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->tooltip_border_color);
}

void nuklear::NkStyleWindow::TooltipBorderColor::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->tooltip_border_color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkStyleWindow::Scaler::get()
{
    return (&NativePtr->scaler == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->scaler);
}

void nuklear::NkStyleWindow::Scaler::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->scaler = *(struct ::nk_style_item*)value->NativePtr;
}

float nuklear::NkStyleWindow::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkStyleWindow::Border::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->border = value;
}

float nuklear::NkStyleWindow::ComboBorder::get()
{
    return NativePtr->combo_border;
}

void nuklear::NkStyleWindow::ComboBorder::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->combo_border = value;
}

float nuklear::NkStyleWindow::ContextualBorder::get()
{
    return NativePtr->contextual_border;
}

void nuklear::NkStyleWindow::ContextualBorder::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->contextual_border = value;
}

float nuklear::NkStyleWindow::MenuBorder::get()
{
    return NativePtr->menu_border;
}

void nuklear::NkStyleWindow::MenuBorder::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->menu_border = value;
}

float nuklear::NkStyleWindow::GroupBorder::get()
{
    return NativePtr->group_border;
}

void nuklear::NkStyleWindow::GroupBorder::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->group_border = value;
}

float nuklear::NkStyleWindow::TooltipBorder::get()
{
    return NativePtr->tooltip_border;
}

void nuklear::NkStyleWindow::TooltipBorder::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->tooltip_border = value;
}

float nuklear::NkStyleWindow::PopupBorder::get()
{
    return NativePtr->popup_border;
}

void nuklear::NkStyleWindow::PopupBorder::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->popup_border = value;
}

float nuklear::NkStyleWindow::MinRowHeightPadding::get()
{
    return NativePtr->min_row_height_padding;
}

void nuklear::NkStyleWindow::MinRowHeightPadding::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->min_row_height_padding = value;
}

float nuklear::NkStyleWindow::Rounding::get()
{
    return NativePtr->rounding;
}

void nuklear::NkStyleWindow::Rounding::set(float value)
{
    ((struct ::nk_style_window*)NativePtr)->rounding = value;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::Spacing::get()
{
    return (&NativePtr->spacing == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->spacing);
}

void nuklear::NkStyleWindow::Spacing::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->spacing = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::ScrollbarSize::get()
{
    return (&NativePtr->scrollbar_size == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->scrollbar_size);
}

void nuklear::NkStyleWindow::ScrollbarSize::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->scrollbar_size = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::MinSize::get()
{
    return (&NativePtr->min_size == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->min_size);
}

void nuklear::NkStyleWindow::MinSize::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->min_size = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::Padding::get()
{
    return (&NativePtr->padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->padding);
}

void nuklear::NkStyleWindow::Padding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::GroupPadding::get()
{
    return (&NativePtr->group_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->group_padding);
}

void nuklear::NkStyleWindow::GroupPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->group_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::PopupPadding::get()
{
    return (&NativePtr->popup_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->popup_padding);
}

void nuklear::NkStyleWindow::PopupPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->popup_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::ComboPadding::get()
{
    return (&NativePtr->combo_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->combo_padding);
}

void nuklear::NkStyleWindow::ComboPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->combo_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::ContextualPadding::get()
{
    return (&NativePtr->contextual_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->contextual_padding);
}

void nuklear::NkStyleWindow::ContextualPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->contextual_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::MenuPadding::get()
{
    return (&NativePtr->menu_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->menu_padding);
}

void nuklear::NkStyleWindow::MenuPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->menu_padding = *(struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkStyleWindow::TooltipPadding::get()
{
    return (&NativePtr->tooltip_padding == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->tooltip_padding);
}

void nuklear::NkStyleWindow::TooltipPadding::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style_window*)NativePtr)->tooltip_padding = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkStyle::NkStyle(struct ::nk_style* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkStyle^ nuklear::NkStyle::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkStyle((struct ::nk_style*) native.ToPointer());
}

nuklear::NkStyle::NkStyle(struct ::nk_style* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkStyle^ nuklear::NkStyle::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkStyle((struct ::nk_style*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkStyle::~NkStyle()
{
    delete NativePtr;
}

nuklear::NkStyle::!NkStyle()
{
    delete NativePtr;
}

nuklear::NkStyle::NkStyle()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_style();
}

nuklear::NkStyle::NkStyle(::nuklear::NkStyle^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_style*)_0->NativePtr;
    NativePtr = new struct ::nk_style(__arg0);
}

::System::IntPtr nuklear::NkStyle::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkStyle::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_style*)object.ToPointer();
}

::nuklear::NkUserFont^ nuklear::NkStyle::Font::get()
{
    return (NativePtr->font == nullptr) ? nullptr : gcnew ::nuklear::NkUserFont((struct ::nk_user_font*)NativePtr->font);
}

::nuklear::NkCursor^ nuklear::NkStyle::CursorActive::get()
{
    return (NativePtr->cursor_active == nullptr) ? nullptr : gcnew ::nuklear::NkCursor((struct ::nk_cursor*)NativePtr->cursor_active);
}

::nuklear::NkCursor^ nuklear::NkStyle::CursorLast::get()
{
    return (NativePtr->cursor_last == nullptr) ? nullptr : gcnew ::nuklear::NkCursor((struct ::nk_cursor*)NativePtr->cursor_last);
}

void nuklear::NkStyle::CursorLast::set(::nuklear::NkCursor^ value)
{
    ((struct ::nk_style*)NativePtr)->cursor_last = (struct ::nk_cursor*)value->NativePtr;
}

int nuklear::NkStyle::CursorVisible::get()
{
    return NativePtr->cursor_visible;
}

void nuklear::NkStyle::CursorVisible::set(int value)
{
    ((struct ::nk_style*)NativePtr)->cursor_visible = value;
}

::nuklear::NkStyleText^ nuklear::NkStyle::Text::get()
{
    return (&NativePtr->text == nullptr) ? nullptr : gcnew ::nuklear::NkStyleText((struct ::nk_style_text*)&NativePtr->text);
}

void nuklear::NkStyle::Text::set(::nuklear::NkStyleText^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->text = *(struct ::nk_style_text*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyle::Button::get()
{
    return (&NativePtr->button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->button);
}

void nuklear::NkStyle::Button::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyle::ContextualButton::get()
{
    return (&NativePtr->contextual_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->contextual_button);
}

void nuklear::NkStyle::ContextualButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->contextual_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleButton^ nuklear::NkStyle::MenuButton::get()
{
    return (&NativePtr->menu_button == nullptr) ? nullptr : gcnew ::nuklear::NkStyleButton((struct ::nk_style_button*)&NativePtr->menu_button);
}

void nuklear::NkStyle::MenuButton::set(::nuklear::NkStyleButton^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->menu_button = *(struct ::nk_style_button*)value->NativePtr;
}

::nuklear::NkStyleToggle^ nuklear::NkStyle::Option::get()
{
    return (&NativePtr->option == nullptr) ? nullptr : gcnew ::nuklear::NkStyleToggle((struct ::nk_style_toggle*)&NativePtr->option);
}

void nuklear::NkStyle::Option::set(::nuklear::NkStyleToggle^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->option = *(struct ::nk_style_toggle*)value->NativePtr;
}

::nuklear::NkStyleToggle^ nuklear::NkStyle::Checkbox::get()
{
    return (&NativePtr->checkbox == nullptr) ? nullptr : gcnew ::nuklear::NkStyleToggle((struct ::nk_style_toggle*)&NativePtr->checkbox);
}

void nuklear::NkStyle::Checkbox::set(::nuklear::NkStyleToggle^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->checkbox = *(struct ::nk_style_toggle*)value->NativePtr;
}

::nuklear::NkStyleSelectable^ nuklear::NkStyle::Selectable::get()
{
    return (&NativePtr->selectable == nullptr) ? nullptr : gcnew ::nuklear::NkStyleSelectable((struct ::nk_style_selectable*)&NativePtr->selectable);
}

void nuklear::NkStyle::Selectable::set(::nuklear::NkStyleSelectable^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->selectable = *(struct ::nk_style_selectable*)value->NativePtr;
}

::nuklear::NkStyleSlider^ nuklear::NkStyle::Slider::get()
{
    return (&NativePtr->slider == nullptr) ? nullptr : gcnew ::nuklear::NkStyleSlider((struct ::nk_style_slider*)&NativePtr->slider);
}

void nuklear::NkStyle::Slider::set(::nuklear::NkStyleSlider^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->slider = *(struct ::nk_style_slider*)value->NativePtr;
}

::nuklear::NkStyleProgress^ nuklear::NkStyle::Progress::get()
{
    return (&NativePtr->progress == nullptr) ? nullptr : gcnew ::nuklear::NkStyleProgress((struct ::nk_style_progress*)&NativePtr->progress);
}

void nuklear::NkStyle::Progress::set(::nuklear::NkStyleProgress^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->progress = *(struct ::nk_style_progress*)value->NativePtr;
}

::nuklear::NkStyleProperty^ nuklear::NkStyle::Property::get()
{
    return (&NativePtr->property == nullptr) ? nullptr : gcnew ::nuklear::NkStyleProperty((struct ::nk_style_property*)&NativePtr->property);
}

void nuklear::NkStyle::Property::set(::nuklear::NkStyleProperty^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->property = *(struct ::nk_style_property*)value->NativePtr;
}

::nuklear::NkStyleEdit^ nuklear::NkStyle::Edit::get()
{
    return (&NativePtr->edit == nullptr) ? nullptr : gcnew ::nuklear::NkStyleEdit((struct ::nk_style_edit*)&NativePtr->edit);
}

void nuklear::NkStyle::Edit::set(::nuklear::NkStyleEdit^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->edit = *(struct ::nk_style_edit*)value->NativePtr;
}

::nuklear::NkStyleChart^ nuklear::NkStyle::Chart::get()
{
    return (&NativePtr->chart == nullptr) ? nullptr : gcnew ::nuklear::NkStyleChart((struct ::nk_style_chart*)&NativePtr->chart);
}

void nuklear::NkStyle::Chart::set(::nuklear::NkStyleChart^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->chart = *(struct ::nk_style_chart*)value->NativePtr;
}

::nuklear::NkStyleScrollbar^ nuklear::NkStyle::Scrollh::get()
{
    return (&NativePtr->scrollh == nullptr) ? nullptr : gcnew ::nuklear::NkStyleScrollbar((struct ::nk_style_scrollbar*)&NativePtr->scrollh);
}

void nuklear::NkStyle::Scrollh::set(::nuklear::NkStyleScrollbar^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->scrollh = *(struct ::nk_style_scrollbar*)value->NativePtr;
}

::nuklear::NkStyleScrollbar^ nuklear::NkStyle::Scrollv::get()
{
    return (&NativePtr->scrollv == nullptr) ? nullptr : gcnew ::nuklear::NkStyleScrollbar((struct ::nk_style_scrollbar*)&NativePtr->scrollv);
}

void nuklear::NkStyle::Scrollv::set(::nuklear::NkStyleScrollbar^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->scrollv = *(struct ::nk_style_scrollbar*)value->NativePtr;
}

::nuklear::NkStyleTab^ nuklear::NkStyle::Tab::get()
{
    return (&NativePtr->tab == nullptr) ? nullptr : gcnew ::nuklear::NkStyleTab((struct ::nk_style_tab*)&NativePtr->tab);
}

void nuklear::NkStyle::Tab::set(::nuklear::NkStyleTab^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->tab = *(struct ::nk_style_tab*)value->NativePtr;
}

::nuklear::NkStyleCombo^ nuklear::NkStyle::Combo::get()
{
    return (&NativePtr->combo == nullptr) ? nullptr : gcnew ::nuklear::NkStyleCombo((struct ::nk_style_combo*)&NativePtr->combo);
}

void nuklear::NkStyle::Combo::set(::nuklear::NkStyleCombo^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->combo = *(struct ::nk_style_combo*)value->NativePtr;
}

::nuklear::NkStyleWindow^ nuklear::NkStyle::Window::get()
{
    return (&NativePtr->window == nullptr) ? nullptr : gcnew ::nuklear::NkStyleWindow((struct ::nk_style_window*)&NativePtr->window);
}

void nuklear::NkStyle::Window::set(::nuklear::NkStyleWindow^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_style*)NativePtr)->window = *(struct ::nk_style_window*)value->NativePtr;
}

nuklear::NkChartSlot::NkChartSlot(struct ::nk_chart_slot* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkChartSlot^ nuklear::NkChartSlot::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkChartSlot((struct ::nk_chart_slot*) native.ToPointer());
}

nuklear::NkChartSlot::NkChartSlot(struct ::nk_chart_slot* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkChartSlot^ nuklear::NkChartSlot::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkChartSlot((struct ::nk_chart_slot*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkChartSlot::~NkChartSlot()
{
    delete NativePtr;
}

nuklear::NkChartSlot::!NkChartSlot()
{
    delete NativePtr;
}

nuklear::NkChartSlot::NkChartSlot()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_chart_slot();
}

nuklear::NkChartSlot::NkChartSlot(::nuklear::NkChartSlot^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_chart_slot*)_0->NativePtr;
    NativePtr = new struct ::nk_chart_slot(__arg0);
}

::System::IntPtr nuklear::NkChartSlot::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkChartSlot::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_chart_slot*)object.ToPointer();
}

::nuklear::NkChartType nuklear::NkChartSlot::Type::get()
{
    return (::nuklear::NkChartType)NativePtr->type;
}

void nuklear::NkChartSlot::Type::set(::nuklear::NkChartType value)
{
    ((struct ::nk_chart_slot*)NativePtr)->type = (enum ::nk_chart_type)value;
}

::nuklear::NkColor^ nuklear::NkChartSlot::Color::get()
{
    return (&NativePtr->color == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->color);
}

void nuklear::NkChartSlot::Color::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_chart_slot*)NativePtr)->color = *(struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkChartSlot::Highlight::get()
{
    return (&NativePtr->highlight == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->highlight);
}

void nuklear::NkChartSlot::Highlight::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_chart_slot*)NativePtr)->highlight = *(struct ::nk_color*)value->NativePtr;
}

float nuklear::NkChartSlot::Min::get()
{
    return NativePtr->min;
}

void nuklear::NkChartSlot::Min::set(float value)
{
    ((struct ::nk_chart_slot*)NativePtr)->min = value;
}

float nuklear::NkChartSlot::Max::get()
{
    return NativePtr->max;
}

void nuklear::NkChartSlot::Max::set(float value)
{
    ((struct ::nk_chart_slot*)NativePtr)->max = value;
}

float nuklear::NkChartSlot::Range::get()
{
    return NativePtr->range;
}

void nuklear::NkChartSlot::Range::set(float value)
{
    ((struct ::nk_chart_slot*)NativePtr)->range = value;
}

int nuklear::NkChartSlot::Count::get()
{
    return NativePtr->count;
}

void nuklear::NkChartSlot::Count::set(int value)
{
    ((struct ::nk_chart_slot*)NativePtr)->count = value;
}

::nuklear::NkVec2^ nuklear::NkChartSlot::Last::get()
{
    return (&NativePtr->last == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->last);
}

void nuklear::NkChartSlot::Last::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_chart_slot*)NativePtr)->last = *(struct ::nk_vec2*)value->NativePtr;
}

int nuklear::NkChartSlot::Index::get()
{
    return NativePtr->index;
}

void nuklear::NkChartSlot::Index::set(int value)
{
    ((struct ::nk_chart_slot*)NativePtr)->index = value;
}

nuklear::NkChart::NkChart(struct ::nk_chart* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkChart^ nuklear::NkChart::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkChart((struct ::nk_chart*) native.ToPointer());
}

nuklear::NkChart::NkChart(struct ::nk_chart* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkChart^ nuklear::NkChart::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkChart((struct ::nk_chart*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkChart::~NkChart()
{
    delete NativePtr;
}

nuklear::NkChart::!NkChart()
{
    delete NativePtr;
}

nuklear::NkChart::NkChart()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_chart();
}

nuklear::NkChart::NkChart(::nuklear::NkChart^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_chart*)_0->NativePtr;
    NativePtr = new struct ::nk_chart(__arg0);
}

::System::IntPtr nuklear::NkChart::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkChart::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_chart*)object.ToPointer();
}

int nuklear::NkChart::Slot::get()
{
    return NativePtr->slot;
}

void nuklear::NkChart::Slot::set(int value)
{
    ((struct ::nk_chart*)NativePtr)->slot = value;
}

float nuklear::NkChart::X::get()
{
    return NativePtr->x;
}

void nuklear::NkChart::X::set(float value)
{
    ((struct ::nk_chart*)NativePtr)->x = value;
}

float nuklear::NkChart::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkChart::Y::set(float value)
{
    ((struct ::nk_chart*)NativePtr)->y = value;
}

float nuklear::NkChart::W::get()
{
    return NativePtr->w;
}

void nuklear::NkChart::W::set(float value)
{
    ((struct ::nk_chart*)NativePtr)->w = value;
}

float nuklear::NkChart::H::get()
{
    return NativePtr->h;
}

void nuklear::NkChart::H::set(float value)
{
    ((struct ::nk_chart*)NativePtr)->h = value;
}

cli::array<::nuklear::NkChartSlot^>^ nuklear::NkChart::Slots::get()
{
    cli::array<::nuklear::NkChartSlot^>^ __array0 = nullptr;
    if (NativePtr->slots != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkChartSlot^>(4);
        for (int i = 0; i < 4; i++)
            __array0[i] = gcnew ::nuklear::NkChartSlot(&NativePtr->slots[i]);
    }
    return __array0;
}

void nuklear::NkChart::Slots::set(cli::array<::nuklear::NkChartSlot^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 4)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 4; i++)
            ((struct ::nk_chart*)NativePtr)->slots[i] = *value[i]->NativePtr;
    }
}

nuklear::NkRowLayout::NkRowLayout(struct ::nk_row_layout* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkRowLayout^ nuklear::NkRowLayout::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkRowLayout((struct ::nk_row_layout*) native.ToPointer());
}

nuklear::NkRowLayout::NkRowLayout(struct ::nk_row_layout* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkRowLayout^ nuklear::NkRowLayout::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkRowLayout((struct ::nk_row_layout*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkRowLayout::~NkRowLayout()
{
    delete NativePtr;
}

nuklear::NkRowLayout::!NkRowLayout()
{
    delete NativePtr;
}

nuklear::NkRowLayout::NkRowLayout()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_row_layout();
}

nuklear::NkRowLayout::NkRowLayout(::nuklear::NkRowLayout^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_row_layout*)_0->NativePtr;
    NativePtr = new struct ::nk_row_layout(__arg0);
}

::System::IntPtr nuklear::NkRowLayout::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkRowLayout::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_row_layout*)object.ToPointer();
}

::nuklear::NkPanelRowLayoutType nuklear::NkRowLayout::Type::get()
{
    return (::nuklear::NkPanelRowLayoutType)NativePtr->type;
}

void nuklear::NkRowLayout::Type::set(::nuklear::NkPanelRowLayoutType value)
{
    ((struct ::nk_row_layout*)NativePtr)->type = (enum ::nk_panel_row_layout_type)value;
}

int nuklear::NkRowLayout::Index::get()
{
    return NativePtr->index;
}

void nuklear::NkRowLayout::Index::set(int value)
{
    ((struct ::nk_row_layout*)NativePtr)->index = value;
}

float nuklear::NkRowLayout::Height::get()
{
    return NativePtr->height;
}

void nuklear::NkRowLayout::Height::set(float value)
{
    ((struct ::nk_row_layout*)NativePtr)->height = value;
}

float nuklear::NkRowLayout::MinHeight::get()
{
    return NativePtr->min_height;
}

void nuklear::NkRowLayout::MinHeight::set(float value)
{
    ((struct ::nk_row_layout*)NativePtr)->min_height = value;
}

int nuklear::NkRowLayout::Columns::get()
{
    return NativePtr->columns;
}

void nuklear::NkRowLayout::Columns::set(int value)
{
    ((struct ::nk_row_layout*)NativePtr)->columns = value;
}

float* nuklear::NkRowLayout::Ratio::get()
{
    return const_cast<float*>(NativePtr->ratio);
}

float nuklear::NkRowLayout::ItemWidth::get()
{
    return NativePtr->item_width;
}

void nuklear::NkRowLayout::ItemWidth::set(float value)
{
    ((struct ::nk_row_layout*)NativePtr)->item_width = value;
}

float nuklear::NkRowLayout::ItemHeight::get()
{
    return NativePtr->item_height;
}

void nuklear::NkRowLayout::ItemHeight::set(float value)
{
    ((struct ::nk_row_layout*)NativePtr)->item_height = value;
}

float nuklear::NkRowLayout::ItemOffset::get()
{
    return NativePtr->item_offset;
}

void nuklear::NkRowLayout::ItemOffset::set(float value)
{
    ((struct ::nk_row_layout*)NativePtr)->item_offset = value;
}

float nuklear::NkRowLayout::Filled::get()
{
    return NativePtr->filled;
}

void nuklear::NkRowLayout::Filled::set(float value)
{
    ((struct ::nk_row_layout*)NativePtr)->filled = value;
}

::nuklear::NkRect^ nuklear::NkRowLayout::Item::get()
{
    return (&NativePtr->item == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)&NativePtr->item);
}

void nuklear::NkRowLayout::Item::set(::nuklear::NkRect^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_row_layout*)NativePtr)->item = *(struct ::nk_rect*)value->NativePtr;
}

int nuklear::NkRowLayout::TreeDepth::get()
{
    return NativePtr->tree_depth;
}

void nuklear::NkRowLayout::TreeDepth::set(int value)
{
    ((struct ::nk_row_layout*)NativePtr)->tree_depth = value;
}

cli::array<float>^ nuklear::NkRowLayout::Templates::get()
{
    cli::array<float>^ __array0 = nullptr;
    if (NativePtr->templates != 0)
    {
        __array0 = gcnew cli::array<float>(16);
        for (int i = 0; i < 16; i++)
            __array0[i] = NativePtr->templates[i];
    }
    return __array0;
}

void nuklear::NkRowLayout::Templates::set(cli::array<float>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 16)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 16; i++)
            ((struct ::nk_row_layout*)NativePtr)->templates[i] = value[i];
    }
}

nuklear::NkPopupBuffer::NkPopupBuffer(struct ::nk_popup_buffer* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPopupBuffer^ nuklear::NkPopupBuffer::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPopupBuffer((struct ::nk_popup_buffer*) native.ToPointer());
}

nuklear::NkPopupBuffer::NkPopupBuffer(struct ::nk_popup_buffer* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPopupBuffer^ nuklear::NkPopupBuffer::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPopupBuffer((struct ::nk_popup_buffer*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPopupBuffer::~NkPopupBuffer()
{
    delete NativePtr;
}

nuklear::NkPopupBuffer::!NkPopupBuffer()
{
    delete NativePtr;
}

nuklear::NkPopupBuffer::NkPopupBuffer()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_popup_buffer();
}

nuklear::NkPopupBuffer::NkPopupBuffer(::nuklear::NkPopupBuffer^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_popup_buffer*)_0->NativePtr;
    NativePtr = new struct ::nk_popup_buffer(__arg0);
}

::System::IntPtr nuklear::NkPopupBuffer::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPopupBuffer::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_popup_buffer*)object.ToPointer();
}

unsigned long long nuklear::NkPopupBuffer::Begin::get()
{
    return NativePtr->begin;
}

void nuklear::NkPopupBuffer::Begin::set(unsigned long long value)
{
    ((struct ::nk_popup_buffer*)NativePtr)->begin = (::nk_size)value;
}

unsigned long long nuklear::NkPopupBuffer::Parent::get()
{
    return NativePtr->parent;
}

void nuklear::NkPopupBuffer::Parent::set(unsigned long long value)
{
    ((struct ::nk_popup_buffer*)NativePtr)->parent = (::nk_size)value;
}

unsigned long long nuklear::NkPopupBuffer::Last::get()
{
    return NativePtr->last;
}

void nuklear::NkPopupBuffer::Last::set(unsigned long long value)
{
    ((struct ::nk_popup_buffer*)NativePtr)->last = (::nk_size)value;
}

unsigned long long nuklear::NkPopupBuffer::End::get()
{
    return NativePtr->end;
}

void nuklear::NkPopupBuffer::End::set(unsigned long long value)
{
    ((struct ::nk_popup_buffer*)NativePtr)->end = (::nk_size)value;
}

int nuklear::NkPopupBuffer::Active::get()
{
    return NativePtr->active;
}

void nuklear::NkPopupBuffer::Active::set(int value)
{
    ((struct ::nk_popup_buffer*)NativePtr)->active = value;
}

nuklear::NkMenuState::NkMenuState(struct ::nk_menu_state* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkMenuState^ nuklear::NkMenuState::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkMenuState((struct ::nk_menu_state*) native.ToPointer());
}

nuklear::NkMenuState::NkMenuState(struct ::nk_menu_state* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkMenuState^ nuklear::NkMenuState::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkMenuState((struct ::nk_menu_state*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkMenuState::~NkMenuState()
{
    delete NativePtr;
}

nuklear::NkMenuState::!NkMenuState()
{
    delete NativePtr;
}

nuklear::NkMenuState::NkMenuState()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_menu_state();
}

nuklear::NkMenuState::NkMenuState(::nuklear::NkMenuState^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_menu_state*)_0->NativePtr;
    NativePtr = new struct ::nk_menu_state(__arg0);
}

::System::IntPtr nuklear::NkMenuState::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkMenuState::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_menu_state*)object.ToPointer();
}

float nuklear::NkMenuState::X::get()
{
    return NativePtr->x;
}

void nuklear::NkMenuState::X::set(float value)
{
    ((struct ::nk_menu_state*)NativePtr)->x = value;
}

float nuklear::NkMenuState::Y::get()
{
    return NativePtr->y;
}

void nuklear::NkMenuState::Y::set(float value)
{
    ((struct ::nk_menu_state*)NativePtr)->y = value;
}

float nuklear::NkMenuState::W::get()
{
    return NativePtr->w;
}

void nuklear::NkMenuState::W::set(float value)
{
    ((struct ::nk_menu_state*)NativePtr)->w = value;
}

float nuklear::NkMenuState::H::get()
{
    return NativePtr->h;
}

void nuklear::NkMenuState::H::set(float value)
{
    ((struct ::nk_menu_state*)NativePtr)->h = value;
}

::nuklear::NkScroll^ nuklear::NkMenuState::Offset::get()
{
    return (&NativePtr->offset == nullptr) ? nullptr : gcnew ::nuklear::NkScroll((struct ::nk_scroll*)&NativePtr->offset);
}

void nuklear::NkMenuState::Offset::set(::nuklear::NkScroll^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_menu_state*)NativePtr)->offset = *(struct ::nk_scroll*)value->NativePtr;
}

nuklear::NkPanel::NkPanel(struct ::nk_panel* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPanel^ nuklear::NkPanel::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPanel((struct ::nk_panel*) native.ToPointer());
}

nuklear::NkPanel::NkPanel(struct ::nk_panel* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPanel^ nuklear::NkPanel::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPanel((struct ::nk_panel*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPanel::~NkPanel()
{
    delete NativePtr;
}

nuklear::NkPanel::!NkPanel()
{
    delete NativePtr;
}

nuklear::NkPanel::NkPanel()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_panel();
}

nuklear::NkPanel::NkPanel(::nuklear::NkPanel^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_panel*)_0->NativePtr;
    NativePtr = new struct ::nk_panel(__arg0);
}

::System::IntPtr nuklear::NkPanel::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPanel::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_panel*)object.ToPointer();
}

::nuklear::NkPanelType nuklear::NkPanel::Type::get()
{
    return (::nuklear::NkPanelType)NativePtr->type;
}

void nuklear::NkPanel::Type::set(::nuklear::NkPanelType value)
{
    ((struct ::nk_panel*)NativePtr)->type = (enum ::nk_panel_type)value;
}

unsigned int nuklear::NkPanel::Flags::get()
{
    return NativePtr->flags;
}

void nuklear::NkPanel::Flags::set(unsigned int value)
{
    ((struct ::nk_panel*)NativePtr)->flags = (::nk_flags)(::nk_uint)value;
}

::nuklear::NkRect^ nuklear::NkPanel::Bounds::get()
{
    return (&NativePtr->bounds == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)&NativePtr->bounds);
}

void nuklear::NkPanel::Bounds::set(::nuklear::NkRect^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_panel*)NativePtr)->bounds = *(struct ::nk_rect*)value->NativePtr;
}

unsigned int* nuklear::NkPanel::OffsetX::get()
{
    return reinterpret_cast<unsigned int*>(NativePtr->offset_x);
}

void nuklear::NkPanel::OffsetX::set(unsigned int* value)
{
    ((struct ::nk_panel*)NativePtr)->offset_x = (nk_uint*)value;
}

unsigned int* nuklear::NkPanel::OffsetY::get()
{
    return reinterpret_cast<unsigned int*>(NativePtr->offset_y);
}

void nuklear::NkPanel::OffsetY::set(unsigned int* value)
{
    ((struct ::nk_panel*)NativePtr)->offset_y = (nk_uint*)value;
}

float nuklear::NkPanel::AtX::get()
{
    return NativePtr->at_x;
}

void nuklear::NkPanel::AtX::set(float value)
{
    ((struct ::nk_panel*)NativePtr)->at_x = value;
}

float nuklear::NkPanel::AtY::get()
{
    return NativePtr->at_y;
}

void nuklear::NkPanel::AtY::set(float value)
{
    ((struct ::nk_panel*)NativePtr)->at_y = value;
}

float nuklear::NkPanel::MaxX::get()
{
    return NativePtr->max_x;
}

void nuklear::NkPanel::MaxX::set(float value)
{
    ((struct ::nk_panel*)NativePtr)->max_x = value;
}

float nuklear::NkPanel::FooterHeight::get()
{
    return NativePtr->footer_height;
}

void nuklear::NkPanel::FooterHeight::set(float value)
{
    ((struct ::nk_panel*)NativePtr)->footer_height = value;
}

float nuklear::NkPanel::HeaderHeight::get()
{
    return NativePtr->header_height;
}

void nuklear::NkPanel::HeaderHeight::set(float value)
{
    ((struct ::nk_panel*)NativePtr)->header_height = value;
}

float nuklear::NkPanel::Border::get()
{
    return NativePtr->border;
}

void nuklear::NkPanel::Border::set(float value)
{
    ((struct ::nk_panel*)NativePtr)->border = value;
}

unsigned int nuklear::NkPanel::HasScrolling::get()
{
    return NativePtr->has_scrolling;
}

void nuklear::NkPanel::HasScrolling::set(unsigned int value)
{
    ((struct ::nk_panel*)NativePtr)->has_scrolling = value;
}

::nuklear::NkRect^ nuklear::NkPanel::Clip::get()
{
    return (&NativePtr->clip == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)&NativePtr->clip);
}

void nuklear::NkPanel::Clip::set(::nuklear::NkRect^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_panel*)NativePtr)->clip = *(struct ::nk_rect*)value->NativePtr;
}

::nuklear::NkMenuState^ nuklear::NkPanel::Menu::get()
{
    return (&NativePtr->menu == nullptr) ? nullptr : gcnew ::nuklear::NkMenuState((struct ::nk_menu_state*)&NativePtr->menu);
}

void nuklear::NkPanel::Menu::set(::nuklear::NkMenuState^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_panel*)NativePtr)->menu = *(struct ::nk_menu_state*)value->NativePtr;
}

::nuklear::NkRowLayout^ nuklear::NkPanel::Row::get()
{
    return (&NativePtr->row == nullptr) ? nullptr : gcnew ::nuklear::NkRowLayout((struct ::nk_row_layout*)&NativePtr->row);
}

void nuklear::NkPanel::Row::set(::nuklear::NkRowLayout^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_panel*)NativePtr)->row = *(struct ::nk_row_layout*)value->NativePtr;
}

::nuklear::NkChart^ nuklear::NkPanel::Chart::get()
{
    return (&NativePtr->chart == nullptr) ? nullptr : gcnew ::nuklear::NkChart((struct ::nk_chart*)&NativePtr->chart);
}

void nuklear::NkPanel::Chart::set(::nuklear::NkChart^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_panel*)NativePtr)->chart = *(struct ::nk_chart*)value->NativePtr;
}

::nuklear::NkCommandBuffer^ nuklear::NkPanel::Buffer::get()
{
    return (NativePtr->buffer == nullptr) ? nullptr : gcnew ::nuklear::NkCommandBuffer((struct ::nk_command_buffer*)NativePtr->buffer);
}

void nuklear::NkPanel::Buffer::set(::nuklear::NkCommandBuffer^ value)
{
    ((struct ::nk_panel*)NativePtr)->buffer = (struct ::nk_command_buffer*)value->NativePtr;
}

::nuklear::NkPanel^ nuklear::NkPanel::Parent::get()
{
    return (NativePtr->parent == nullptr) ? nullptr : gcnew ::nuklear::NkPanel((struct ::nk_panel*)NativePtr->parent);
}

void nuklear::NkPanel::Parent::set(::nuklear::NkPanel^ value)
{
    ((struct ::nk_panel*)NativePtr)->parent = (struct ::nk_panel*)value->NativePtr;
}

nuklear::NkPopupState::NkPopupState(struct ::nk_popup_state* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPopupState^ nuklear::NkPopupState::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPopupState((struct ::nk_popup_state*) native.ToPointer());
}

nuklear::NkPopupState::NkPopupState(struct ::nk_popup_state* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPopupState^ nuklear::NkPopupState::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPopupState((struct ::nk_popup_state*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPopupState::~NkPopupState()
{
    delete NativePtr;
}

nuklear::NkPopupState::!NkPopupState()
{
    delete NativePtr;
}

nuklear::NkPopupState::NkPopupState()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_popup_state();
}

nuklear::NkPopupState::NkPopupState(::nuklear::NkPopupState^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_popup_state*)_0->NativePtr;
    NativePtr = new struct ::nk_popup_state(__arg0);
}

::System::IntPtr nuklear::NkPopupState::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPopupState::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_popup_state*)object.ToPointer();
}

::nuklear::NkWindow^ nuklear::NkPopupState::Win::get()
{
    return (NativePtr->win == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->win);
}

void nuklear::NkPopupState::Win::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_popup_state*)NativePtr)->win = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkPanelType nuklear::NkPopupState::Type::get()
{
    return (::nuklear::NkPanelType)NativePtr->type;
}

void nuklear::NkPopupState::Type::set(::nuklear::NkPanelType value)
{
    ((struct ::nk_popup_state*)NativePtr)->type = (enum ::nk_panel_type)value;
}

::nuklear::NkPopupBuffer^ nuklear::NkPopupState::Buf::get()
{
    return (&NativePtr->buf == nullptr) ? nullptr : gcnew ::nuklear::NkPopupBuffer((struct ::nk_popup_buffer*)&NativePtr->buf);
}

void nuklear::NkPopupState::Buf::set(::nuklear::NkPopupBuffer^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_popup_state*)NativePtr)->buf = *(struct ::nk_popup_buffer*)value->NativePtr;
}

unsigned int nuklear::NkPopupState::Name::get()
{
    return NativePtr->name;
}

void nuklear::NkPopupState::Name::set(unsigned int value)
{
    ((struct ::nk_popup_state*)NativePtr)->name = (::nk_hash)(::nk_uint)value;
}

int nuklear::NkPopupState::Active::get()
{
    return NativePtr->active;
}

void nuklear::NkPopupState::Active::set(int value)
{
    ((struct ::nk_popup_state*)NativePtr)->active = value;
}

unsigned int nuklear::NkPopupState::ComboCount::get()
{
    return NativePtr->combo_count;
}

void nuklear::NkPopupState::ComboCount::set(unsigned int value)
{
    ((struct ::nk_popup_state*)NativePtr)->combo_count = value;
}

unsigned int nuklear::NkPopupState::ConCount::get()
{
    return NativePtr->con_count;
}

void nuklear::NkPopupState::ConCount::set(unsigned int value)
{
    ((struct ::nk_popup_state*)NativePtr)->con_count = value;
}

unsigned int nuklear::NkPopupState::ConOld::get()
{
    return NativePtr->con_old;
}

void nuklear::NkPopupState::ConOld::set(unsigned int value)
{
    ((struct ::nk_popup_state*)NativePtr)->con_old = value;
}

unsigned int nuklear::NkPopupState::ActiveCon::get()
{
    return NativePtr->active_con;
}

void nuklear::NkPopupState::ActiveCon::set(unsigned int value)
{
    ((struct ::nk_popup_state*)NativePtr)->active_con = value;
}

::nuklear::NkRect^ nuklear::NkPopupState::Header::get()
{
    return (&NativePtr->header == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)&NativePtr->header);
}

void nuklear::NkPopupState::Header::set(::nuklear::NkRect^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_popup_state*)NativePtr)->header = *(struct ::nk_rect*)value->NativePtr;
}

nuklear::NkEditState::NkEditState(struct ::nk_edit_state* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkEditState^ nuklear::NkEditState::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkEditState((struct ::nk_edit_state*) native.ToPointer());
}

nuklear::NkEditState::NkEditState(struct ::nk_edit_state* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkEditState^ nuklear::NkEditState::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkEditState((struct ::nk_edit_state*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkEditState::~NkEditState()
{
    delete NativePtr;
}

nuklear::NkEditState::!NkEditState()
{
    delete NativePtr;
}

nuklear::NkEditState::NkEditState()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_edit_state();
}

nuklear::NkEditState::NkEditState(::nuklear::NkEditState^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_edit_state*)_0->NativePtr;
    NativePtr = new struct ::nk_edit_state(__arg0);
}

::System::IntPtr nuklear::NkEditState::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkEditState::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_edit_state*)object.ToPointer();
}

unsigned int nuklear::NkEditState::Name::get()
{
    return NativePtr->name;
}

void nuklear::NkEditState::Name::set(unsigned int value)
{
    ((struct ::nk_edit_state*)NativePtr)->name = (::nk_hash)(::nk_uint)value;
}

unsigned int nuklear::NkEditState::Seq::get()
{
    return NativePtr->seq;
}

void nuklear::NkEditState::Seq::set(unsigned int value)
{
    ((struct ::nk_edit_state*)NativePtr)->seq = value;
}

unsigned int nuklear::NkEditState::Old::get()
{
    return NativePtr->old;
}

void nuklear::NkEditState::Old::set(unsigned int value)
{
    ((struct ::nk_edit_state*)NativePtr)->old = value;
}

int nuklear::NkEditState::Active::get()
{
    return NativePtr->active;
}

void nuklear::NkEditState::Active::set(int value)
{
    ((struct ::nk_edit_state*)NativePtr)->active = value;
}

int nuklear::NkEditState::Prev::get()
{
    return NativePtr->prev;
}

void nuklear::NkEditState::Prev::set(int value)
{
    ((struct ::nk_edit_state*)NativePtr)->prev = value;
}

int nuklear::NkEditState::Cursor::get()
{
    return NativePtr->cursor;
}

void nuklear::NkEditState::Cursor::set(int value)
{
    ((struct ::nk_edit_state*)NativePtr)->cursor = value;
}

int nuklear::NkEditState::SelStart::get()
{
    return NativePtr->sel_start;
}

void nuklear::NkEditState::SelStart::set(int value)
{
    ((struct ::nk_edit_state*)NativePtr)->sel_start = value;
}

int nuklear::NkEditState::SelEnd::get()
{
    return NativePtr->sel_end;
}

void nuklear::NkEditState::SelEnd::set(int value)
{
    ((struct ::nk_edit_state*)NativePtr)->sel_end = value;
}

::nuklear::NkScroll^ nuklear::NkEditState::Scrollbar::get()
{
    return (&NativePtr->scrollbar == nullptr) ? nullptr : gcnew ::nuklear::NkScroll((struct ::nk_scroll*)&NativePtr->scrollbar);
}

void nuklear::NkEditState::Scrollbar::set(::nuklear::NkScroll^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_edit_state*)NativePtr)->scrollbar = *(struct ::nk_scroll*)value->NativePtr;
}

unsigned char nuklear::NkEditState::Mode::get()
{
    return NativePtr->mode;
}

void nuklear::NkEditState::Mode::set(unsigned char value)
{
    ((struct ::nk_edit_state*)NativePtr)->mode = value;
}

unsigned char nuklear::NkEditState::SingleLine::get()
{
    return NativePtr->single_line;
}

void nuklear::NkEditState::SingleLine::set(unsigned char value)
{
    ((struct ::nk_edit_state*)NativePtr)->single_line = value;
}

nuklear::NkPropertyState::NkPropertyState(struct ::nk_property_state* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPropertyState^ nuklear::NkPropertyState::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPropertyState((struct ::nk_property_state*) native.ToPointer());
}

nuklear::NkPropertyState::NkPropertyState(struct ::nk_property_state* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPropertyState^ nuklear::NkPropertyState::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPropertyState((struct ::nk_property_state*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPropertyState::~NkPropertyState()
{
    delete NativePtr;
}

nuklear::NkPropertyState::!NkPropertyState()
{
    delete NativePtr;
}

nuklear::NkPropertyState::NkPropertyState()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_property_state();
}

nuklear::NkPropertyState::NkPropertyState(::nuklear::NkPropertyState^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_property_state*)_0->NativePtr;
    NativePtr = new struct ::nk_property_state(__arg0);
}

::System::IntPtr nuklear::NkPropertyState::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPropertyState::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_property_state*)object.ToPointer();
}

int nuklear::NkPropertyState::Active::get()
{
    return NativePtr->active;
}

void nuklear::NkPropertyState::Active::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->active = value;
}

int nuklear::NkPropertyState::Prev::get()
{
    return NativePtr->prev;
}

void nuklear::NkPropertyState::Prev::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->prev = value;
}

cli::array<char>^ nuklear::NkPropertyState::Buffer::get()
{
    cli::array<char>^ __array0 = nullptr;
    if (NativePtr->buffer != 0)
    {
        __array0 = gcnew cli::array<char>(64);
        for (int i = 0; i < 64; i++)
            __array0[i] = NativePtr->buffer[i];
    }
    return __array0;
}

void nuklear::NkPropertyState::Buffer::set(cli::array<char>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 64)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 64; i++)
            ((struct ::nk_property_state*)NativePtr)->buffer[i] = value[i];
    }
}

int nuklear::NkPropertyState::Length::get()
{
    return NativePtr->length;
}

void nuklear::NkPropertyState::Length::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->length = value;
}

int nuklear::NkPropertyState::Cursor::get()
{
    return NativePtr->cursor;
}

void nuklear::NkPropertyState::Cursor::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->cursor = value;
}

int nuklear::NkPropertyState::SelectStart::get()
{
    return NativePtr->select_start;
}

void nuklear::NkPropertyState::SelectStart::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->select_start = value;
}

int nuklear::NkPropertyState::SelectEnd::get()
{
    return NativePtr->select_end;
}

void nuklear::NkPropertyState::SelectEnd::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->select_end = value;
}

unsigned int nuklear::NkPropertyState::Name::get()
{
    return NativePtr->name;
}

void nuklear::NkPropertyState::Name::set(unsigned int value)
{
    ((struct ::nk_property_state*)NativePtr)->name = (::nk_hash)(::nk_uint)value;
}

unsigned int nuklear::NkPropertyState::Seq::get()
{
    return NativePtr->seq;
}

void nuklear::NkPropertyState::Seq::set(unsigned int value)
{
    ((struct ::nk_property_state*)NativePtr)->seq = value;
}

unsigned int nuklear::NkPropertyState::Old::get()
{
    return NativePtr->old;
}

void nuklear::NkPropertyState::Old::set(unsigned int value)
{
    ((struct ::nk_property_state*)NativePtr)->old = value;
}

int nuklear::NkPropertyState::State::get()
{
    return NativePtr->state;
}

void nuklear::NkPropertyState::State::set(int value)
{
    ((struct ::nk_property_state*)NativePtr)->state = value;
}

nuklear::NkWindow::NkWindow(struct ::nk_window* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkWindow^ nuklear::NkWindow::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkWindow((struct ::nk_window*) native.ToPointer());
}

nuklear::NkWindow::NkWindow(struct ::nk_window* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkWindow^ nuklear::NkWindow::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkWindow((struct ::nk_window*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkWindow::~NkWindow()
{
    delete NativePtr;
}

nuklear::NkWindow::!NkWindow()
{
    delete NativePtr;
}

nuklear::NkWindow::NkWindow()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_window();
}

nuklear::NkWindow::NkWindow(::nuklear::NkWindow^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_window*)_0->NativePtr;
    NativePtr = new struct ::nk_window(__arg0);
}

::System::IntPtr nuklear::NkWindow::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkWindow::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_window*)object.ToPointer();
}

unsigned int nuklear::NkWindow::Seq::get()
{
    return NativePtr->seq;
}

void nuklear::NkWindow::Seq::set(unsigned int value)
{
    ((struct ::nk_window*)NativePtr)->seq = value;
}

unsigned int nuklear::NkWindow::Name::get()
{
    return NativePtr->name;
}

void nuklear::NkWindow::Name::set(unsigned int value)
{
    ((struct ::nk_window*)NativePtr)->name = (::nk_hash)(::nk_uint)value;
}

cli::array<char>^ nuklear::NkWindow::NameString::get()
{
    cli::array<char>^ __array0 = nullptr;
    if (NativePtr->name_string != 0)
    {
        __array0 = gcnew cli::array<char>(64);
        for (int i = 0; i < 64; i++)
            __array0[i] = NativePtr->name_string[i];
    }
    return __array0;
}

void nuklear::NkWindow::NameString::set(cli::array<char>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 64)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 64; i++)
            ((struct ::nk_window*)NativePtr)->name_string[i] = value[i];
    }
}

unsigned int nuklear::NkWindow::Flags::get()
{
    return NativePtr->flags;
}

void nuklear::NkWindow::Flags::set(unsigned int value)
{
    ((struct ::nk_window*)NativePtr)->flags = (::nk_flags)(::nk_uint)value;
}

::nuklear::NkRect^ nuklear::NkWindow::Bounds::get()
{
    return (&NativePtr->bounds == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)&NativePtr->bounds);
}

void nuklear::NkWindow::Bounds::set(::nuklear::NkRect^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_window*)NativePtr)->bounds = *(struct ::nk_rect*)value->NativePtr;
}

::nuklear::NkScroll^ nuklear::NkWindow::Scrollbar::get()
{
    return (&NativePtr->scrollbar == nullptr) ? nullptr : gcnew ::nuklear::NkScroll((struct ::nk_scroll*)&NativePtr->scrollbar);
}

void nuklear::NkWindow::Scrollbar::set(::nuklear::NkScroll^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_window*)NativePtr)->scrollbar = *(struct ::nk_scroll*)value->NativePtr;
}

::nuklear::NkCommandBuffer^ nuklear::NkWindow::Buffer::get()
{
    return (&NativePtr->buffer == nullptr) ? nullptr : gcnew ::nuklear::NkCommandBuffer((struct ::nk_command_buffer*)&NativePtr->buffer);
}

void nuklear::NkWindow::Buffer::set(::nuklear::NkCommandBuffer^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_window*)NativePtr)->buffer = *(struct ::nk_command_buffer*)value->NativePtr;
}

::nuklear::NkPanel^ nuklear::NkWindow::Layout::get()
{
    return (NativePtr->layout == nullptr) ? nullptr : gcnew ::nuklear::NkPanel((struct ::nk_panel*)NativePtr->layout);
}

void nuklear::NkWindow::Layout::set(::nuklear::NkPanel^ value)
{
    ((struct ::nk_window*)NativePtr)->layout = (struct ::nk_panel*)value->NativePtr;
}

float nuklear::NkWindow::ScrollbarHidingTimer::get()
{
    return NativePtr->scrollbar_hiding_timer;
}

void nuklear::NkWindow::ScrollbarHidingTimer::set(float value)
{
    ((struct ::nk_window*)NativePtr)->scrollbar_hiding_timer = value;
}

::nuklear::NkPropertyState^ nuklear::NkWindow::Property::get()
{
    return (&NativePtr->property == nullptr) ? nullptr : gcnew ::nuklear::NkPropertyState((struct ::nk_property_state*)&NativePtr->property);
}

void nuklear::NkWindow::Property::set(::nuklear::NkPropertyState^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_window*)NativePtr)->property = *(struct ::nk_property_state*)value->NativePtr;
}

::nuklear::NkPopupState^ nuklear::NkWindow::Popup::get()
{
    return (&NativePtr->popup == nullptr) ? nullptr : gcnew ::nuklear::NkPopupState((struct ::nk_popup_state*)&NativePtr->popup);
}

void nuklear::NkWindow::Popup::set(::nuklear::NkPopupState^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_window*)NativePtr)->popup = *(struct ::nk_popup_state*)value->NativePtr;
}

::nuklear::NkEditState^ nuklear::NkWindow::Edit::get()
{
    return (&NativePtr->edit == nullptr) ? nullptr : gcnew ::nuklear::NkEditState((struct ::nk_edit_state*)&NativePtr->edit);
}

void nuklear::NkWindow::Edit::set(::nuklear::NkEditState^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_window*)NativePtr)->edit = *(struct ::nk_edit_state*)value->NativePtr;
}

unsigned int nuklear::NkWindow::Scrolled::get()
{
    return NativePtr->scrolled;
}

void nuklear::NkWindow::Scrolled::set(unsigned int value)
{
    ((struct ::nk_window*)NativePtr)->scrolled = value;
}

::nuklear::NkTable^ nuklear::NkWindow::Tables::get()
{
    return (NativePtr->tables == nullptr) ? nullptr : gcnew ::nuklear::NkTable((struct ::nk_table*)NativePtr->tables);
}

void nuklear::NkWindow::Tables::set(::nuklear::NkTable^ value)
{
    ((struct ::nk_window*)NativePtr)->tables = (struct ::nk_table*)value->NativePtr;
}

unsigned int nuklear::NkWindow::TableCount::get()
{
    return NativePtr->table_count;
}

void nuklear::NkWindow::TableCount::set(unsigned int value)
{
    ((struct ::nk_window*)NativePtr)->table_count = value;
}

::nuklear::NkWindow^ nuklear::NkWindow::Next::get()
{
    return (NativePtr->next == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->next);
}

void nuklear::NkWindow::Next::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_window*)NativePtr)->next = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkWindow^ nuklear::NkWindow::Prev::get()
{
    return (NativePtr->prev == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->prev);
}

void nuklear::NkWindow::Prev::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_window*)NativePtr)->prev = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkWindow^ nuklear::NkWindow::Parent::get()
{
    return (NativePtr->parent == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->parent);
}

void nuklear::NkWindow::Parent::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_window*)NativePtr)->parent = (struct ::nk_window*)value->NativePtr;
}

nuklear::NkConfigStackStyleItemElement::NkConfigStackStyleItemElement(struct ::nk_config_stack_style_item_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackStyleItemElement^ nuklear::NkConfigStackStyleItemElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackStyleItemElement((struct ::nk_config_stack_style_item_element*) native.ToPointer());
}

nuklear::NkConfigStackStyleItemElement::NkConfigStackStyleItemElement(struct ::nk_config_stack_style_item_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackStyleItemElement^ nuklear::NkConfigStackStyleItemElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackStyleItemElement((struct ::nk_config_stack_style_item_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackStyleItemElement::~NkConfigStackStyleItemElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackStyleItemElement::!NkConfigStackStyleItemElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackStyleItemElement::NkConfigStackStyleItemElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_style_item_element();
}

nuklear::NkConfigStackStyleItemElement::NkConfigStackStyleItemElement(::nuklear::NkConfigStackStyleItemElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_style_item_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_style_item_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackStyleItemElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackStyleItemElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_style_item_element*)object.ToPointer();
}

::nuklear::NkStyleItem^ nuklear::NkConfigStackStyleItemElement::Address::get()
{
    return (NativePtr->address == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)NativePtr->address);
}

void nuklear::NkConfigStackStyleItemElement::Address::set(::nuklear::NkStyleItem^ value)
{
    ((struct ::nk_config_stack_style_item_element*)NativePtr)->address = (struct ::nk_style_item*)value->NativePtr;
}

::nuklear::NkStyleItem^ nuklear::NkConfigStackStyleItemElement::OldValue::get()
{
    return (&NativePtr->old_value == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)&NativePtr->old_value);
}

void nuklear::NkConfigStackStyleItemElement::OldValue::set(::nuklear::NkStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_config_stack_style_item_element*)NativePtr)->old_value = *(struct ::nk_style_item*)value->NativePtr;
}

nuklear::NkConfigStackFloatElement::NkConfigStackFloatElement(struct ::nk_config_stack_float_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackFloatElement^ nuklear::NkConfigStackFloatElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackFloatElement((struct ::nk_config_stack_float_element*) native.ToPointer());
}

nuklear::NkConfigStackFloatElement::NkConfigStackFloatElement(struct ::nk_config_stack_float_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackFloatElement^ nuklear::NkConfigStackFloatElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackFloatElement((struct ::nk_config_stack_float_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackFloatElement::~NkConfigStackFloatElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackFloatElement::!NkConfigStackFloatElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackFloatElement::NkConfigStackFloatElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_float_element();
}

nuklear::NkConfigStackFloatElement::NkConfigStackFloatElement(::nuklear::NkConfigStackFloatElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_float_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_float_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackFloatElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackFloatElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_float_element*)object.ToPointer();
}

float* nuklear::NkConfigStackFloatElement::Address::get()
{
    return NativePtr->address;
}

void nuklear::NkConfigStackFloatElement::Address::set(float* value)
{
    ((struct ::nk_config_stack_float_element*)NativePtr)->address = (float*)value;
}

float nuklear::NkConfigStackFloatElement::OldValue::get()
{
    return NativePtr->old_value;
}

void nuklear::NkConfigStackFloatElement::OldValue::set(float value)
{
    ((struct ::nk_config_stack_float_element*)NativePtr)->old_value = value;
}

nuklear::NkConfigStackVec2Element::NkConfigStackVec2Element(struct ::nk_config_stack_vec2_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackVec2Element^ nuklear::NkConfigStackVec2Element::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackVec2Element((struct ::nk_config_stack_vec2_element*) native.ToPointer());
}

nuklear::NkConfigStackVec2Element::NkConfigStackVec2Element(struct ::nk_config_stack_vec2_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackVec2Element^ nuklear::NkConfigStackVec2Element::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackVec2Element((struct ::nk_config_stack_vec2_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackVec2Element::~NkConfigStackVec2Element()
{
    delete NativePtr;
}

nuklear::NkConfigStackVec2Element::!NkConfigStackVec2Element()
{
    delete NativePtr;
}

nuklear::NkConfigStackVec2Element::NkConfigStackVec2Element()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_vec2_element();
}

nuklear::NkConfigStackVec2Element::NkConfigStackVec2Element(::nuklear::NkConfigStackVec2Element^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_vec2_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_vec2_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackVec2Element::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackVec2Element::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_vec2_element*)object.ToPointer();
}

::nuklear::NkVec2^ nuklear::NkConfigStackVec2Element::Address::get()
{
    return (NativePtr->address == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)NativePtr->address);
}

void nuklear::NkConfigStackVec2Element::Address::set(::nuklear::NkVec2^ value)
{
    ((struct ::nk_config_stack_vec2_element*)NativePtr)->address = (struct ::nk_vec2*)value->NativePtr;
}

::nuklear::NkVec2^ nuklear::NkConfigStackVec2Element::OldValue::get()
{
    return (&NativePtr->old_value == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)&NativePtr->old_value);
}

void nuklear::NkConfigStackVec2Element::OldValue::set(::nuklear::NkVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_config_stack_vec2_element*)NativePtr)->old_value = *(struct ::nk_vec2*)value->NativePtr;
}

nuklear::NkConfigStackFlagsElement::NkConfigStackFlagsElement(struct ::nk_config_stack_flags_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackFlagsElement^ nuklear::NkConfigStackFlagsElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackFlagsElement((struct ::nk_config_stack_flags_element*) native.ToPointer());
}

nuklear::NkConfigStackFlagsElement::NkConfigStackFlagsElement(struct ::nk_config_stack_flags_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackFlagsElement^ nuklear::NkConfigStackFlagsElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackFlagsElement((struct ::nk_config_stack_flags_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackFlagsElement::~NkConfigStackFlagsElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackFlagsElement::!NkConfigStackFlagsElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackFlagsElement::NkConfigStackFlagsElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_flags_element();
}

nuklear::NkConfigStackFlagsElement::NkConfigStackFlagsElement(::nuklear::NkConfigStackFlagsElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_flags_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_flags_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackFlagsElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackFlagsElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_flags_element*)object.ToPointer();
}

unsigned int* nuklear::NkConfigStackFlagsElement::Address::get()
{
    return reinterpret_cast<unsigned int*>(NativePtr->address);
}

void nuklear::NkConfigStackFlagsElement::Address::set(unsigned int* value)
{
    ((struct ::nk_config_stack_flags_element*)NativePtr)->address = (nk_flags*)value;
}

unsigned int nuklear::NkConfigStackFlagsElement::OldValue::get()
{
    return NativePtr->old_value;
}

void nuklear::NkConfigStackFlagsElement::OldValue::set(unsigned int value)
{
    ((struct ::nk_config_stack_flags_element*)NativePtr)->old_value = (::nk_flags)(::nk_uint)value;
}

nuklear::NkConfigStackColorElement::NkConfigStackColorElement(struct ::nk_config_stack_color_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackColorElement^ nuklear::NkConfigStackColorElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackColorElement((struct ::nk_config_stack_color_element*) native.ToPointer());
}

nuklear::NkConfigStackColorElement::NkConfigStackColorElement(struct ::nk_config_stack_color_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackColorElement^ nuklear::NkConfigStackColorElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackColorElement((struct ::nk_config_stack_color_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackColorElement::~NkConfigStackColorElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackColorElement::!NkConfigStackColorElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackColorElement::NkConfigStackColorElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_color_element();
}

nuklear::NkConfigStackColorElement::NkConfigStackColorElement(::nuklear::NkConfigStackColorElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_color_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_color_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackColorElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackColorElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_color_element*)object.ToPointer();
}

::nuklear::NkColor^ nuklear::NkConfigStackColorElement::Address::get()
{
    return (NativePtr->address == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)NativePtr->address);
}

void nuklear::NkConfigStackColorElement::Address::set(::nuklear::NkColor^ value)
{
    ((struct ::nk_config_stack_color_element*)NativePtr)->address = (struct ::nk_color*)value->NativePtr;
}

::nuklear::NkColor^ nuklear::NkConfigStackColorElement::OldValue::get()
{
    return (&NativePtr->old_value == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)&NativePtr->old_value);
}

void nuklear::NkConfigStackColorElement::OldValue::set(::nuklear::NkColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_config_stack_color_element*)NativePtr)->old_value = *(struct ::nk_color*)value->NativePtr;
}

nuklear::NkConfigStackUserFontElement::NkConfigStackUserFontElement(struct ::nk_config_stack_user_font_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackUserFontElement^ nuklear::NkConfigStackUserFontElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackUserFontElement((struct ::nk_config_stack_user_font_element*) native.ToPointer());
}

nuklear::NkConfigStackUserFontElement::NkConfigStackUserFontElement(struct ::nk_config_stack_user_font_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackUserFontElement^ nuklear::NkConfigStackUserFontElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackUserFontElement((struct ::nk_config_stack_user_font_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackUserFontElement::~NkConfigStackUserFontElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackUserFontElement::!NkConfigStackUserFontElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackUserFontElement::NkConfigStackUserFontElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_user_font_element();
}

nuklear::NkConfigStackUserFontElement::NkConfigStackUserFontElement(::nuklear::NkConfigStackUserFontElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_user_font_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_user_font_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackUserFontElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackUserFontElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_user_font_element*)object.ToPointer();
}

::nuklear::NkUserFont^ nuklear::NkConfigStackUserFontElement::Address::get()
{
    return (NativePtr->address == nullptr) ? nullptr : gcnew ::nuklear::NkUserFont((struct ::nk_user_font*)NativePtr->address);
}

::nuklear::NkUserFont^ nuklear::NkConfigStackUserFontElement::OldValue::get()
{
    return (NativePtr->old_value == nullptr) ? nullptr : gcnew ::nuklear::NkUserFont((struct ::nk_user_font*)NativePtr->old_value);
}

nuklear::NkConfigStackButtonBehaviorElement::NkConfigStackButtonBehaviorElement(struct ::nk_config_stack_button_behavior_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackButtonBehaviorElement^ nuklear::NkConfigStackButtonBehaviorElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackButtonBehaviorElement((struct ::nk_config_stack_button_behavior_element*) native.ToPointer());
}

nuklear::NkConfigStackButtonBehaviorElement::NkConfigStackButtonBehaviorElement(struct ::nk_config_stack_button_behavior_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackButtonBehaviorElement^ nuklear::NkConfigStackButtonBehaviorElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackButtonBehaviorElement((struct ::nk_config_stack_button_behavior_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackButtonBehaviorElement::~NkConfigStackButtonBehaviorElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackButtonBehaviorElement::!NkConfigStackButtonBehaviorElement()
{
    delete NativePtr;
}

nuklear::NkConfigStackButtonBehaviorElement::NkConfigStackButtonBehaviorElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_button_behavior_element();
}

nuklear::NkConfigStackButtonBehaviorElement::NkConfigStackButtonBehaviorElement(::nuklear::NkConfigStackButtonBehaviorElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_button_behavior_element*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_button_behavior_element(__arg0);
}

::System::IntPtr nuklear::NkConfigStackButtonBehaviorElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackButtonBehaviorElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_button_behavior_element*)object.ToPointer();
}

::nuklear::NkButtonBehavior* nuklear::NkConfigStackButtonBehaviorElement::Address::get()
{
    return (::nuklear::NkButtonBehavior*)NativePtr->address;
}

void nuklear::NkConfigStackButtonBehaviorElement::Address::set(::nuklear::NkButtonBehavior* value)
{
    ((struct ::nk_config_stack_button_behavior_element*)NativePtr)->address = (enum ::nk_button_behavior*)*value;
}

::nuklear::NkButtonBehavior nuklear::NkConfigStackButtonBehaviorElement::OldValue::get()
{
    return (::nuklear::NkButtonBehavior)NativePtr->old_value;
}

void nuklear::NkConfigStackButtonBehaviorElement::OldValue::set(::nuklear::NkButtonBehavior value)
{
    ((struct ::nk_config_stack_button_behavior_element*)NativePtr)->old_value = (enum ::nk_button_behavior)value;
}

nuklear::NkConfigStackStyleItem::NkConfigStackStyleItem(struct ::nk_config_stack_style_item* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackStyleItem^ nuklear::NkConfigStackStyleItem::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackStyleItem((struct ::nk_config_stack_style_item*) native.ToPointer());
}

nuklear::NkConfigStackStyleItem::NkConfigStackStyleItem(struct ::nk_config_stack_style_item* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackStyleItem^ nuklear::NkConfigStackStyleItem::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackStyleItem((struct ::nk_config_stack_style_item*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackStyleItem::~NkConfigStackStyleItem()
{
    delete NativePtr;
}

nuklear::NkConfigStackStyleItem::!NkConfigStackStyleItem()
{
    delete NativePtr;
}

nuklear::NkConfigStackStyleItem::NkConfigStackStyleItem()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_style_item();
}

nuklear::NkConfigStackStyleItem::NkConfigStackStyleItem(::nuklear::NkConfigStackStyleItem^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_style_item*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_style_item(__arg0);
}

::System::IntPtr nuklear::NkConfigStackStyleItem::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackStyleItem::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_style_item*)object.ToPointer();
}

int nuklear::NkConfigStackStyleItem::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackStyleItem::Head::set(int value)
{
    ((struct ::nk_config_stack_style_item*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackStyleItemElement^>^ nuklear::NkConfigStackStyleItem::Elements::get()
{
    cli::array<::nuklear::NkConfigStackStyleItemElement^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackStyleItemElement^>(16);
        for (int i = 0; i < 16; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackStyleItemElement(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackStyleItem::Elements::set(cli::array<::nuklear::NkConfigStackStyleItemElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 16)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 16; i++)
            ((struct ::nk_config_stack_style_item*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigStackFloat::NkConfigStackFloat(struct ::nk_config_stack_float* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackFloat^ nuklear::NkConfigStackFloat::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackFloat((struct ::nk_config_stack_float*) native.ToPointer());
}

nuklear::NkConfigStackFloat::NkConfigStackFloat(struct ::nk_config_stack_float* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackFloat^ nuklear::NkConfigStackFloat::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackFloat((struct ::nk_config_stack_float*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackFloat::~NkConfigStackFloat()
{
    delete NativePtr;
}

nuklear::NkConfigStackFloat::!NkConfigStackFloat()
{
    delete NativePtr;
}

nuklear::NkConfigStackFloat::NkConfigStackFloat()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_float();
}

nuklear::NkConfigStackFloat::NkConfigStackFloat(::nuklear::NkConfigStackFloat^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_float*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_float(__arg0);
}

::System::IntPtr nuklear::NkConfigStackFloat::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackFloat::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_float*)object.ToPointer();
}

int nuklear::NkConfigStackFloat::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackFloat::Head::set(int value)
{
    ((struct ::nk_config_stack_float*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackFloatElement^>^ nuklear::NkConfigStackFloat::Elements::get()
{
    cli::array<::nuklear::NkConfigStackFloatElement^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackFloatElement^>(32);
        for (int i = 0; i < 32; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackFloatElement(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackFloat::Elements::set(cli::array<::nuklear::NkConfigStackFloatElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 32)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 32; i++)
            ((struct ::nk_config_stack_float*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigStackVec2::NkConfigStackVec2(struct ::nk_config_stack_vec2* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackVec2^ nuklear::NkConfigStackVec2::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackVec2((struct ::nk_config_stack_vec2*) native.ToPointer());
}

nuklear::NkConfigStackVec2::NkConfigStackVec2(struct ::nk_config_stack_vec2* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackVec2^ nuklear::NkConfigStackVec2::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackVec2((struct ::nk_config_stack_vec2*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackVec2::~NkConfigStackVec2()
{
    delete NativePtr;
}

nuklear::NkConfigStackVec2::!NkConfigStackVec2()
{
    delete NativePtr;
}

nuklear::NkConfigStackVec2::NkConfigStackVec2()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_vec2();
}

nuklear::NkConfigStackVec2::NkConfigStackVec2(::nuklear::NkConfigStackVec2^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_vec2*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_vec2(__arg0);
}

::System::IntPtr nuklear::NkConfigStackVec2::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackVec2::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_vec2*)object.ToPointer();
}

int nuklear::NkConfigStackVec2::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackVec2::Head::set(int value)
{
    ((struct ::nk_config_stack_vec2*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackVec2Element^>^ nuklear::NkConfigStackVec2::Elements::get()
{
    cli::array<::nuklear::NkConfigStackVec2Element^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackVec2Element^>(16);
        for (int i = 0; i < 16; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackVec2Element(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackVec2::Elements::set(cli::array<::nuklear::NkConfigStackVec2Element^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 16)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 16; i++)
            ((struct ::nk_config_stack_vec2*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigStackFlags::NkConfigStackFlags(struct ::nk_config_stack_flags* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackFlags^ nuklear::NkConfigStackFlags::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackFlags((struct ::nk_config_stack_flags*) native.ToPointer());
}

nuklear::NkConfigStackFlags::NkConfigStackFlags(struct ::nk_config_stack_flags* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackFlags^ nuklear::NkConfigStackFlags::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackFlags((struct ::nk_config_stack_flags*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackFlags::~NkConfigStackFlags()
{
    delete NativePtr;
}

nuklear::NkConfigStackFlags::!NkConfigStackFlags()
{
    delete NativePtr;
}

nuklear::NkConfigStackFlags::NkConfigStackFlags()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_flags();
}

nuklear::NkConfigStackFlags::NkConfigStackFlags(::nuklear::NkConfigStackFlags^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_flags*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_flags(__arg0);
}

::System::IntPtr nuklear::NkConfigStackFlags::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackFlags::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_flags*)object.ToPointer();
}

int nuklear::NkConfigStackFlags::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackFlags::Head::set(int value)
{
    ((struct ::nk_config_stack_flags*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackFlagsElement^>^ nuklear::NkConfigStackFlags::Elements::get()
{
    cli::array<::nuklear::NkConfigStackFlagsElement^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackFlagsElement^>(32);
        for (int i = 0; i < 32; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackFlagsElement(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackFlags::Elements::set(cli::array<::nuklear::NkConfigStackFlagsElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 32)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 32; i++)
            ((struct ::nk_config_stack_flags*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigStackColor::NkConfigStackColor(struct ::nk_config_stack_color* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackColor^ nuklear::NkConfigStackColor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackColor((struct ::nk_config_stack_color*) native.ToPointer());
}

nuklear::NkConfigStackColor::NkConfigStackColor(struct ::nk_config_stack_color* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackColor^ nuklear::NkConfigStackColor::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackColor((struct ::nk_config_stack_color*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackColor::~NkConfigStackColor()
{
    delete NativePtr;
}

nuklear::NkConfigStackColor::!NkConfigStackColor()
{
    delete NativePtr;
}

nuklear::NkConfigStackColor::NkConfigStackColor()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_color();
}

nuklear::NkConfigStackColor::NkConfigStackColor(::nuklear::NkConfigStackColor^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_color*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_color(__arg0);
}

::System::IntPtr nuklear::NkConfigStackColor::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackColor::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_color*)object.ToPointer();
}

int nuklear::NkConfigStackColor::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackColor::Head::set(int value)
{
    ((struct ::nk_config_stack_color*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackColorElement^>^ nuklear::NkConfigStackColor::Elements::get()
{
    cli::array<::nuklear::NkConfigStackColorElement^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackColorElement^>(32);
        for (int i = 0; i < 32; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackColorElement(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackColor::Elements::set(cli::array<::nuklear::NkConfigStackColorElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 32)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 32; i++)
            ((struct ::nk_config_stack_color*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigStackUserFont::NkConfigStackUserFont(struct ::nk_config_stack_user_font* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackUserFont^ nuklear::NkConfigStackUserFont::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackUserFont((struct ::nk_config_stack_user_font*) native.ToPointer());
}

nuklear::NkConfigStackUserFont::NkConfigStackUserFont(struct ::nk_config_stack_user_font* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackUserFont^ nuklear::NkConfigStackUserFont::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackUserFont((struct ::nk_config_stack_user_font*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackUserFont::~NkConfigStackUserFont()
{
    delete NativePtr;
}

nuklear::NkConfigStackUserFont::!NkConfigStackUserFont()
{
    delete NativePtr;
}

nuklear::NkConfigStackUserFont::NkConfigStackUserFont()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_user_font();
}

nuklear::NkConfigStackUserFont::NkConfigStackUserFont(::nuklear::NkConfigStackUserFont^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_user_font*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_user_font(__arg0);
}

::System::IntPtr nuklear::NkConfigStackUserFont::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackUserFont::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_user_font*)object.ToPointer();
}

int nuklear::NkConfigStackUserFont::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackUserFont::Head::set(int value)
{
    ((struct ::nk_config_stack_user_font*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackUserFontElement^>^ nuklear::NkConfigStackUserFont::Elements::get()
{
    cli::array<::nuklear::NkConfigStackUserFontElement^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackUserFontElement^>(8);
        for (int i = 0; i < 8; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackUserFontElement(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackUserFont::Elements::set(cli::array<::nuklear::NkConfigStackUserFontElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 8)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 8; i++)
            ((struct ::nk_config_stack_user_font*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigStackButtonBehavior::NkConfigStackButtonBehavior(struct ::nk_config_stack_button_behavior* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigStackButtonBehavior^ nuklear::NkConfigStackButtonBehavior::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigStackButtonBehavior((struct ::nk_config_stack_button_behavior*) native.ToPointer());
}

nuklear::NkConfigStackButtonBehavior::NkConfigStackButtonBehavior(struct ::nk_config_stack_button_behavior* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigStackButtonBehavior^ nuklear::NkConfigStackButtonBehavior::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigStackButtonBehavior((struct ::nk_config_stack_button_behavior*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigStackButtonBehavior::~NkConfigStackButtonBehavior()
{
    delete NativePtr;
}

nuklear::NkConfigStackButtonBehavior::!NkConfigStackButtonBehavior()
{
    delete NativePtr;
}

nuklear::NkConfigStackButtonBehavior::NkConfigStackButtonBehavior()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_config_stack_button_behavior();
}

nuklear::NkConfigStackButtonBehavior::NkConfigStackButtonBehavior(::nuklear::NkConfigStackButtonBehavior^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_config_stack_button_behavior*)_0->NativePtr;
    NativePtr = new struct ::nk_config_stack_button_behavior(__arg0);
}

::System::IntPtr nuklear::NkConfigStackButtonBehavior::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigStackButtonBehavior::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_config_stack_button_behavior*)object.ToPointer();
}

int nuklear::NkConfigStackButtonBehavior::Head::get()
{
    return NativePtr->head;
}

void nuklear::NkConfigStackButtonBehavior::Head::set(int value)
{
    ((struct ::nk_config_stack_button_behavior*)NativePtr)->head = value;
}

cli::array<::nuklear::NkConfigStackButtonBehaviorElement^>^ nuklear::NkConfigStackButtonBehavior::Elements::get()
{
    cli::array<::nuklear::NkConfigStackButtonBehaviorElement^>^ __array0 = nullptr;
    if (NativePtr->elements != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkConfigStackButtonBehaviorElement^>(8);
        for (int i = 0; i < 8; i++)
            __array0[i] = gcnew ::nuklear::NkConfigStackButtonBehaviorElement(&NativePtr->elements[i]);
    }
    return __array0;
}

void nuklear::NkConfigStackButtonBehavior::Elements::set(cli::array<::nuklear::NkConfigStackButtonBehaviorElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 8)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 8; i++)
            ((struct ::nk_config_stack_button_behavior*)NativePtr)->elements[i] = *value[i]->NativePtr;
    }
}

nuklear::NkConfigurationStacks::NkConfigurationStacks(struct ::nk_configuration_stacks* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkConfigurationStacks^ nuklear::NkConfigurationStacks::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkConfigurationStacks((struct ::nk_configuration_stacks*) native.ToPointer());
}

nuklear::NkConfigurationStacks::NkConfigurationStacks(struct ::nk_configuration_stacks* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkConfigurationStacks^ nuklear::NkConfigurationStacks::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkConfigurationStacks((struct ::nk_configuration_stacks*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkConfigurationStacks::~NkConfigurationStacks()
{
    delete NativePtr;
}

nuklear::NkConfigurationStacks::!NkConfigurationStacks()
{
    delete NativePtr;
}

nuklear::NkConfigurationStacks::NkConfigurationStacks()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_configuration_stacks();
}

nuklear::NkConfigurationStacks::NkConfigurationStacks(::nuklear::NkConfigurationStacks^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_configuration_stacks*)_0->NativePtr;
    NativePtr = new struct ::nk_configuration_stacks(__arg0);
}

::System::IntPtr nuklear::NkConfigurationStacks::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkConfigurationStacks::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_configuration_stacks*)object.ToPointer();
}

::nuklear::NkConfigStackStyleItem^ nuklear::NkConfigurationStacks::StyleItems::get()
{
    return (&NativePtr->style_items == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackStyleItem((struct ::nk_config_stack_style_item*)&NativePtr->style_items);
}

void nuklear::NkConfigurationStacks::StyleItems::set(::nuklear::NkConfigStackStyleItem^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->style_items = *(struct ::nk_config_stack_style_item*)value->NativePtr;
}

::nuklear::NkConfigStackFloat^ nuklear::NkConfigurationStacks::Floats::get()
{
    return (&NativePtr->floats == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackFloat((struct ::nk_config_stack_float*)&NativePtr->floats);
}

void nuklear::NkConfigurationStacks::Floats::set(::nuklear::NkConfigStackFloat^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->floats = *(struct ::nk_config_stack_float*)value->NativePtr;
}

::nuklear::NkConfigStackVec2^ nuklear::NkConfigurationStacks::Vectors::get()
{
    return (&NativePtr->vectors == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackVec2((struct ::nk_config_stack_vec2*)&NativePtr->vectors);
}

void nuklear::NkConfigurationStacks::Vectors::set(::nuklear::NkConfigStackVec2^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->vectors = *(struct ::nk_config_stack_vec2*)value->NativePtr;
}

::nuklear::NkConfigStackFlags^ nuklear::NkConfigurationStacks::Flags::get()
{
    return (&NativePtr->flags == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackFlags((struct ::nk_config_stack_flags*)&NativePtr->flags);
}

void nuklear::NkConfigurationStacks::Flags::set(::nuklear::NkConfigStackFlags^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->flags = *(struct ::nk_config_stack_flags*)value->NativePtr;
}

::nuklear::NkConfigStackColor^ nuklear::NkConfigurationStacks::Colors::get()
{
    return (&NativePtr->colors == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackColor((struct ::nk_config_stack_color*)&NativePtr->colors);
}

void nuklear::NkConfigurationStacks::Colors::set(::nuklear::NkConfigStackColor^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->colors = *(struct ::nk_config_stack_color*)value->NativePtr;
}

::nuklear::NkConfigStackUserFont^ nuklear::NkConfigurationStacks::Fonts::get()
{
    return (&NativePtr->fonts == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackUserFont((struct ::nk_config_stack_user_font*)&NativePtr->fonts);
}

void nuklear::NkConfigurationStacks::Fonts::set(::nuklear::NkConfigStackUserFont^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->fonts = *(struct ::nk_config_stack_user_font*)value->NativePtr;
}

::nuklear::NkConfigStackButtonBehavior^ nuklear::NkConfigurationStacks::ButtonBehaviors::get()
{
    return (&NativePtr->button_behaviors == nullptr) ? nullptr : gcnew ::nuklear::NkConfigStackButtonBehavior((struct ::nk_config_stack_button_behavior*)&NativePtr->button_behaviors);
}

void nuklear::NkConfigurationStacks::ButtonBehaviors::set(::nuklear::NkConfigStackButtonBehavior^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_configuration_stacks*)NativePtr)->button_behaviors = *(struct ::nk_config_stack_button_behavior*)value->NativePtr;
}

nuklear::NkTable::NkTable(struct ::nk_table* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkTable^ nuklear::NkTable::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkTable((struct ::nk_table*) native.ToPointer());
}

nuklear::NkTable::NkTable(struct ::nk_table* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkTable^ nuklear::NkTable::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkTable((struct ::nk_table*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkTable::~NkTable()
{
    delete NativePtr;
}

nuklear::NkTable::!NkTable()
{
    delete NativePtr;
}

nuklear::NkTable::NkTable()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_table();
}

nuklear::NkTable::NkTable(::nuklear::NkTable^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_table*)_0->NativePtr;
    NativePtr = new struct ::nk_table(__arg0);
}

::System::IntPtr nuklear::NkTable::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkTable::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_table*)object.ToPointer();
}

unsigned int nuklear::NkTable::Seq::get()
{
    return NativePtr->seq;
}

void nuklear::NkTable::Seq::set(unsigned int value)
{
    ((struct ::nk_table*)NativePtr)->seq = value;
}

unsigned int nuklear::NkTable::Size::get()
{
    return NativePtr->size;
}

void nuklear::NkTable::Size::set(unsigned int value)
{
    ((struct ::nk_table*)NativePtr)->size = value;
}

cli::array<unsigned int>^ nuklear::NkTable::Keys::get()
{
    cli::array<unsigned int>^ __array0 = nullptr;
    if (NativePtr->keys != 0)
    {
        __array0 = gcnew cli::array<unsigned int>(59);
        for (int i = 0; i < 59; i++)
            __array0[i] = NativePtr->keys[i];
    }
    return __array0;
}

void nuklear::NkTable::Keys::set(cli::array<unsigned int>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 59)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 59; i++)
            ((struct ::nk_table*)NativePtr)->keys[i] = value[i];
    }
}

cli::array<unsigned int>^ nuklear::NkTable::Values::get()
{
    cli::array<unsigned int>^ __array0 = nullptr;
    if (NativePtr->values != 0)
    {
        __array0 = gcnew cli::array<unsigned int>(59);
        for (int i = 0; i < 59; i++)
            __array0[i] = NativePtr->values[i];
    }
    return __array0;
}

void nuklear::NkTable::Values::set(cli::array<unsigned int>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 59)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 59; i++)
            ((struct ::nk_table*)NativePtr)->values[i] = value[i];
    }
}

::nuklear::NkTable^ nuklear::NkTable::Next::get()
{
    return (NativePtr->next == nullptr) ? nullptr : gcnew ::nuklear::NkTable((struct ::nk_table*)NativePtr->next);
}

void nuklear::NkTable::Next::set(::nuklear::NkTable^ value)
{
    ((struct ::nk_table*)NativePtr)->next = (struct ::nk_table*)value->NativePtr;
}

::nuklear::NkTable^ nuklear::NkTable::Prev::get()
{
    return (NativePtr->prev == nullptr) ? nullptr : gcnew ::nuklear::NkTable((struct ::nk_table*)NativePtr->prev);
}

void nuklear::NkTable::Prev::set(::nuklear::NkTable^ value)
{
    ((struct ::nk_table*)NativePtr)->prev = (struct ::nk_table*)value->NativePtr;
}

nuklear::NkPageData::NkPageData(::nk_page_data* native)
{
    __tbl = (&native->tbl == nullptr) ? nullptr : gcnew ::nuklear::NkTable((struct ::nk_table*)&native->tbl);
    __pan = (&native->pan == nullptr) ? nullptr : gcnew ::nuklear::NkPanel((struct ::nk_panel*)&native->pan);
    __win = (&native->win == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)&native->win);
}

nuklear::NkPageData^ nuklear::NkPageData::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPageData((::nk_page_data*) native.ToPointer());
}

nuklear::NkPageData::NkPageData(::nk_page_data* native, bool ownNativeInstance)
{
    __tbl = (&native->tbl == nullptr) ? nullptr : gcnew ::nuklear::NkTable((struct ::nk_table*)&native->tbl);
    __pan = (&native->pan == nullptr) ? nullptr : gcnew ::nuklear::NkPanel((struct ::nk_panel*)&native->pan);
    __win = (&native->win == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)&native->win);
}

nuklear::NkPageData^ nuklear::NkPageData::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPageData((::nk_page_data*) native.ToPointer(), __ownsNativeInstance);
}

::nuklear::NkTable^ nuklear::NkPageData::Tbl::get()
{
    return __tbl;
}

void nuklear::NkPageData::Tbl::set(::nuklear::NkTable^ value)
{
    __tbl = value;
}

::nuklear::NkPanel^ nuklear::NkPageData::Pan::get()
{
    return __pan;
}

void nuklear::NkPageData::Pan::set(::nuklear::NkPanel^ value)
{
    __pan = value;
}

::nuklear::NkWindow^ nuklear::NkPageData::Win::get()
{
    return __win;
}

void nuklear::NkPageData::Win::set(::nuklear::NkWindow^ value)
{
    __win = value;
}

nuklear::NkPageElement::NkPageElement(struct ::nk_page_element* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPageElement^ nuklear::NkPageElement::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPageElement((struct ::nk_page_element*) native.ToPointer());
}

nuklear::NkPageElement::NkPageElement(struct ::nk_page_element* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPageElement^ nuklear::NkPageElement::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPageElement((struct ::nk_page_element*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPageElement::~NkPageElement()
{
    delete NativePtr;
}

nuklear::NkPageElement::!NkPageElement()
{
    delete NativePtr;
}

nuklear::NkPageElement::NkPageElement()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_page_element();
}

nuklear::NkPageElement::NkPageElement(::nuklear::NkPageElement^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_page_element*)_0->NativePtr;
    NativePtr = new struct ::nk_page_element(__arg0);
}

::System::IntPtr nuklear::NkPageElement::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPageElement::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_page_element*)object.ToPointer();
}

::nuklear::NkPageData nuklear::NkPageElement::Data::get()
{
    return ::nuklear::NkPageData((::nk_page_data*)&NativePtr->data);
}

void nuklear::NkPageElement::Data::set(::nuklear::NkPageData value)
{
    auto _marshal0 = ::nk_page_data();
    if (ReferenceEquals(value.Tbl, nullptr))
        throw gcnew ::System::ArgumentNullException("value.Tbl", "Cannot be null because it is passed by value.");
    _marshal0.tbl = *(struct ::nk_table*)value.Tbl->NativePtr;
    if (ReferenceEquals(value.Pan, nullptr))
        throw gcnew ::System::ArgumentNullException("value.Pan", "Cannot be null because it is passed by value.");
    _marshal0.pan = *(struct ::nk_panel*)value.Pan->NativePtr;
    if (ReferenceEquals(value.Win, nullptr))
        throw gcnew ::System::ArgumentNullException("value.Win", "Cannot be null because it is passed by value.");
    _marshal0.win = *(struct ::nk_window*)value.Win->NativePtr;
    ((struct ::nk_page_element*)NativePtr)->data = _marshal0;
}

::nuklear::NkPageElement^ nuklear::NkPageElement::Next::get()
{
    return (NativePtr->next == nullptr) ? nullptr : gcnew ::nuklear::NkPageElement((struct ::nk_page_element*)NativePtr->next);
}

void nuklear::NkPageElement::Next::set(::nuklear::NkPageElement^ value)
{
    ((struct ::nk_page_element*)NativePtr)->next = (struct ::nk_page_element*)value->NativePtr;
}

::nuklear::NkPageElement^ nuklear::NkPageElement::Prev::get()
{
    return (NativePtr->prev == nullptr) ? nullptr : gcnew ::nuklear::NkPageElement((struct ::nk_page_element*)NativePtr->prev);
}

void nuklear::NkPageElement::Prev::set(::nuklear::NkPageElement^ value)
{
    ((struct ::nk_page_element*)NativePtr)->prev = (struct ::nk_page_element*)value->NativePtr;
}

nuklear::NkPage::NkPage(struct ::nk_page* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPage^ nuklear::NkPage::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPage((struct ::nk_page*) native.ToPointer());
}

nuklear::NkPage::NkPage(struct ::nk_page* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPage^ nuklear::NkPage::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPage((struct ::nk_page*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPage::~NkPage()
{
    delete NativePtr;
}

nuklear::NkPage::!NkPage()
{
    delete NativePtr;
}

nuklear::NkPage::NkPage()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_page();
}

nuklear::NkPage::NkPage(::nuklear::NkPage^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_page*)_0->NativePtr;
    NativePtr = new struct ::nk_page(__arg0);
}

::System::IntPtr nuklear::NkPage::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPage::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_page*)object.ToPointer();
}

unsigned int nuklear::NkPage::Size::get()
{
    return NativePtr->size;
}

void nuklear::NkPage::Size::set(unsigned int value)
{
    ((struct ::nk_page*)NativePtr)->size = value;
}

::nuklear::NkPage^ nuklear::NkPage::Next::get()
{
    return (NativePtr->next == nullptr) ? nullptr : gcnew ::nuklear::NkPage((struct ::nk_page*)NativePtr->next);
}

void nuklear::NkPage::Next::set(::nuklear::NkPage^ value)
{
    ((struct ::nk_page*)NativePtr)->next = (struct ::nk_page*)value->NativePtr;
}

cli::array<::nuklear::NkPageElement^>^ nuklear::NkPage::Win::get()
{
    cli::array<::nuklear::NkPageElement^>^ __array0 = nullptr;
    if (NativePtr->win != 0)
    {
        __array0 = gcnew cli::array<::nuklear::NkPageElement^>(1);
        for (int i = 0; i < 1; i++)
            __array0[i] = gcnew ::nuklear::NkPageElement(&NativePtr->win[i]);
    }
    return __array0;
}

void nuklear::NkPage::Win::set(cli::array<::nuklear::NkPageElement^>^ value)
{
    if (value != nullptr)
    {
        if (value->Length != 1)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 1; i++)
            ((struct ::nk_page*)NativePtr)->win[i] = *value[i]->NativePtr;
    }
}

nuklear::NkPool::NkPool(struct ::nk_pool* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkPool^ nuklear::NkPool::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkPool((struct ::nk_pool*) native.ToPointer());
}

nuklear::NkPool::NkPool(struct ::nk_pool* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkPool^ nuklear::NkPool::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkPool((struct ::nk_pool*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkPool::~NkPool()
{
    delete NativePtr;
}

nuklear::NkPool::!NkPool()
{
    delete NativePtr;
}

nuklear::NkPool::NkPool()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_pool();
}

nuklear::NkPool::NkPool(::nuklear::NkPool^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_pool*)_0->NativePtr;
    NativePtr = new struct ::nk_pool(__arg0);
}

::System::IntPtr nuklear::NkPool::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkPool::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_pool*)object.ToPointer();
}

::nuklear::NkAllocator^ nuklear::NkPool::Alloc::get()
{
    return (&NativePtr->alloc == nullptr) ? nullptr : gcnew ::nuklear::NkAllocator((struct ::nk_allocator*)&NativePtr->alloc);
}

void nuklear::NkPool::Alloc::set(::nuklear::NkAllocator^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_pool*)NativePtr)->alloc = *(struct ::nk_allocator*)value->NativePtr;
}

::nuklear::NkAllocationType nuklear::NkPool::Type::get()
{
    return (::nuklear::NkAllocationType)NativePtr->type;
}

void nuklear::NkPool::Type::set(::nuklear::NkAllocationType value)
{
    ((struct ::nk_pool*)NativePtr)->type = (enum ::nk_allocation_type)value;
}

unsigned int nuklear::NkPool::PageCount::get()
{
    return NativePtr->page_count;
}

void nuklear::NkPool::PageCount::set(unsigned int value)
{
    ((struct ::nk_pool*)NativePtr)->page_count = value;
}

::nuklear::NkPage^ nuklear::NkPool::Pages::get()
{
    return (NativePtr->pages == nullptr) ? nullptr : gcnew ::nuklear::NkPage((struct ::nk_page*)NativePtr->pages);
}

void nuklear::NkPool::Pages::set(::nuklear::NkPage^ value)
{
    ((struct ::nk_pool*)NativePtr)->pages = (struct ::nk_page*)value->NativePtr;
}

::nuklear::NkPageElement^ nuklear::NkPool::Freelist::get()
{
    return (NativePtr->freelist == nullptr) ? nullptr : gcnew ::nuklear::NkPageElement((struct ::nk_page_element*)NativePtr->freelist);
}

void nuklear::NkPool::Freelist::set(::nuklear::NkPageElement^ value)
{
    ((struct ::nk_pool*)NativePtr)->freelist = (struct ::nk_page_element*)value->NativePtr;
}

unsigned int nuklear::NkPool::Capacity::get()
{
    return NativePtr->capacity;
}

void nuklear::NkPool::Capacity::set(unsigned int value)
{
    ((struct ::nk_pool*)NativePtr)->capacity = value;
}

unsigned long long nuklear::NkPool::Size::get()
{
    return NativePtr->size;
}

void nuklear::NkPool::Size::set(unsigned long long value)
{
    ((struct ::nk_pool*)NativePtr)->size = (::nk_size)value;
}

unsigned long long nuklear::NkPool::Cap::get()
{
    return NativePtr->cap;
}

void nuklear::NkPool::Cap::set(unsigned long long value)
{
    ((struct ::nk_pool*)NativePtr)->cap = (::nk_size)value;
}

nuklear::NkContext::NkContext(struct ::nk_context* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

nuklear::NkContext^ nuklear::NkContext::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::nuklear::NkContext((struct ::nk_context*) native.ToPointer());
}

nuklear::NkContext::NkContext(struct ::nk_context* native, bool ownNativeInstance)
    : __ownsNativeInstance(ownNativeInstance)
{
    NativePtr = native;
}

nuklear::NkContext^ nuklear::NkContext::__CreateInstance(::System::IntPtr native, bool __ownsNativeInstance)
{
    return gcnew ::nuklear::NkContext((struct ::nk_context*) native.ToPointer(), __ownsNativeInstance);
}

nuklear::NkContext::~NkContext()
{
    delete NativePtr;
}

nuklear::NkContext::!NkContext()
{
    delete NativePtr;
}

nuklear::NkContext::NkContext()
{
    __ownsNativeInstance = true;
    NativePtr = new struct ::nk_context();
}

nuklear::NkContext::NkContext(::nuklear::NkContext^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(struct ::nk_context*)_0->NativePtr;
    NativePtr = new struct ::nk_context(__arg0);
}

::System::IntPtr nuklear::NkContext::__Instance::get()
{
    return ::System::IntPtr(NativePtr);
}

void nuklear::NkContext::__Instance::set(::System::IntPtr object)
{
    NativePtr = (struct ::nk_context*)object.ToPointer();
}

::nuklear::NkInput^ nuklear::NkContext::Input::get()
{
    return (&NativePtr->input == nullptr) ? nullptr : gcnew ::nuklear::NkInput((struct ::nk_input*)&NativePtr->input);
}

void nuklear::NkContext::Input::set(::nuklear::NkInput^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->input = *(struct ::nk_input*)value->NativePtr;
}

::nuklear::NkStyle^ nuklear::NkContext::Style::get()
{
    return (&NativePtr->style == nullptr) ? nullptr : gcnew ::nuklear::NkStyle((struct ::nk_style*)&NativePtr->style);
}

void nuklear::NkContext::Style::set(::nuklear::NkStyle^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->style = *(struct ::nk_style*)value->NativePtr;
}

::nuklear::NkBuffer^ nuklear::NkContext::Memory::get()
{
    return (&NativePtr->memory == nullptr) ? nullptr : gcnew ::nuklear::NkBuffer((struct ::nk_buffer*)&NativePtr->memory);
}

void nuklear::NkContext::Memory::set(::nuklear::NkBuffer^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->memory = *(struct ::nk_buffer*)value->NativePtr;
}

::nuklear::NkClipboard^ nuklear::NkContext::Clip::get()
{
    return (&NativePtr->clip == nullptr) ? nullptr : gcnew ::nuklear::NkClipboard((struct ::nk_clipboard*)&NativePtr->clip);
}

void nuklear::NkContext::Clip::set(::nuklear::NkClipboard^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->clip = *(struct ::nk_clipboard*)value->NativePtr;
}

unsigned int nuklear::NkContext::LastWidgetState::get()
{
    return NativePtr->last_widget_state;
}

void nuklear::NkContext::LastWidgetState::set(unsigned int value)
{
    ((struct ::nk_context*)NativePtr)->last_widget_state = (::nk_flags)(::nk_uint)value;
}

::nuklear::NkButtonBehavior nuklear::NkContext::ButtonBehavior::get()
{
    return (::nuklear::NkButtonBehavior)NativePtr->button_behavior;
}

void nuklear::NkContext::ButtonBehavior::set(::nuklear::NkButtonBehavior value)
{
    ((struct ::nk_context*)NativePtr)->button_behavior = (enum ::nk_button_behavior)value;
}

::nuklear::NkConfigurationStacks^ nuklear::NkContext::Stacks::get()
{
    return (&NativePtr->stacks == nullptr) ? nullptr : gcnew ::nuklear::NkConfigurationStacks((struct ::nk_configuration_stacks*)&NativePtr->stacks);
}

void nuklear::NkContext::Stacks::set(::nuklear::NkConfigurationStacks^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->stacks = *(struct ::nk_configuration_stacks*)value->NativePtr;
}

float nuklear::NkContext::DeltaTimeSeconds::get()
{
    return NativePtr->delta_time_seconds;
}

void nuklear::NkContext::DeltaTimeSeconds::set(float value)
{
    ((struct ::nk_context*)NativePtr)->delta_time_seconds = value;
}

::nuklear::NkTextEdit^ nuklear::NkContext::TextEdit::get()
{
    return (&NativePtr->text_edit == nullptr) ? nullptr : gcnew ::nuklear::NkTextEdit((struct ::nk_text_edit*)&NativePtr->text_edit);
}

void nuklear::NkContext::TextEdit::set(::nuklear::NkTextEdit^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->text_edit = *(struct ::nk_text_edit*)value->NativePtr;
}

::nuklear::NkCommandBuffer^ nuklear::NkContext::Overlay::get()
{
    return (&NativePtr->overlay == nullptr) ? nullptr : gcnew ::nuklear::NkCommandBuffer((struct ::nk_command_buffer*)&NativePtr->overlay);
}

void nuklear::NkContext::Overlay::set(::nuklear::NkCommandBuffer^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->overlay = *(struct ::nk_command_buffer*)value->NativePtr;
}

int nuklear::NkContext::Build::get()
{
    return NativePtr->build;
}

void nuklear::NkContext::Build::set(int value)
{
    ((struct ::nk_context*)NativePtr)->build = value;
}

int nuklear::NkContext::UsePool::get()
{
    return NativePtr->use_pool;
}

void nuklear::NkContext::UsePool::set(int value)
{
    ((struct ::nk_context*)NativePtr)->use_pool = value;
}

::nuklear::NkPool^ nuklear::NkContext::Pool::get()
{
    return (&NativePtr->pool == nullptr) ? nullptr : gcnew ::nuklear::NkPool((struct ::nk_pool*)&NativePtr->pool);
}

void nuklear::NkContext::Pool::set(::nuklear::NkPool^ value)
{
    if (ReferenceEquals(value, nullptr))
        throw gcnew ::System::ArgumentNullException("value", "Cannot be null because it is passed by value.");
    ((struct ::nk_context*)NativePtr)->pool = *(struct ::nk_pool*)value->NativePtr;
}

::nuklear::NkWindow^ nuklear::NkContext::Begin::get()
{
    return (NativePtr->begin == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->begin);
}

void nuklear::NkContext::Begin::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_context*)NativePtr)->begin = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkWindow^ nuklear::NkContext::End::get()
{
    return (NativePtr->end == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->end);
}

void nuklear::NkContext::End::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_context*)NativePtr)->end = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkWindow^ nuklear::NkContext::Active::get()
{
    return (NativePtr->active == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->active);
}

void nuklear::NkContext::Active::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_context*)NativePtr)->active = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkWindow^ nuklear::NkContext::Current::get()
{
    return (NativePtr->current == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)NativePtr->current);
}

void nuklear::NkContext::Current::set(::nuklear::NkWindow^ value)
{
    ((struct ::nk_context*)NativePtr)->current = (struct ::nk_window*)value->NativePtr;
}

::nuklear::NkPageElement^ nuklear::NkContext::Freelist::get()
{
    return (NativePtr->freelist == nullptr) ? nullptr : gcnew ::nuklear::NkPageElement((struct ::nk_page_element*)NativePtr->freelist);
}

void nuklear::NkContext::Freelist::set(::nuklear::NkPageElement^ value)
{
    ((struct ::nk_context*)NativePtr)->freelist = (struct ::nk_page_element*)value->NativePtr;
}

unsigned int nuklear::NkContext::Count::get()
{
    return NativePtr->count;
}

void nuklear::NkContext::Count::set(unsigned int value)
{
    ((struct ::nk_context*)NativePtr)->count = value;
}

unsigned int nuklear::NkContext::Seq::get()
{
    return NativePtr->seq;
}

void nuklear::NkContext::Seq::set(unsigned int value)
{
    ((struct ::nk_context*)NativePtr)->seq = value;
}

int nuklear::nuklear::NkInitFixed(::nuklear::NkContext^ _0, ::System::IntPtr memory, unsigned long long size, ::nuklear::NkUserFont^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (void*)memory;
    auto __arg2 = size;
    auto __arg3 = (struct ::nk_user_font*)_1->NativePtr;
    auto ___ret = ::nk_init_fixed(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkInit(::nuklear::NkContext^ _0, ::nuklear::NkAllocator^ _1, ::nuklear::NkUserFont^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_allocator*)_1->NativePtr;
    auto __arg2 = (struct ::nk_user_font*)_2->NativePtr;
    auto ___ret = ::nk_init(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkInitCustom(::nuklear::NkContext^ _0, ::nuklear::NkBuffer^ cmds, ::nuklear::NkBuffer^ pool, ::nuklear::NkUserFont^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_buffer*)cmds->NativePtr;
    auto __arg2 = (struct ::nk_buffer*)pool->NativePtr;
    auto __arg3 = (struct ::nk_user_font*)_1->NativePtr;
    auto ___ret = ::nk_init_custom(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

void nuklear::nuklear::NkClear(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_clear(__arg0);
}

void nuklear::nuklear::NkFree(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_free(__arg0);
}

void nuklear::nuklear::NkInputBegin(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_input_begin(__arg0);
}

void nuklear::nuklear::NkInputMotion(::nuklear::NkContext^ _0, int x, int y)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_input_motion(__arg0, x, y);
}

void nuklear::nuklear::NkInputKey(::nuklear::NkContext^ _0, ::nuklear::NkKeys _1, int down)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_keys)_1;
    ::nk_input_key(__arg0, __arg1, down);
}

void nuklear::nuklear::NkInputButton(::nuklear::NkContext^ _0, ::nuklear::NkButtons _1, int x, int y, int down)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    ::nk_input_button(__arg0, __arg1, x, y, down);
}

void nuklear::nuklear::NkInputScroll(::nuklear::NkContext^ _0, ::nuklear::NkVec2^ val)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(val, nullptr))
        throw gcnew ::System::ArgumentNullException("val", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_vec2*)val->NativePtr;
    ::nk_input_scroll(__arg0, __arg1);
}

void nuklear::nuklear::NkInputChar(::nuklear::NkContext^ _0, char _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_input_char(__arg0, _1);
}

void nuklear::nuklear::NkInputGlyph(::nuklear::NkContext^ _0, cli::array<char>^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    char __1ArrayPtr[4];
    if (_1 != nullptr)
    {
        if (_1->Length != 4)
        {
            throw gcnew ::System::InvalidOperationException("Source array size must equal destination array size.");
        }
        for (int i = 0; i < 4; i++)
            __1ArrayPtr[i] = _1[i];
    }
    auto __arg1 = __1ArrayPtr;
    ::nk_input_glyph(__arg0, __arg1);
}

void nuklear::nuklear::NkInputUnicode(::nuklear::NkContext^ _0, unsigned int _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = _1;
    ::nk_input_unicode(__arg0, __arg1);
}

void nuklear::nuklear::NkInputEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_input_end(__arg0);
}

::nuklear::NkCommand^ nuklear::nuklear::NkBegin(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk__begin(__arg0);
    if (___ret == nullptr) return nullptr;
    return (___ret == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)___ret);
}

::nuklear::NkCommand^ nuklear::nuklear::NkNext(::nuklear::NkContext^ _0, ::nuklear::NkCommand^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_command*)_1->NativePtr;
    auto ___ret = ::nk__next(__arg0, __arg1);
    if (___ret == nullptr) return nullptr;
    return (___ret == nullptr) ? nullptr : gcnew ::nuklear::NkCommand((struct ::nk_command*)___ret);
}

bool nuklear::nuklear::NkBegin(::nuklear::NkContext^ ctx, ::System::String^ title, ::nuklear::NkRect^ bounds, unsigned int flags)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(bounds, nullptr))
        throw gcnew ::System::ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)bounds->NativePtr;
    auto __arg3 = flags;
    auto ___ret = ::nk_begin(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

bool nuklear::nuklear::NkBeginTitled(::nuklear::NkContext^ ctx, ::System::String^ name, ::System::String^ title, ::nuklear::NkRect^ bounds, unsigned int flags)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    if (ReferenceEquals(bounds, nullptr))
        throw gcnew ::System::ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_rect*)bounds->NativePtr;
    auto __arg4 = flags;
    auto ___ret = ::nk_begin_titled(__arg0, __arg1, __arg2, __arg3, __arg4);
    return ___ret;
}

void nuklear::nuklear::NkEnd(::nuklear::NkContext^ ctx)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    ::nk_end(__arg0);
}

::nuklear::NkWindow^ nuklear::nuklear::NkWindowFind(::nuklear::NkContext^ ctx, ::System::String^ name)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_window_find(__arg0, __arg1);
    if (___ret == nullptr) return nullptr;
    return (___ret == nullptr) ? nullptr : gcnew ::nuklear::NkWindow((struct ::nk_window*)___ret);
}

::nuklear::NkRect^ nuklear::nuklear::NkWindowGetBounds(::nuklear::NkContext^ ctx)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___ret = ::nk_window_get_bounds(__arg0);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWindowGetPosition(::nuklear::NkContext^ ctx)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___ret = ::nk_window_get_position(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWindowGetSize(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_size(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

float nuklear::nuklear::NkWindowGetWidth(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_width(__arg0);
    return ___ret;
}

float nuklear::nuklear::NkWindowGetHeight(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_height(__arg0);
    return ___ret;
}

::nuklear::NkPanel^ nuklear::nuklear::NkWindowGetPanel(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_panel(__arg0);
    if (___ret == nullptr) return nullptr;
    return (___ret == nullptr) ? nullptr : gcnew ::nuklear::NkPanel((struct ::nk_panel*)___ret);
}

::nuklear::NkRect^ nuklear::nuklear::NkWindowGetContentRegion(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_content_region(__arg0);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWindowGetContentRegionMin(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_content_region_min(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWindowGetContentRegionMax(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_content_region_max(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWindowGetContentRegionSize(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_content_region_size(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkCommandBuffer^ nuklear::nuklear::NkWindowGetCanvas(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_get_canvas(__arg0);
    if (___ret == nullptr) return nullptr;
    return (___ret == nullptr) ? nullptr : gcnew ::nuklear::NkCommandBuffer((struct ::nk_command_buffer*)___ret);
}

void nuklear::nuklear::NkWindowGetScroll(::nuklear::NkContext^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% offset_x, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% offset_y)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    nk_uint __arg1 = (::nk_uint)offset_x;
    nk_uint __arg2 = (::nk_uint)offset_y;
    ::nk_window_get_scroll(__arg0, &__arg1, &__arg2);
    offset_x = __arg1;
    offset_y = __arg2;
}

int nuklear::nuklear::NkWindowHasFocus(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_has_focus(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkWindowIsHovered(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_is_hovered(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkWindowIsCollapsed(::nuklear::NkContext^ ctx, ::System::String^ name)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_window_is_collapsed(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkWindowIsClosed(::nuklear::NkContext^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_window_is_closed(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkWindowIsHidden(::nuklear::NkContext^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_window_is_hidden(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkWindowIsActive(::nuklear::NkContext^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_window_is_active(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkWindowIsAnyHovered(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_window_is_any_hovered(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkItemIsAnyActive(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_item_is_any_active(__arg0);
    return ___ret;
}

void nuklear::nuklear::NkWindowSetBounds(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkRect^ bounds)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(bounds, nullptr))
        throw gcnew ::System::ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)bounds->NativePtr;
    ::nk_window_set_bounds(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkWindowSetPosition(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkVec2^ pos)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(pos, nullptr))
        throw gcnew ::System::ArgumentNullException("pos", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)pos->NativePtr;
    ::nk_window_set_position(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkWindowSetSize(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkVec2^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)_1->NativePtr;
    ::nk_window_set_size(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkWindowSetFocus(::nuklear::NkContext^ _0, ::System::String^ name)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    ::nk_window_set_focus(__arg0, __arg1);
}

void nuklear::nuklear::NkWindowSetScroll(::nuklear::NkContext^ _0, unsigned int offset_x, unsigned int offset_y)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = offset_x;
    auto __arg2 = offset_y;
    ::nk_window_set_scroll(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkWindowClose(::nuklear::NkContext^ ctx, ::System::String^ name)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    ::nk_window_close(__arg0, __arg1);
}

void nuklear::nuklear::NkWindowCollapse(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkCollapseStates state)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = (enum ::nk_collapse_states)state;
    ::nk_window_collapse(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkWindowCollapseIf(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkCollapseStates _1, int cond)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = (enum ::nk_collapse_states)_1;
    ::nk_window_collapse_if(__arg0, __arg1, __arg2, cond);
}

void nuklear::nuklear::NkWindowShow(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkShowStates _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = (enum ::nk_show_states)_1;
    ::nk_window_show(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkWindowShowIf(::nuklear::NkContext^ _0, ::System::String^ name, ::nuklear::NkShowStates _1, int cond)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = (enum ::nk_show_states)_1;
    ::nk_window_show_if(__arg0, __arg1, __arg2, cond);
}

void nuklear::nuklear::NkLayoutSetMinRowHeight(::nuklear::NkContext^ _0, float height)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_set_min_row_height(__arg0, height);
}

void nuklear::nuklear::NkLayoutResetMinRowHeight(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_reset_min_row_height(__arg0);
}

::nuklear::NkRect^ nuklear::nuklear::NkLayoutWidgetBounds(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_layout_widget_bounds(__arg0);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

float nuklear::nuklear::NkLayoutRatioFromPixel(::nuklear::NkContext^ _0, float pixel_width)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_layout_ratio_from_pixel(__arg0, pixel_width);
    return ___ret;
}

void nuklear::nuklear::NkLayoutRowDynamic(::nuklear::NkContext^ ctx, float height, int cols)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    ::nk_layout_row_dynamic(__arg0, height, cols);
}

void nuklear::nuklear::NkLayoutRowStatic(::nuklear::NkContext^ ctx, float height, int item_width, int cols)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    ::nk_layout_row_static(__arg0, height, item_width, cols);
}

void nuklear::nuklear::NkLayoutRowBegin(::nuklear::NkContext^ ctx, ::nuklear::NkLayoutFormat fmt, float row_height, int cols)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto __arg1 = (enum ::nk_layout_format)fmt;
    ::nk_layout_row_begin(__arg0, __arg1, row_height, cols);
}

void nuklear::nuklear::NkLayoutRowPush(::nuklear::NkContext^ _0, float value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_push(__arg0, value);
}

void nuklear::nuklear::NkLayoutRowEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_end(__arg0);
}

void nuklear::nuklear::NkLayoutRow(::nuklear::NkContext^ _0, ::nuklear::NkLayoutFormat _1, float height, int cols, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% ratio)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_layout_format)_1;
    float __arg4 = ratio;
    ::nk_layout_row(__arg0, __arg1, height, cols, &__arg4);
    ratio = __arg4;
}

void nuklear::nuklear::NkLayoutRowTemplateBegin(::nuklear::NkContext^ _0, float row_height)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_template_begin(__arg0, row_height);
}

void nuklear::nuklear::NkLayoutRowTemplatePushDynamic(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_template_push_dynamic(__arg0);
}

void nuklear::nuklear::NkLayoutRowTemplatePushVariable(::nuklear::NkContext^ _0, float min_width)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_template_push_variable(__arg0, min_width);
}

void nuklear::nuklear::NkLayoutRowTemplatePushStatic(::nuklear::NkContext^ _0, float width)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_template_push_static(__arg0, width);
}

void nuklear::nuklear::NkLayoutRowTemplateEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_row_template_end(__arg0);
}

void nuklear::nuklear::NkLayoutSpaceBegin(::nuklear::NkContext^ _0, ::nuklear::NkLayoutFormat _1, float height, int widget_count)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_layout_format)_1;
    ::nk_layout_space_begin(__arg0, __arg1, height, widget_count);
}

void nuklear::nuklear::NkLayoutSpacePush(::nuklear::NkContext^ _0, ::nuklear::NkRect^ bounds)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(bounds, nullptr))
        throw gcnew ::System::ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)bounds->NativePtr;
    ::nk_layout_space_push(__arg0, __arg1);
}

void nuklear::nuklear::NkLayoutSpaceEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_layout_space_end(__arg0);
}

::nuklear::NkRect^ nuklear::nuklear::NkLayoutSpaceBounds(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_layout_space_bounds(__arg0);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkLayoutSpaceToScreen(::nuklear::NkContext^ _0, ::nuklear::NkVec2^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_vec2*)_1->NativePtr;
    auto ___ret = ::nk_layout_space_to_screen(__arg0, __arg1);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkLayoutSpaceToLocal(::nuklear::NkContext^ _0, ::nuklear::NkVec2^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_vec2*)_1->NativePtr;
    auto ___ret = ::nk_layout_space_to_local(__arg0, __arg1);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::NkLayoutSpaceRectToScreen(::nuklear::NkContext^ _0, ::nuklear::NkRect^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto ___ret = ::nk_layout_space_rect_to_screen(__arg0, __arg1);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::NkLayoutSpaceRectToLocal(::nuklear::NkContext^ _0, ::nuklear::NkRect^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto ___ret = ::nk_layout_space_rect_to_local(__arg0, __arg1);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

int nuklear::nuklear::NkGroupBegin(::nuklear::NkContext^ _0, ::System::String^ title, unsigned int _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = _1;
    auto ___ret = ::nk_group_begin(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkGroupBeginTitled(::nuklear::NkContext^ _0, ::System::String^ name, ::System::String^ title, unsigned int _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = _1;
    auto ___ret = ::nk_group_begin_titled(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

void nuklear::nuklear::NkGroupEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_group_end(__arg0);
}

int nuklear::nuklear::NkGroupScrolledOffsetBegin(::nuklear::NkContext^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% x_offset, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% y_offset, ::System::String^ title, unsigned int flags)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    nk_uint __arg1 = (::nk_uint)x_offset;
    nk_uint __arg2 = (::nk_uint)y_offset;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg3 = ___arg3.c_str();
    auto __arg4 = flags;
    auto ___ret = ::nk_group_scrolled_offset_begin(__arg0, &__arg1, &__arg2, __arg3, __arg4);
    x_offset = __arg1;
    y_offset = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkGroupScrolledBegin(::nuklear::NkContext^ _0, ::nuklear::NkScroll^ off, ::System::String^ title, unsigned int _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_scroll*)off->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = _1;
    auto ___ret = ::nk_group_scrolled_begin(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

void nuklear::nuklear::NkGroupScrolledEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_group_scrolled_end(__arg0);
}

void nuklear::nuklear::NkGroupGetScroll(::nuklear::NkContext^ _0, ::System::String^ id, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% x_offset, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% y_offset)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(id);
    auto __arg1 = ___arg1.c_str();
    nk_uint __arg2 = (::nk_uint)x_offset;
    nk_uint __arg3 = (::nk_uint)y_offset;
    ::nk_group_get_scroll(__arg0, __arg1, &__arg2, &__arg3);
    x_offset = __arg2;
    y_offset = __arg3;
}

void nuklear::nuklear::NkGroupSetScroll(::nuklear::NkContext^ _0, ::System::String^ id, unsigned int x_offset, unsigned int y_offset)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(id);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = x_offset;
    auto __arg3 = y_offset;
    ::nk_group_set_scroll(__arg0, __arg1, __arg2, __arg3);
}

int nuklear::nuklear::NkTreePushHashed(::nuklear::NkContext^ _0, ::nuklear::NkTreeType _1, ::System::String^ title, ::nuklear::NkCollapseStates initial_state, ::System::String^ hash, int len, int seed)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_tree_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = (enum ::nk_collapse_states)initial_state;
    auto ___arg4 = clix::marshalString<clix::E_UTF8>(hash);
    auto __arg4 = ___arg4.c_str();
    auto ___ret = ::nk_tree_push_hashed(__arg0, __arg1, __arg2, __arg3, __arg4, len, seed);
    return ___ret;
}

int nuklear::nuklear::NkTreeImagePushHashed(::nuklear::NkContext^ _0, ::nuklear::NkTreeType _1, ::nuklear::NkImage^ _2, ::System::String^ title, ::nuklear::NkCollapseStates initial_state, ::System::String^ hash, int len, int seed)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_tree_type)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)_2->NativePtr;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg3 = ___arg3.c_str();
    auto __arg4 = (enum ::nk_collapse_states)initial_state;
    auto ___arg5 = clix::marshalString<clix::E_UTF8>(hash);
    auto __arg5 = ___arg5.c_str();
    auto ___ret = ::nk_tree_image_push_hashed(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, len, seed);
    return ___ret;
}

void nuklear::nuklear::NkTreePop(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_tree_pop(__arg0);
}

int nuklear::nuklear::NkTreeStatePush(::nuklear::NkContext^ _0, ::nuklear::NkTreeType _1, ::System::String^ title, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] ::nuklear::NkCollapseStates% state)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_tree_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    ::nk_collapse_states __arg3 = (enum ::nk_collapse_states)state;
    auto ___ret = ::nk_tree_state_push(__arg0, __arg1, __arg2, &__arg3);
    state = (::nuklear::NkCollapseStates)__arg3;
    return ___ret;
}

int nuklear::nuklear::NkTreeStateImagePush(::nuklear::NkContext^ _0, ::nuklear::NkTreeType _1, ::nuklear::NkImage^ _2, ::System::String^ title, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] ::nuklear::NkCollapseStates% state)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_tree_type)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)_2->NativePtr;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg3 = ___arg3.c_str();
    ::nk_collapse_states __arg4 = (enum ::nk_collapse_states)state;
    auto ___ret = ::nk_tree_state_image_push(__arg0, __arg1, __arg2, __arg3, &__arg4);
    state = (::nuklear::NkCollapseStates)__arg4;
    return ___ret;
}

void nuklear::nuklear::NkTreeStatePop(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_tree_state_pop(__arg0);
}

int nuklear::nuklear::NkTreeElementPushHashed(::nuklear::NkContext^ _0, ::nuklear::NkTreeType _1, ::System::String^ title, ::nuklear::NkCollapseStates initial_state, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% selected, ::System::String^ hash, int len, int seed)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_tree_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = (enum ::nk_collapse_states)initial_state;
    int __arg4 = selected;
    auto ___arg5 = clix::marshalString<clix::E_UTF8>(hash);
    auto __arg5 = ___arg5.c_str();
    auto ___ret = ::nk_tree_element_push_hashed(__arg0, __arg1, __arg2, __arg3, &__arg4, __arg5, len, seed);
    selected = __arg4;
    return ___ret;
}

int nuklear::nuklear::NkTreeElementImagePushHashed(::nuklear::NkContext^ _0, ::nuklear::NkTreeType _1, ::nuklear::NkImage^ _2, ::System::String^ title, ::nuklear::NkCollapseStates initial_state, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% selected, ::System::String^ hash, int len, int seed)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_tree_type)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)_2->NativePtr;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg3 = ___arg3.c_str();
    auto __arg4 = (enum ::nk_collapse_states)initial_state;
    int __arg5 = selected;
    auto ___arg6 = clix::marshalString<clix::E_UTF8>(hash);
    auto __arg6 = ___arg6.c_str();
    auto ___ret = ::nk_tree_element_image_push_hashed(__arg0, __arg1, __arg2, __arg3, __arg4, &__arg5, __arg6, len, seed);
    selected = __arg5;
    return ___ret;
}

void nuklear::nuklear::NkTreeElementPop(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_tree_element_pop(__arg0);
}

int nuklear::nuklear::NkListViewBegin(::nuklear::NkContext^ _0, ::nuklear::NkListView^ out, ::System::String^ id, unsigned int _1, int row_height, int row_count)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_list_view*)out->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(id);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = _1;
    auto ___ret = ::nk_list_view_begin(__arg0, __arg1, __arg2, __arg3, row_height, row_count);
    return ___ret;
}

void nuklear::nuklear::NkListViewEnd(::nuklear::NkListView^ _0)
{
    auto __arg0 = (struct ::nk_list_view*)_0->NativePtr;
    ::nk_list_view_end(__arg0);
}

::nuklear::NkWidgetLayoutStates nuklear::nuklear::NkWidget(::nuklear::NkRect^ _0, ::nuklear::NkContext^ _1)
{
    auto __arg0 = (struct ::nk_rect*)_0->NativePtr;
    auto __arg1 = (struct ::nk_context*)_1->NativePtr;
    auto ___ret = ::nk_widget(__arg0, __arg1);
    return (::nuklear::NkWidgetLayoutStates)___ret;
}

::nuklear::NkWidgetLayoutStates nuklear::nuklear::NkWidgetFitting(::nuklear::NkRect^ _0, ::nuklear::NkContext^ _1, ::nuklear::NkVec2^ _2)
{
    auto __arg0 = (struct ::nk_rect*)_0->NativePtr;
    auto __arg1 = (struct ::nk_context*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)_2->NativePtr;
    auto ___ret = ::nk_widget_fitting(__arg0, __arg1, __arg2);
    return (::nuklear::NkWidgetLayoutStates)___ret;
}

::nuklear::NkRect^ nuklear::nuklear::NkWidgetBounds(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_widget_bounds(__arg0);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWidgetPosition(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_widget_position(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkWidgetSize(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_widget_size(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

float nuklear::nuklear::NkWidgetWidth(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_widget_width(__arg0);
    return ___ret;
}

float nuklear::nuklear::NkWidgetHeight(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_widget_height(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkWidgetIsHovered(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_widget_is_hovered(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkWidgetIsMouseClicked(::nuklear::NkContext^ _0, ::nuklear::NkButtons _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    auto ___ret = ::nk_widget_is_mouse_clicked(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkWidgetHasMouseClickDown(::nuklear::NkContext^ _0, ::nuklear::NkButtons _1, int down)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    auto ___ret = ::nk_widget_has_mouse_click_down(__arg0, __arg1, down);
    return ___ret;
}

void nuklear::nuklear::NkSpacing(::nuklear::NkContext^ _0, int cols)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_spacing(__arg0, cols);
}

void nuklear::nuklear::NkText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int _3)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = _3;
    ::nk_text(__arg0, __arg1, _2, __arg3);
}

void nuklear::nuklear::NkTextColored(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int _3, ::nuklear::NkColor^ _4)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = _3;
    if (ReferenceEquals(_4, nullptr))
        throw gcnew ::System::ArgumentNullException("_4", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_4->NativePtr;
    ::nk_text_colored(__arg0, __arg1, _2, __arg3, __arg4);
}

void nuklear::nuklear::NkTextWrap(::nuklear::NkContext^ _0, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    ::nk_text_wrap(__arg0, __arg1, _2);
}

void nuklear::nuklear::NkTextWrapColored(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, ::nuklear::NkColor^ _3)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(_3, nullptr))
        throw gcnew ::System::ArgumentNullException("_3", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_3->NativePtr;
    ::nk_text_wrap_colored(__arg0, __arg1, _2, __arg3);
}

void nuklear::nuklear::NkLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    ::nk_label(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkLabelColored(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_label_colored(__arg0, __arg1, __arg2, __arg3);
}

void nuklear::nuklear::NkLabelWrap(::nuklear::NkContext^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    ::nk_label_wrap(__arg0, __arg1);
}

void nuklear::nuklear::NkLabelColoredWrap(::nuklear::NkContext^ _0, ::System::String^ _1, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_label_colored_wrap(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::nk_image(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    ::nk_image(__arg0, __arg1);
}

void nuklear::nuklear::NkImageColor(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_image_color(__arg0, __arg1, __arg2);
}

int nuklear::nuklear::NkButtonText(::nuklear::NkContext^ _0, ::System::String^ title, int len)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_button_text(__arg0, __arg1, len);
    return ___ret;
}

int nuklear::nuklear::NkButtonLabel(::nuklear::NkContext^ _0, ::System::String^ title)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_button_label(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkButtonColor(::nuklear::NkContext^ _0, ::nuklear::NkColor^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_1->NativePtr;
    auto ___ret = ::nk_button_color(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkButtonSymbol(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___ret = ::nk_button_symbol(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkButtonImage(::nuklear::NkContext^ _0, ::nuklear::NkImage^ img)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)img->NativePtr;
    auto ___ret = ::nk_button_image(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkButtonSymbolLabel(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, unsigned int text_alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = text_alignment;
    auto ___ret = ::nk_button_symbol_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkButtonSymbolText(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, int _3, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_button_symbol_text(__arg0, __arg1, __arg2, _3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkButtonImageLabel(::nuklear::NkContext^ _0, ::nuklear::NkImage^ img, ::System::String^ _1, unsigned int text_alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)img->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = text_alignment;
    auto ___ret = ::nk_button_image_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkButtonImageText(::nuklear::NkContext^ _0, ::nuklear::NkImage^ img, ::System::String^ _1, int _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)img->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_button_image_text(__arg0, __arg1, __arg2, _2, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkButtonTextStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::System::String^ title, int len)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_button_text_styled(__arg0, __arg1, __arg2, len);
    return ___ret;
}

int nuklear::nuklear::NkButtonLabelStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::System::String^ title)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_button_label_styled(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkButtonSymbolStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::nuklear::NkSymbolType _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    auto __arg2 = (enum ::nk_symbol_type)_2;
    auto ___ret = ::nk_button_symbol_styled(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkButtonImageStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::nuklear::NkImage^ img)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)img->NativePtr;
    auto ___ret = ::nk_button_image_styled(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkButtonSymbolTextStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::nuklear::NkSymbolType _2, ::System::String^ _3, int _4, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    auto __arg2 = (enum ::nk_symbol_type)_2;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(_3);
    auto __arg3 = ___arg3.c_str();
    auto __arg5 = alignment;
    auto ___ret = ::nk_button_symbol_text_styled(__arg0, __arg1, __arg2, __arg3, _4, __arg5);
    return ___ret;
}

int nuklear::nuklear::NkButtonSymbolLabelStyled(::nuklear::NkContext^ ctx, ::nuklear::NkStyleButton^ style, ::nuklear::NkSymbolType symbol, ::System::String^ title, unsigned int align)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)style->NativePtr;
    auto __arg2 = (enum ::nk_symbol_type)symbol;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg3 = ___arg3.c_str();
    auto __arg4 = align;
    auto ___ret = ::nk_button_symbol_label_styled(__arg0, __arg1, __arg2, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkButtonImageLabelStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::nuklear::NkImage^ img, ::System::String^ _2, unsigned int text_alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)img->NativePtr;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg3 = ___arg3.c_str();
    auto __arg4 = text_alignment;
    auto ___ret = ::nk_button_image_label_styled(__arg0, __arg1, __arg2, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkButtonImageTextStyled(::nuklear::NkContext^ _0, ::nuklear::NkStyleButton^ _1, ::nuklear::NkImage^ img, ::System::String^ _2, int _3, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_button*)_1->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)img->NativePtr;
    auto ___arg3 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg3 = ___arg3.c_str();
    auto __arg5 = alignment;
    auto ___ret = ::nk_button_image_text_styled(__arg0, __arg1, __arg2, __arg3, _3, __arg5);
    return ___ret;
}

void nuklear::nuklear::NkButtonSetBehavior(::nuklear::NkContext^ _0, ::nuklear::NkButtonBehavior _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_button_behavior)_1;
    ::nk_button_set_behavior(__arg0, __arg1);
}

int nuklear::nuklear::NkButtonPushBehavior(::nuklear::NkContext^ _0, ::nuklear::NkButtonBehavior _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_button_behavior)_1;
    auto ___ret = ::nk_button_push_behavior(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkButtonPopBehavior(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_button_pop_behavior(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkCheckLabel(::nuklear::NkContext^ _0, ::System::String^ _1, int active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_check_label(__arg0, __arg1, active);
    return ___ret;
}

int nuklear::nuklear::NkCheckText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, int active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_check_text(__arg0, __arg1, _2, active);
    return ___ret;
}

unsigned int nuklear::nuklear::NkCheckFlagsLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int flags, unsigned int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_check_flags_label(__arg0, __arg1, flags, value);
    return ___ret;
}

unsigned int nuklear::nuklear::NkCheckFlagsText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int flags, unsigned int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_check_flags_text(__arg0, __arg1, _2, flags, value);
    return ___ret;
}

int nuklear::nuklear::NkCheckboxLabel(::nuklear::NkContext^ _0, ::System::String^ _1, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    int __arg2 = active;
    auto ___ret = ::nk_checkbox_label(__arg0, __arg1, &__arg2);
    active = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkCheckboxText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    int __arg3 = active;
    auto ___ret = ::nk_checkbox_text(__arg0, __arg1, _2, &__arg3);
    active = __arg3;
    return ___ret;
}

int nuklear::nuklear::NkCheckboxFlagsLabel(::nuklear::NkContext^ _0, ::System::String^ _1, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% flags, unsigned int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    unsigned int __arg2 = flags;
    auto ___ret = ::nk_checkbox_flags_label(__arg0, __arg1, &__arg2, value);
    flags = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkCheckboxFlagsText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% flags, unsigned int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    unsigned int __arg3 = flags;
    auto ___ret = ::nk_checkbox_flags_text(__arg0, __arg1, _2, &__arg3, value);
    flags = __arg3;
    return ___ret;
}

int nuklear::nuklear::NkRadioLabel(::nuklear::NkContext^ _0, ::System::String^ _1, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    int __arg2 = active;
    auto ___ret = ::nk_radio_label(__arg0, __arg1, &__arg2);
    active = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkRadioText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    int __arg3 = active;
    auto ___ret = ::nk_radio_text(__arg0, __arg1, _2, &__arg3);
    active = __arg3;
    return ___ret;
}

int nuklear::nuklear::NkOptionLabel(::nuklear::NkContext^ _0, ::System::String^ _1, int active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_option_label(__arg0, __arg1, active);
    return ___ret;
}

int nuklear::nuklear::NkOptionText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, int active)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_option_text(__arg0, __arg1, _2, active);
    return ___ret;
}

int nuklear::nuklear::NkSelectableLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    int __arg3 = value;
    auto ___ret = ::nk_selectable_label(__arg0, __arg1, __arg2, &__arg3);
    value = __arg3;
    return ___ret;
}

int nuklear::nuklear::NkSelectableText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int align, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    int __arg4 = value;
    auto ___ret = ::nk_selectable_text(__arg0, __arg1, _2, __arg3, &__arg4);
    value = __arg4;
    return ___ret;
}

int nuklear::nuklear::NkSelectableImageLabel(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, unsigned int align, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = align;
    int __arg4 = value;
    auto ___ret = ::nk_selectable_image_label(__arg0, __arg1, __arg2, __arg3, &__arg4);
    value = __arg4;
    return ___ret;
}

int nuklear::nuklear::NkSelectableImageText(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, int _3, unsigned int align, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = align;
    int __arg5 = value;
    auto ___ret = ::nk_selectable_image_text(__arg0, __arg1, __arg2, _3, __arg4, &__arg5);
    value = __arg5;
    return ___ret;
}

int nuklear::nuklear::NkSelectableSymbolLabel(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, unsigned int align, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = align;
    int __arg4 = value;
    auto ___ret = ::nk_selectable_symbol_label(__arg0, __arg1, __arg2, __arg3, &__arg4);
    value = __arg4;
    return ___ret;
}

int nuklear::nuklear::NkSelectableSymbolText(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, int _3, unsigned int align, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = align;
    int __arg5 = value;
    auto ___ret = ::nk_selectable_symbol_text(__arg0, __arg1, __arg2, _3, __arg4, &__arg5);
    value = __arg5;
    return ___ret;
}

int nuklear::nuklear::NkSelectLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align, int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    auto ___ret = ::nk_select_label(__arg0, __arg1, __arg2, value);
    return ___ret;
}

int nuklear::nuklear::NkSelectText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int align, int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    auto ___ret = ::nk_select_text(__arg0, __arg1, _2, __arg3, value);
    return ___ret;
}

int nuklear::nuklear::NkSelectImageLabel(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, unsigned int align, int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = align;
    auto ___ret = ::nk_select_image_label(__arg0, __arg1, __arg2, __arg3, value);
    return ___ret;
}

int nuklear::nuklear::NkSelectImageText(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, int _3, unsigned int align, int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = align;
    auto ___ret = ::nk_select_image_text(__arg0, __arg1, __arg2, _3, __arg4, value);
    return ___ret;
}

int nuklear::nuklear::NkSelectSymbolLabel(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, unsigned int align, int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = align;
    auto ___ret = ::nk_select_symbol_label(__arg0, __arg1, __arg2, __arg3, value);
    return ___ret;
}

int nuklear::nuklear::NkSelectSymbolText(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, int _3, unsigned int align, int value)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = align;
    auto ___ret = ::nk_select_symbol_text(__arg0, __arg1, __arg2, _3, __arg4, value);
    return ___ret;
}

float nuklear::nuklear::NkSlideFloat(::nuklear::NkContext^ _0, float min, float val, float max, float step)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_slide_float(__arg0, min, val, max, step);
    return ___ret;
}

int nuklear::nuklear::NkSlideInt(::nuklear::NkContext^ _0, int min, int val, int max, int step)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_slide_int(__arg0, min, val, max, step);
    return ___ret;
}

int nuklear::nuklear::NkSliderFloat(::nuklear::NkContext^ _0, float min, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% val, float max, float step)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    float __arg2 = val;
    auto ___ret = ::nk_slider_float(__arg0, min, &__arg2, max, step);
    val = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkSliderInt(::nuklear::NkContext^ _0, int min, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% val, int max, int step)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    int __arg2 = val;
    auto ___ret = ::nk_slider_int(__arg0, min, &__arg2, max, step);
    val = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkProgress(::nuklear::NkContext^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned long long% cur, unsigned long long max, int modifyable)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    nk_size __arg1 = (::nk_size)cur;
    auto __arg2 = max;
    auto ___ret = ::nk_progress(__arg0, &__arg1, __arg2, modifyable);
    cur = __arg1;
    return ___ret;
}

unsigned long long nuklear::nuklear::NkProg(::nuklear::NkContext^ _0, unsigned long long cur, unsigned long long max, int modifyable)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = cur;
    auto __arg2 = max;
    auto ___ret = ::nk_prog(__arg0, __arg1, __arg2, modifyable);
    return ___ret;
}

::nuklear::NkColorf^ nuklear::nuklear::NkColorPicker(::nuklear::NkContext^ _0, ::nuklear::NkColorf^ _1, ::nuklear::NkColorFormat _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_colorf*)_1->NativePtr;
    auto __arg2 = (enum ::nk_color_format)_2;
    auto ___ret = ::nk_color_picker(__arg0, __arg1, __arg2);
    auto _____ret = new struct ::nk_colorf(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColorf((struct ::nk_colorf*)_____ret, true);
}

int nuklear::nuklear::NkColorPick(::nuklear::NkContext^ _0, ::nuklear::NkColorf^ _1, ::nuklear::NkColorFormat _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_colorf*)_1->NativePtr;
    auto __arg2 = (enum ::nk_color_format)_2;
    auto ___ret = ::nk_color_pick(__arg0, __arg1, __arg2);
    return ___ret;
}

void nuklear::nuklear::NkPropertyInt(::nuklear::NkContext^ _0, ::System::String^ name, int min, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% val, int max, int step, float inc_per_pixel)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    int __arg3 = val;
    ::nk_property_int(__arg0, __arg1, min, &__arg3, max, step, inc_per_pixel);
    val = __arg3;
}

void nuklear::nuklear::NkPropertyFloat(::nuklear::NkContext^ _0, ::System::String^ name, float min, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% val, float max, float step, float inc_per_pixel)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    float __arg3 = val;
    ::nk_property_float(__arg0, __arg1, min, &__arg3, max, step, inc_per_pixel);
    val = __arg3;
}

void nuklear::nuklear::NkPropertyDouble(::nuklear::NkContext^ _0, ::System::String^ name, double min, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% val, double max, double step, float inc_per_pixel)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    double __arg3 = val;
    ::nk_property_double(__arg0, __arg1, min, &__arg3, max, step, inc_per_pixel);
    val = __arg3;
}

int nuklear::nuklear::NkPropertyi(::nuklear::NkContext^ _0, ::System::String^ name, int min, int val, int max, int step, float inc_per_pixel)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_propertyi(__arg0, __arg1, min, val, max, step, inc_per_pixel);
    return ___ret;
}

float nuklear::nuklear::NkPropertyf(::nuklear::NkContext^ _0, ::System::String^ name, float min, float val, float max, float step, float inc_per_pixel)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_propertyf(__arg0, __arg1, min, val, max, step, inc_per_pixel);
    return ___ret;
}

double nuklear::nuklear::NkPropertyd(::nuklear::NkContext^ _0, ::System::String^ name, double min, double val, double max, double step, float inc_per_pixel)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_propertyd(__arg0, __arg1, min, val, max, step, inc_per_pixel);
    return ___ret;
}

unsigned int nuklear::nuklear::NkEditString(::nuklear::NkContext^ _0, unsigned int _1, char* buffer, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% len, int max, ::nuklear::NkPluginFilter^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = _1;
    auto __arg2 = (char*)buffer;
    int __arg3 = len;
    auto __arg5 = static_cast<::nk_plugin_filter>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(_2).ToPointer());
    auto ___ret = ::nk_edit_string(__arg0, __arg1, __arg2, &__arg3, max, __arg5);
    len = __arg3;
    return ___ret;
}

unsigned int nuklear::nuklear::NkEditStringZeroTerminated(::nuklear::NkContext^ _0, unsigned int _1, char* buffer, int max, ::nuklear::NkPluginFilter^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = _1;
    auto __arg2 = (char*)buffer;
    auto __arg4 = static_cast<::nk_plugin_filter>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(_2).ToPointer());
    auto ___ret = ::nk_edit_string_zero_terminated(__arg0, __arg1, __arg2, max, __arg4);
    return ___ret;
}

unsigned int nuklear::nuklear::NkEditBuffer(::nuklear::NkContext^ _0, unsigned int _1, ::nuklear::NkTextEdit^ _2, ::nuklear::NkPluginFilter^ _3)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = _1;
    auto __arg2 = (struct ::nk_text_edit*)_2->NativePtr;
    auto __arg3 = static_cast<::nk_plugin_filter>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(_3).ToPointer());
    auto ___ret = ::nk_edit_buffer(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

void nuklear::nuklear::NkEditFocus(::nuklear::NkContext^ _0, unsigned int flags)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = flags;
    ::nk_edit_focus(__arg0, __arg1);
}

void nuklear::nuklear::NkEditUnfocus(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_edit_unfocus(__arg0);
}

int nuklear::nuklear::NkChartBegin(::nuklear::NkContext^ _0, ::nuklear::NkChartType _1, int num, float min, float max)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_chart_type)_1;
    auto ___ret = ::nk_chart_begin(__arg0, __arg1, num, min, max);
    return ___ret;
}

int nuklear::nuklear::NkChartBeginColored(::nuklear::NkContext^ _0, ::nuklear::NkChartType _1, ::nuklear::NkColor^ _2, ::nuklear::NkColor^ active, int num, float min, float max)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_chart_type)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)_2->NativePtr;
    if (ReferenceEquals(active, nullptr))
        throw gcnew ::System::ArgumentNullException("active", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)active->NativePtr;
    auto ___ret = ::nk_chart_begin_colored(__arg0, __arg1, __arg2, __arg3, num, min, max);
    return ___ret;
}

void nuklear::nuklear::NkChartAddSlot(::nuklear::NkContext^ ctx, ::nuklear::NkChartType _0, int count, float min_value, float max_value)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto __arg1 = (enum ::nk_chart_type)_0;
    ::nk_chart_add_slot(__arg0, __arg1, count, min_value, max_value);
}

void nuklear::nuklear::NkChartAddSlotColored(::nuklear::NkContext^ ctx, ::nuklear::NkChartType _0, ::nuklear::NkColor^ _1, ::nuklear::NkColor^ active, int count, float min_value, float max_value)
{
    auto __arg0 = (struct ::nk_context*)ctx->NativePtr;
    auto __arg1 = (enum ::nk_chart_type)_0;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)_1->NativePtr;
    if (ReferenceEquals(active, nullptr))
        throw gcnew ::System::ArgumentNullException("active", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)active->NativePtr;
    ::nk_chart_add_slot_colored(__arg0, __arg1, __arg2, __arg3, count, min_value, max_value);
}

unsigned int nuklear::nuklear::NkChartPush(::nuklear::NkContext^ _0, float _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_chart_push(__arg0, _1);
    return ___ret;
}

unsigned int nuklear::nuklear::NkChartPushSlot(::nuklear::NkContext^ _0, float _1, int _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_chart_push_slot(__arg0, _1, _2);
    return ___ret;
}

void nuklear::nuklear::NkChartEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_chart_end(__arg0);
}

void nuklear::nuklear::NkPlot(::nuklear::NkContext^ _0, ::nuklear::NkChartType _1, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% values, int count, int offset)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_chart_type)_1;
    float __arg2 = values;
    ::nk_plot(__arg0, __arg1, &__arg2, count, offset);
    values = __arg2;
}

void nuklear::nuklear::NkPlotFunction(::nuklear::NkContext^ _0, ::nuklear::NkChartType _1, ::System::IntPtr userdata, ::nuklear::Func_float___IntPtr_int^ value_getter, int count, int offset)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_chart_type)_1;
    auto __arg2 = (void*)userdata;
    auto __arg3 = static_cast<float (*)(void*, int)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value_getter).ToPointer());
    ::nk_plot_function(__arg0, __arg1, __arg2, __arg3, count, offset);
}

int nuklear::nuklear::NkPopupBegin(::nuklear::NkContext^ _0, ::nuklear::NkPopupType _1, ::System::String^ _2, unsigned int _3, ::nuklear::NkRect^ bounds)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_popup_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = _3;
    if (ReferenceEquals(bounds, nullptr))
        throw gcnew ::System::ArgumentNullException("bounds", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_rect*)bounds->NativePtr;
    auto ___ret = ::nk_popup_begin(__arg0, __arg1, __arg2, __arg3, __arg4);
    return ___ret;
}

void nuklear::nuklear::NkPopupClose(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_popup_close(__arg0);
}

void nuklear::nuklear::NkPopupEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_popup_end(__arg0);
}

void nuklear::nuklear::NkPopupGetScroll(::nuklear::NkContext^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% offset_x, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% offset_y)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    nk_uint __arg1 = (::nk_uint)offset_x;
    nk_uint __arg2 = (::nk_uint)offset_y;
    ::nk_popup_get_scroll(__arg0, &__arg1, &__arg2);
    offset_x = __arg1;
    offset_y = __arg2;
}

void nuklear::nuklear::NkPopupSetScroll(::nuklear::NkContext^ _0, unsigned int offset_x, unsigned int offset_y)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = offset_x;
    auto __arg2 = offset_y;
    ::nk_popup_set_scroll(__arg0, __arg1, __arg2);
}

int nuklear::nuklear::NkCombo(::nuklear::NkContext^ _0, ::System::String^* items, int count, int selected, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (const char**)items; // void* -> const char**
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo(__arg0, __arg1, count, selected, item_height, __arg5);
    return ___ret;
}

int nuklear::nuklear::NkComboSeparator(::nuklear::NkContext^ _0, ::System::String^ items_separated_by_separator, int separator, int selected, int count, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(items_separated_by_separator);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_separator(__arg0, __arg1, separator, selected, count, item_height, __arg6);
    return ___ret;
}

int nuklear::nuklear::NkComboString(::nuklear::NkContext^ _0, ::System::String^ items_separated_by_zeros, int selected, int count, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(items_separated_by_zeros);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_string(__arg0, __arg1, selected, count, item_height, __arg5);
    return ___ret;
}

int nuklear::nuklear::NkComboCallback(::nuklear::NkContext^ _0, ::nuklear::Action___IntPtr_int_sbytePtrPtr^ item_getter, ::System::IntPtr userdata, int selected, int count, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = static_cast<void (*)(void*, int, const char**)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(item_getter).ToPointer()); // (void*, int, void*) -> (void*, int, char**)
    auto __arg2 = (void*)userdata;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_callback(__arg0, __arg1, __arg2, selected, count, item_height, __arg6);
    return ___ret;
}

void nuklear::nuklear::NkCombobox(::nuklear::NkContext^ _0, ::System::String^* items, int count, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% selected, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (const char**)items; // (void*) -> (const char**)
    int __arg3 = selected;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_vec2*)size->NativePtr;
    ::nk_combobox(__arg0, __arg1, count, &__arg3, item_height, __arg5);
    selected = __arg3;
}

void nuklear::nuklear::NkComboboxString(::nuklear::NkContext^ _0, ::System::String^ items_separated_by_zeros, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% selected, int count, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(items_separated_by_zeros);
    auto __arg1 = ___arg1.c_str();
    int __arg2 = selected;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_vec2*)size->NativePtr;
    ::nk_combobox_string(__arg0, __arg1, &__arg2, count, item_height, __arg5);
    selected = __arg2;
}

void nuklear::nuklear::NkComboboxSeparator(::nuklear::NkContext^ _0, ::System::String^ items_separated_by_separator, int separator, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% selected, int count, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(items_separated_by_separator);
    auto __arg1 = ___arg1.c_str();
    int __arg3 = selected;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_vec2*)size->NativePtr;
    ::nk_combobox_separator(__arg0, __arg1, separator, &__arg3, count, item_height, __arg6);
    selected = __arg3;
}

void nuklear::nuklear::NkComboboxCallback(::nuklear::NkContext^ _0, ::nuklear::Action___IntPtr_int_sbytePtrPtr^ item_getter, ::System::IntPtr _1, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% selected, int count, int item_height, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = static_cast<void (*)(void*, int, const char**)>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(item_getter).ToPointer()); // (void*, int, void*) -> (void*, int, char**)
    auto __arg2 = (void*)_1;
    int __arg3 = selected;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_vec2*)size->NativePtr;
    ::nk_combobox_callback(__arg0, __arg1, __arg2, &__arg3, count, item_height, __arg6);
    selected = __arg3;
}

int nuklear::nuklear::NkComboBeginText(::nuklear::NkContext^ _0, ::System::String^ selected, int _1, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(selected);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_text(__arg0, __arg1, _1, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginLabel(::nuklear::NkContext^ _0, ::System::String^ selected, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(selected);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_label(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginColor(::nuklear::NkContext^ _0, ::nuklear::NkColor^ color, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(color, nullptr))
        throw gcnew ::System::ArgumentNullException("color", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)color->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_color(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginSymbol(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_symbol(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginSymbolLabel(::nuklear::NkContext^ _0, ::System::String^ selected, ::nuklear::NkSymbolType _1, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(selected);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = (enum ::nk_symbol_type)_1;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_symbol_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginSymbolText(::nuklear::NkContext^ _0, ::System::String^ selected, int _1, ::nuklear::NkSymbolType _2, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(selected);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = (enum ::nk_symbol_type)_2;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_symbol_text(__arg0, __arg1, _1, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginImage(::nuklear::NkContext^ _0, ::nuklear::NkImage^ img, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)img->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_image(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginImageLabel(::nuklear::NkContext^ _0, ::System::String^ selected, ::nuklear::NkImage^ _1, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(selected);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)_1->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_image_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkComboBeginImageText(::nuklear::NkContext^ _0, ::System::String^ selected, int _1, ::nuklear::NkImage^ _2, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(selected);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_image*)_2->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_combo_begin_image_text(__arg0, __arg1, _1, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkComboItemLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = alignment;
    auto ___ret = ::nk_combo_item_label(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkComboItemText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_combo_item_text(__arg0, __arg1, _2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkComboItemImageLabel(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_combo_item_image_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkComboItemImageText(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, int _3, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_combo_item_image_text(__arg0, __arg1, __arg2, _3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkComboItemSymbolLabel(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_combo_item_symbol_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkComboItemSymbolText(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, int _3, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_combo_item_symbol_text(__arg0, __arg1, __arg2, _3, __arg4);
    return ___ret;
}

void nuklear::nuklear::NkComboClose(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_combo_close(__arg0);
}

void nuklear::nuklear::NkComboEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_combo_end(__arg0);
}

int nuklear::nuklear::NkContextualBegin(::nuklear::NkContext^ _0, unsigned int _1, ::nuklear::NkVec2^ _2, ::nuklear::NkRect^ trigger_bounds)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = _1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)_2->NativePtr;
    if (ReferenceEquals(trigger_bounds, nullptr))
        throw gcnew ::System::ArgumentNullException("trigger_bounds", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_rect*)trigger_bounds->NativePtr;
    auto ___ret = ::nk_contextual_begin(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkContextualItemText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int align)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    auto ___ret = ::nk_contextual_item_text(__arg0, __arg1, _2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkContextualItemLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    auto ___ret = ::nk_contextual_item_label(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkContextualItemImageLabel(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_contextual_item_image_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkContextualItemImageText(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, int len, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_contextual_item_image_text(__arg0, __arg1, __arg2, len, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkContextualItemSymbolLabel(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_contextual_item_symbol_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkContextualItemSymbolText(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, int _3, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_contextual_item_symbol_text(__arg0, __arg1, __arg2, _3, __arg4);
    return ___ret;
}

void nuklear::nuklear::NkContextualClose(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_contextual_close(__arg0);
}

void nuklear::nuklear::NkContextualEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_contextual_end(__arg0);
}

void nuklear::nuklear::NkTooltip(::nuklear::NkContext^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    ::nk_tooltip(__arg0, __arg1);
}

int nuklear::nuklear::NkTooltipBegin(::nuklear::NkContext^ _0, float width)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_tooltip_begin(__arg0, width);
    return ___ret;
}

void nuklear::nuklear::NkTooltipEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_tooltip_end(__arg0);
}

void nuklear::nuklear::NkMenubarBegin(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_menubar_begin(__arg0);
}

void nuklear::nuklear::NkMenubarEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_menubar_end(__arg0);
}

int nuklear::nuklear::NkMenuBeginText(::nuklear::NkContext^ _0, ::System::String^ title, int title_len, unsigned int align, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(title);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_text(__arg0, __arg1, title_len, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginImage(::nuklear::NkContext^ _0, ::System::String^ _1, ::nuklear::NkImage^ _2, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_image*)_2->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_image(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginImageText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int align, ::nuklear::NkImage^ _3, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    if (ReferenceEquals(_3, nullptr))
        throw gcnew ::System::ArgumentNullException("_3", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_image*)_3->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_image_text(__arg0, __arg1, _2, __arg3, __arg4, __arg5);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginImageLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align, ::nuklear::NkImage^ _2, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_image*)_2->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_image_label(__arg0, __arg1, __arg2, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginSymbol(::nuklear::NkContext^ _0, ::System::String^ _1, ::nuklear::NkSymbolType _2, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = (enum ::nk_symbol_type)_2;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_symbol(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginSymbolText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int align, ::nuklear::NkSymbolType _3, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    auto __arg4 = (enum ::nk_symbol_type)_3;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_symbol_text(__arg0, __arg1, _2, __arg3, __arg4, __arg5);
    return ___ret;
}

int nuklear::nuklear::NkMenuBeginSymbolLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int align, ::nuklear::NkSymbolType _2, ::nuklear::NkVec2^ size)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = align;
    auto __arg3 = (enum ::nk_symbol_type)_2;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_menu_begin_symbol_label(__arg0, __arg1, __arg2, __arg3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkMenuItemText(::nuklear::NkContext^ _0, ::System::String^ _1, int _2, unsigned int align)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg3 = align;
    auto ___ret = ::nk_menu_item_text(__arg0, __arg1, _2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkMenuItemLabel(::nuklear::NkContext^ _0, ::System::String^ _1, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto __arg2 = alignment;
    auto ___ret = ::nk_menu_item_label(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkMenuItemImageLabel(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_menu_item_image_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

int nuklear::nuklear::NkMenuItemImageText(::nuklear::NkContext^ _0, ::nuklear::NkImage^ _1, ::System::String^ _2, int len, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_image*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_menu_item_image_text(__arg0, __arg1, __arg2, len, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkMenuItemSymbolText(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, int _3, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = alignment;
    auto ___ret = ::nk_menu_item_symbol_text(__arg0, __arg1, __arg2, _3, __arg4);
    return ___ret;
}

int nuklear::nuklear::NkMenuItemSymbolLabel(::nuklear::NkContext^ _0, ::nuklear::NkSymbolType _1, ::System::String^ _2, unsigned int alignment)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_symbol_type)_1;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_2);
    auto __arg2 = ___arg2.c_str();
    auto __arg3 = alignment;
    auto ___ret = ::nk_menu_item_symbol_label(__arg0, __arg1, __arg2, __arg3);
    return ___ret;
}

void nuklear::nuklear::NkMenuClose(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_menu_close(__arg0);
}

void nuklear::nuklear::NkMenuEnd(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_menu_end(__arg0);
}

void nuklear::nuklear::NkStyleDefault(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_style_default(__arg0);
}

void nuklear::nuklear::NkStyleFromTable(::nuklear::NkContext^ _0, ::nuklear::NkColor^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_color*)_1->NativePtr;
    ::nk_style_from_table(__arg0, __arg1);
}

void nuklear::nuklear::NkStyleLoadCursor(::nuklear::NkContext^ _0, ::nuklear::NkStyleCursor _1, ::nuklear::NkCursor^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_style_cursor)_1;
    auto __arg2 = (struct ::nk_cursor*)_2->NativePtr;
    ::nk_style_load_cursor(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkStyleLoadAllCursors(::nuklear::NkContext^ _0, ::nuklear::NkCursor^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_cursor*)_1->NativePtr;
    ::nk_style_load_all_cursors(__arg0, __arg1);
}

::System::String^ nuklear::nuklear::NkStyleGetColorByName(::nuklear::NkStyleColors _0)
{
    auto __arg0 = (enum ::nk_style_colors)_0;
    auto ___ret = ::nk_style_get_color_by_name(__arg0);
    if (___ret == nullptr) return nullptr;
    return (___ret == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(___ret));
}

void nuklear::nuklear::NkStyleSetFont(::nuklear::NkContext^ _0, ::nuklear::NkUserFont^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_user_font*)_1->NativePtr;
    ::nk_style_set_font(__arg0, __arg1);
}

int nuklear::nuklear::NkStyleSetCursor(::nuklear::NkContext^ _0, ::nuklear::NkStyleCursor _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (enum ::nk_style_cursor)_1;
    auto ___ret = ::nk_style_set_cursor(__arg0, __arg1);
    return ___ret;
}

void nuklear::nuklear::NkStyleShowCursor(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_style_show_cursor(__arg0);
}

void nuklear::nuklear::NkStyleHideCursor(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    ::nk_style_hide_cursor(__arg0);
}

int nuklear::nuklear::NkStylePushFont(::nuklear::NkContext^ _0, ::nuklear::NkUserFont^ _1)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_user_font*)_1->NativePtr;
    auto ___ret = ::nk_style_push_font(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkStylePushFloat(::nuklear::NkContext^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% _1, float _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    float __arg1 = _1;
    auto ___ret = ::nk_style_push_float(__arg0, &__arg1, _2);
    _1 = __arg1;
    return ___ret;
}

int nuklear::nuklear::NkStylePushVec2(::nuklear::NkContext^ _0, ::nuklear::NkVec2^ _1, ::nuklear::NkVec2^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_vec2*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_vec2*)_2->NativePtr;
    auto ___ret = ::nk_style_push_vec2(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkStylePushStyleItem(::nuklear::NkContext^ _0, ::nuklear::NkStyleItem^ _1, ::nuklear::NkStyleItem^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_style_item*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_style_item*)_2->NativePtr;
    auto ___ret = ::nk_style_push_style_item(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkStylePushFlags(::nuklear::NkContext^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% _1, unsigned int _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    nk_flags __arg1 = (::nk_flags)(::nk_uint)_1;
    auto __arg2 = _2;
    auto ___ret = ::nk_style_push_flags(__arg0, &__arg1, __arg2);
    _1 = __arg1;
    return ___ret;
}

int nuklear::nuklear::NkStylePushColor(::nuklear::NkContext^ _0, ::nuklear::NkColor^ _1, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto __arg1 = (struct ::nk_color*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)_2->NativePtr;
    auto ___ret = ::nk_style_push_color(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkStylePopFont(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_style_pop_font(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStylePopFloat(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_style_pop_float(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStylePopVec2(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_style_pop_vec2(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStylePopStyleItem(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_style_pop_style_item(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStylePopFlags(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_style_pop_flags(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStylePopColor(::nuklear::NkContext^ _0)
{
    auto __arg0 = (struct ::nk_context*)_0->NativePtr;
    auto ___ret = ::nk_style_pop_color(__arg0);
    return ___ret;
}

::nuklear::NkColor^ nuklear::nuklear::NkRgb(int r, int g, int b)
{
    auto ___ret = ::nk_rgb(r, g, b);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbIv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% rgb)
{
    int __arg0 = rgb;
    auto ___ret = ::nk_rgb_iv(&__arg0);
    rgb = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbBv(unsigned char* rgb)
{
    auto __arg0 = (nk_byte*)rgb;
    auto ___ret = ::nk_rgb_bv(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbF(float r, float g, float b)
{
    auto ___ret = ::nk_rgb_f(r, g, b);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% rgb)
{
    float __arg0 = rgb;
    auto ___ret = ::nk_rgb_fv(&__arg0);
    rgb = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbCf(::nuklear::NkColorf^ c)
{
    if (ReferenceEquals(c, nullptr))
        throw gcnew ::System::ArgumentNullException("c", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_colorf*)c->NativePtr;
    auto ___ret = ::nk_rgb_cf(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbHex(::System::String^ rgb)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(rgb);
    auto __arg0 = ___arg0.c_str();
    auto ___ret = ::nk_rgb_hex(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgba(int r, int g, int b, int a)
{
    auto ___ret = ::nk_rgba(r, g, b, a);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaU32(unsigned int _0)
{
    auto __arg0 = _0;
    auto ___ret = ::nk_rgba_u32(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaIv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% rgba)
{
    int __arg0 = rgba;
    auto ___ret = ::nk_rgba_iv(&__arg0);
    rgba = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaBv(unsigned char* rgba)
{
    auto __arg0 = (nk_byte*)rgba;
    auto ___ret = ::nk_rgba_bv(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaF(float r, float g, float b, float a)
{
    auto ___ret = ::nk_rgba_f(r, g, b, a);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% rgba)
{
    float __arg0 = rgba;
    auto ___ret = ::nk_rgba_fv(&__arg0);
    rgba = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaCf(::nuklear::NkColorf^ c)
{
    if (ReferenceEquals(c, nullptr))
        throw gcnew ::System::ArgumentNullException("c", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_colorf*)c->NativePtr;
    auto ___ret = ::nk_rgba_cf(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkRgbaHex(::System::String^ rgb)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(rgb);
    auto __arg0 = ___arg0.c_str();
    auto ___ret = ::nk_rgba_hex(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColorf^ nuklear::nuklear::NkHsvaColorf(float h, float s, float v, float a)
{
    auto ___ret = ::nk_hsva_colorf(h, s, v, a);
    auto _____ret = new struct ::nk_colorf(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColorf((struct ::nk_colorf*)_____ret, true);
}

::nuklear::NkColorf^ nuklear::nuklear::NkHsvaColorfv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% c)
{
    float __arg0 = c;
    auto ___ret = ::nk_hsva_colorfv(&__arg0);
    c = __arg0;
    auto _____ret = new struct ::nk_colorf(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColorf((struct ::nk_colorf*)_____ret, true);
}

void nuklear::nuklear::NkColorfHsvaF([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_h, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_s, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_v, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_a, ::nuklear::NkColorf^ in)
{
    float __arg0 = out_h;
    float __arg1 = out_s;
    float __arg2 = out_v;
    float __arg3 = out_a;
    if (ReferenceEquals(in, nullptr))
        throw gcnew ::System::ArgumentNullException("in", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_colorf*)in->NativePtr;
    ::nk_colorf_hsva_f(&__arg0, &__arg1, &__arg2, &__arg3, __arg4);
    out_h = __arg0;
    out_s = __arg1;
    out_v = __arg2;
    out_a = __arg3;
}

void nuklear::nuklear::NkColorfHsvaFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% hsva, ::nuklear::NkColorf^ in)
{
    float __arg0 = hsva;
    if (ReferenceEquals(in, nullptr))
        throw gcnew ::System::ArgumentNullException("in", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_colorf*)in->NativePtr;
    ::nk_colorf_hsva_fv(&__arg0, __arg1);
    hsva = __arg0;
}

::nuklear::NkColor^ nuklear::nuklear::NkHsv(int h, int s, int v)
{
    auto ___ret = ::nk_hsv(h, s, v);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvIv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% hsv)
{
    int __arg0 = hsv;
    auto ___ret = ::nk_hsv_iv(&__arg0);
    hsv = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvBv(unsigned char* hsv)
{
    auto __arg0 = (nk_byte*)hsv;
    auto ___ret = ::nk_hsv_bv(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvF(float h, float s, float v)
{
    auto ___ret = ::nk_hsv_f(h, s, v);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% hsv)
{
    float __arg0 = hsv;
    auto ___ret = ::nk_hsv_fv(&__arg0);
    hsv = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsva(int h, int s, int v, int a)
{
    auto ___ret = ::nk_hsva(h, s, v, a);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvaIv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% hsva)
{
    int __arg0 = hsva;
    auto ___ret = ::nk_hsva_iv(&__arg0);
    hsva = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvaBv(unsigned char* hsva)
{
    auto __arg0 = (nk_byte*)hsva;
    auto ___ret = ::nk_hsva_bv(__arg0);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvaF(float h, float s, float v, float a)
{
    auto ___ret = ::nk_hsva_f(h, s, v, a);
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

::nuklear::NkColor^ nuklear::nuklear::NkHsvaFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% hsva)
{
    float __arg0 = hsva;
    auto ___ret = ::nk_hsva_fv(&__arg0);
    hsva = __arg0;
    auto _____ret = new struct ::nk_color(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColor((struct ::nk_color*)_____ret, true);
}

void nuklear::nuklear::NkColorF([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% r, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% g, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% b, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% a, ::nuklear::NkColor^ _0)
{
    float __arg0 = r;
    float __arg1 = g;
    float __arg2 = b;
    float __arg3 = a;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_f(&__arg0, &__arg1, &__arg2, &__arg3, __arg4);
    r = __arg0;
    g = __arg1;
    b = __arg2;
    a = __arg3;
}

void nuklear::nuklear::NkColorFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% rgba_out, ::nuklear::NkColor^ _0)
{
    float __arg0 = rgba_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_fv(&__arg0, __arg1);
    rgba_out = __arg0;
}

::nuklear::NkColorf^ nuklear::nuklear::NkColorCf(::nuklear::NkColor^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_color*)_0->NativePtr;
    auto ___ret = ::nk_color_cf(__arg0);
    auto _____ret = new struct ::nk_colorf(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkColorf((struct ::nk_colorf*)_____ret, true);
}

void nuklear::nuklear::NkColorD([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% r, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% g, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% b, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% a, ::nuklear::NkColor^ _0)
{
    double __arg0 = r;
    double __arg1 = g;
    double __arg2 = b;
    double __arg3 = a;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_d(&__arg0, &__arg1, &__arg2, &__arg3, __arg4);
    r = __arg0;
    g = __arg1;
    b = __arg2;
    a = __arg3;
}

void nuklear::nuklear::NkColorDv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] double% rgba_out, ::nuklear::NkColor^ _0)
{
    double __arg0 = rgba_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_dv(&__arg0, __arg1);
    rgba_out = __arg0;
}

unsigned int nuklear::nuklear::NkColorU32(::nuklear::NkColor^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_color*)_0->NativePtr;
    auto ___ret = ::nk_color_u32(__arg0);
    return ___ret;
}

void nuklear::nuklear::NkColorHexRgba(char* output, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (char*)output;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hex_rgba(__arg0, __arg1);
}

void nuklear::nuklear::NkColorHexRgb(char* output, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (char*)output;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hex_rgb(__arg0, __arg1);
}

void nuklear::nuklear::NkColorHsvI([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% out_h, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% out_s, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% out_v, ::nuklear::NkColor^ _0)
{
    int __arg0 = out_h;
    int __arg1 = out_s;
    int __arg2 = out_v;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsv_i(&__arg0, &__arg1, &__arg2, __arg3);
    out_h = __arg0;
    out_s = __arg1;
    out_v = __arg2;
}

void nuklear::nuklear::NkColorHsvB(unsigned char* out_h, unsigned char* out_s, unsigned char* out_v, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (nk_byte*)out_h;
    auto __arg1 = (nk_byte*)out_s;
    auto __arg2 = (nk_byte*)out_v;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsv_b(__arg0, __arg1, __arg2, __arg3);
}

void nuklear::nuklear::NkColorHsvIv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% hsv_out, ::nuklear::NkColor^ _0)
{
    int __arg0 = hsv_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsv_iv(&__arg0, __arg1);
    hsv_out = __arg0;
}

void nuklear::nuklear::NkColorHsvBv(unsigned char* hsv_out, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (nk_byte*)hsv_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsv_bv(__arg0, __arg1);
}

void nuklear::nuklear::NkColorHsvF([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_h, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_s, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_v, ::nuklear::NkColor^ _0)
{
    float __arg0 = out_h;
    float __arg1 = out_s;
    float __arg2 = out_v;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsv_f(&__arg0, &__arg1, &__arg2, __arg3);
    out_h = __arg0;
    out_s = __arg1;
    out_v = __arg2;
}

void nuklear::nuklear::NkColorHsvFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% hsv_out, ::nuklear::NkColor^ _0)
{
    float __arg0 = hsv_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsv_fv(&__arg0, __arg1);
    hsv_out = __arg0;
}

void nuklear::nuklear::NkColorHsvaI([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% h, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% s, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% v, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% a, ::nuklear::NkColor^ _0)
{
    int __arg0 = h;
    int __arg1 = s;
    int __arg2 = v;
    int __arg3 = a;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsva_i(&__arg0, &__arg1, &__arg2, &__arg3, __arg4);
    h = __arg0;
    s = __arg1;
    v = __arg2;
    a = __arg3;
}

void nuklear::nuklear::NkColorHsvaB(unsigned char* h, unsigned char* s, unsigned char* v, unsigned char* a, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (nk_byte*)h;
    auto __arg1 = (nk_byte*)s;
    auto __arg2 = (nk_byte*)v;
    auto __arg3 = (nk_byte*)a;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsva_b(__arg0, __arg1, __arg2, __arg3, __arg4);
}

void nuklear::nuklear::NkColorHsvaIv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% hsva_out, ::nuklear::NkColor^ _0)
{
    int __arg0 = hsva_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsva_iv(&__arg0, __arg1);
    hsva_out = __arg0;
}

void nuklear::nuklear::NkColorHsvaBv(unsigned char* hsva_out, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (nk_byte*)hsva_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsva_bv(__arg0, __arg1);
}

void nuklear::nuklear::NkColorHsvaF([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_h, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_s, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_v, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% out_a, ::nuklear::NkColor^ _0)
{
    float __arg0 = out_h;
    float __arg1 = out_s;
    float __arg2 = out_v;
    float __arg3 = out_a;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsva_f(&__arg0, &__arg1, &__arg2, &__arg3, __arg4);
    out_h = __arg0;
    out_s = __arg1;
    out_v = __arg2;
    out_a = __arg3;
}

void nuklear::nuklear::NkColorHsvaFv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% hsva_out, ::nuklear::NkColor^ _0)
{
    float __arg0 = hsva_out;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_color_hsva_fv(&__arg0, __arg1);
    hsva_out = __arg0;
}

::nuklear::NkHandle nuklear::nuklear::NkHandlePtr(::System::IntPtr _0)
{
    auto __arg0 = (void*)_0;
    auto ___ret = ::nk_handle_ptr(__arg0);
    return ::nuklear::NkHandle((::nk_handle*)&___ret);
}

::nuklear::NkHandle nuklear::nuklear::NkHandleId(int _0)
{
    auto ___ret = ::nk_handle_id(_0);
    return ::nuklear::NkHandle((::nk_handle*)&___ret);
}

::nuklear::NkImage^ nuklear::nuklear::NkImageHandle(::nuklear::NkHandle _0)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)_0.Ptr;
    _marshal0.id = _0.Id;
    auto __arg0 = _marshal0;
    auto ___ret = ::nk_image_handle(__arg0);
    auto _____ret = new struct ::nk_image(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)_____ret, true);
}

::nuklear::NkImage^ nuklear::nuklear::NkImagePtr(::System::IntPtr _0)
{
    auto __arg0 = (void*)_0;
    auto ___ret = ::nk_image_ptr(__arg0);
    auto _____ret = new struct ::nk_image(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)_____ret, true);
}

::nuklear::NkImage^ nuklear::nuklear::NkImageId(int _0)
{
    auto ___ret = ::nk_image_id(_0);
    auto _____ret = new struct ::nk_image(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)_____ret, true);
}

int nuklear::nuklear::NkImageIsSubimage(::nuklear::NkImage^ img)
{
    auto __arg0 = (struct ::nk_image*)img->NativePtr;
    auto ___ret = ::nk_image_is_subimage(__arg0);
    return ___ret;
}

::nuklear::NkImage^ nuklear::nuklear::NkSubimagePtr(::System::IntPtr _0, unsigned short w, unsigned short h, ::nuklear::NkRect^ sub_region)
{
    auto __arg0 = (void*)_0;
    if (ReferenceEquals(sub_region, nullptr))
        throw gcnew ::System::ArgumentNullException("sub_region", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_rect*)sub_region->NativePtr;
    auto ___ret = ::nk_subimage_ptr(__arg0, w, h, __arg3);
    auto _____ret = new struct ::nk_image(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)_____ret, true);
}

::nuklear::NkImage^ nuklear::nuklear::NkSubimageId(int _0, unsigned short w, unsigned short h, ::nuklear::NkRect^ sub_region)
{
    if (ReferenceEquals(sub_region, nullptr))
        throw gcnew ::System::ArgumentNullException("sub_region", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_rect*)sub_region->NativePtr;
    auto ___ret = ::nk_subimage_id(_0, w, h, __arg3);
    auto _____ret = new struct ::nk_image(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)_____ret, true);
}

::nuklear::NkImage^ nuklear::nuklear::NkSubimageHandle(::nuklear::NkHandle _0, unsigned short w, unsigned short h, ::nuklear::NkRect^ sub_region)
{
    auto _marshal0 = ::nk_handle();
    _marshal0.ptr = (void*)_0.Ptr;
    _marshal0.id = _0.Id;
    auto __arg0 = _marshal0;
    if (ReferenceEquals(sub_region, nullptr))
        throw gcnew ::System::ArgumentNullException("sub_region", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_rect*)sub_region->NativePtr;
    auto ___ret = ::nk_subimage_handle(__arg0, w, h, __arg3);
    auto _____ret = new struct ::nk_image(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkImage((struct ::nk_image*)_____ret, true);
}

unsigned int nuklear::nuklear::NkMurmurHash(::System::IntPtr key, int len, unsigned int seed)
{
    auto __arg0 = (const void*)key;
    auto __arg2 = seed;
    auto ___ret = ::nk_murmur_hash(__arg0, len, __arg2);
    return ___ret;
}

void nuklear::nuklear::NkTriangleFromDirection(::nuklear::NkVec2^ result, ::nuklear::NkRect^ r, float pad_x, float pad_y, ::nuklear::NkHeading _0)
{
    auto __arg0 = (struct ::nk_vec2*)result->NativePtr;
    if (ReferenceEquals(r, nullptr))
        throw gcnew ::System::ArgumentNullException("r", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)r->NativePtr;
    auto __arg4 = (enum ::nk_heading)_0;
    ::nk_triangle_from_direction(__arg0, __arg1, pad_x, pad_y, __arg4);
}

::nuklear::NkVec2^ nuklear::nuklear::nk_vec2(float x, float y)
{
    auto ___ret = ::nk_vec2(x, y);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::nk_vec2i(int x, int y)
{
    auto ___ret = ::nk_vec2i(x, y);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkVec2v([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% xy)
{
    float __arg0 = xy;
    auto ___ret = ::nk_vec2v(&__arg0);
    xy = __arg0;
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkVec2iv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% xy)
{
    int __arg0 = xy;
    auto ___ret = ::nk_vec2iv(&__arg0);
    xy = __arg0;
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::NkGetNullRect()
{
    auto ___ret = ::nk_get_null_rect();
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::nk_rect(float x, float y, float w, float h)
{
    auto ___ret = ::nk_rect(x, y, w, h);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::nk_recti(int x, int y, int w, int h)
{
    auto ___ret = ::nk_recti(x, y, w, h);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::NkRecta(::nuklear::NkVec2^ pos, ::nuklear::NkVec2^ size)
{
    if (ReferenceEquals(pos, nullptr))
        throw gcnew ::System::ArgumentNullException("pos", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_vec2*)pos->NativePtr;
    if (ReferenceEquals(size, nullptr))
        throw gcnew ::System::ArgumentNullException("size", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_vec2*)size->NativePtr;
    auto ___ret = ::nk_recta(__arg0, __arg1);
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::NkRectv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% xywh)
{
    float __arg0 = xywh;
    auto ___ret = ::nk_rectv(&__arg0);
    xywh = __arg0;
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkRect^ nuklear::nuklear::NkRectiv([::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% xywh)
{
    int __arg0 = xywh;
    auto ___ret = ::nk_rectiv(&__arg0);
    xywh = __arg0;
    auto _____ret = new struct ::nk_rect(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkRect((struct ::nk_rect*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkRectPos(::nuklear::NkRect^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_rect*)_0->NativePtr;
    auto ___ret = ::nk_rect_pos(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

::nuklear::NkVec2^ nuklear::nuklear::NkRectSize(::nuklear::NkRect^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_rect*)_0->NativePtr;
    auto ___ret = ::nk_rect_size(__arg0);
    auto _____ret = new struct ::nk_vec2(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkVec2((struct ::nk_vec2*)_____ret, true);
}

int nuklear::nuklear::NkStrlen(::System::String^ str)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    auto __arg0 = ___arg0.c_str();
    auto ___ret = ::nk_strlen(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStricmp(::System::String^ s1, ::System::String^ s2)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(s1);
    auto __arg0 = ___arg0.c_str();
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(s2);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_stricmp(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkStricmpn(::System::String^ s1, ::System::String^ s2, int n)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(s1);
    auto __arg0 = ___arg0.c_str();
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(s2);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_stricmpn(__arg0, __arg1, n);
    return ___ret;
}

int nuklear::nuklear::NkStrtoi(::System::String^ str, ::System::String^* endptr)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    auto __arg0 = ___arg0.c_str();
    auto __arg1 = (const char**)endptr; // replace de (void*) à (const char**)
    auto ___ret = ::nk_strtoi(__arg0, __arg1);
    return ___ret;
}

float nuklear::nuklear::NkStrtof(::System::String^ str, ::System::String^* endptr)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    auto __arg0 = ___arg0.c_str();
    auto __arg1 = (const char**)endptr; // replace de (void*) à (const char**)
    auto ___ret = ::nk_strtof(__arg0, __arg1);
    return ___ret;
}

double nuklear::nuklear::NkStrtod(::System::String^ str, ::System::String^* endptr)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    auto __arg0 = ___arg0.c_str();
    auto __arg1 = (const char**)endptr; // replace de (void*) à (const char**)
    auto ___ret = ::nk_strtod(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkStrfilter(::System::String^ text, ::System::String^ regexp)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(text);
    auto __arg0 = ___arg0.c_str();
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(regexp);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_strfilter(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkStrmatchFuzzyString(::System::String^ str, ::System::String^ pattern, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% out_score)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    auto __arg0 = ___arg0.c_str();
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(pattern);
    auto __arg1 = ___arg1.c_str();
    int __arg2 = out_score;
    auto ___ret = ::nk_strmatch_fuzzy_string(__arg0, __arg1, &__arg2);
    out_score = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkStrmatchFuzzyText(::System::String^ txt, int txt_len, ::System::String^ pattern, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% out_score)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(txt);
    auto __arg0 = ___arg0.c_str();
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(pattern);
    auto __arg2 = ___arg2.c_str();
    int __arg3 = out_score;
    auto ___ret = ::nk_strmatch_fuzzy_text(__arg0, txt_len, __arg2, &__arg3);
    out_score = __arg3;
    return ___ret;
}

int nuklear::nuklear::NkUtfDecode(::System::String^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% _1, int _2)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(_0);
    auto __arg0 = ___arg0.c_str();
    nk_rune __arg1 = (::nk_rune)(::nk_uint)_1;
    auto ___ret = ::nk_utf_decode(__arg0, &__arg1, _2);
    _1 = __arg1;
    return ___ret;
}

int nuklear::nuklear::NkUtfEncode(unsigned int _0, char* _1, int _2)
{
    auto __arg0 = _0;
    auto __arg1 = (char*)_1;
    auto ___ret = ::nk_utf_encode(__arg0, __arg1, _2);
    return ___ret;
}

int nuklear::nuklear::NkUtfLen(::System::String^ _0, int byte_len)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(_0);
    auto __arg0 = ___arg0.c_str();
    auto ___ret = ::nk_utf_len(__arg0, byte_len);
    return ___ret;
}

::System::String^ nuklear::nuklear::NkUtfAt(::System::String^ buffer, int length, int index, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% unicode, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% len)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(buffer);
    auto __arg0 = ___arg0.c_str();
    nk_rune __arg3 = (::nk_rune)(::nk_uint)unicode;
    int __arg4 = len;
    auto ___ret = ::nk_utf_at(__arg0, length, index, &__arg3, &__arg4);
    unicode = __arg3;
    len = __arg4;
    if (___ret == nullptr) return nullptr;
    return (___ret == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(___ret));
}

void nuklear::nuklear::NkBufferInit(::nuklear::NkBuffer^ _0, ::nuklear::NkAllocator^ _1, unsigned long long size)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto __arg1 = (struct ::nk_allocator*)_1->NativePtr;
    auto __arg2 = size;
    ::nk_buffer_init(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkBufferInitFixed(::nuklear::NkBuffer^ _0, ::System::IntPtr memory, unsigned long long size)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto __arg1 = (void*)memory;
    auto __arg2 = size;
    ::nk_buffer_init_fixed(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkBufferInfo(::nuklear::NkMemoryStatus^ _0, ::nuklear::NkBuffer^ _1)
{
    auto __arg0 = (struct ::nk_memory_status*)_0->NativePtr;
    auto __arg1 = (struct ::nk_buffer*)_1->NativePtr;
    ::nk_buffer_info(__arg0, __arg1);
}

void nuklear::nuklear::NkBufferPush(::nuklear::NkBuffer^ _0, ::nuklear::NkBufferAllocationType type, ::System::IntPtr memory, unsigned long long size, unsigned long long align)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buffer_allocation_type)type;
    auto __arg2 = (const void*)memory;
    auto __arg3 = size;
    auto __arg4 = align;
    ::nk_buffer_push(__arg0, __arg1, __arg2, __arg3, __arg4);
}

void nuklear::nuklear::NkBufferMark(::nuklear::NkBuffer^ _0, ::nuklear::NkBufferAllocationType type)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buffer_allocation_type)type;
    ::nk_buffer_mark(__arg0, __arg1);
}

void nuklear::nuklear::NkBufferReset(::nuklear::NkBuffer^ _0, ::nuklear::NkBufferAllocationType type)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buffer_allocation_type)type;
    ::nk_buffer_reset(__arg0, __arg1);
}

void nuklear::nuklear::NkBufferClear(::nuklear::NkBuffer^ _0)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    ::nk_buffer_clear(__arg0);
}

void nuklear::nuklear::NkBufferFree(::nuklear::NkBuffer^ _0)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    ::nk_buffer_free(__arg0);
}

::System::IntPtr nuklear::nuklear::NkBufferMemory(::nuklear::NkBuffer^ _0)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto ___ret = ::nk_buffer_memory(__arg0);
    if (___ret == nullptr) return ::System::IntPtr();
    return ::System::IntPtr(___ret);
}

::System::IntPtr nuklear::nuklear::NkBufferMemoryConst(::nuklear::NkBuffer^ _0)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto ___ret = ::nk_buffer_memory_const(__arg0);
    if (___ret == nullptr) return ::System::IntPtr();
    return ::System::IntPtr(const_cast<void*>(___ret));
}

unsigned long long nuklear::nuklear::NkBufferTotal(::nuklear::NkBuffer^ _0)
{
    auto __arg0 = (struct ::nk_buffer*)_0->NativePtr;
    auto ___ret = ::nk_buffer_total(__arg0);
    return ___ret;
}

void nuklear::nuklear::NkStrInit(::nuklear::NkStr^ _0, ::nuklear::NkAllocator^ _1, unsigned long long size)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto __arg1 = (struct ::nk_allocator*)_1->NativePtr;
    auto __arg2 = size;
    ::nk_str_init(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkStrInitFixed(::nuklear::NkStr^ _0, ::System::IntPtr memory, unsigned long long size)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto __arg1 = (void*)memory;
    auto __arg2 = size;
    ::nk_str_init_fixed(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkStrClear(::nuklear::NkStr^ _0)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    ::nk_str_clear(__arg0);
}

void nuklear::nuklear::NkStrFree(::nuklear::NkStr^ _0)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    ::nk_str_free(__arg0);
}

int nuklear::nuklear::NkStrAppendTextChar(::nuklear::NkStr^ _0, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_str_append_text_char(__arg0, __arg1, _2);
    return ___ret;
}

int nuklear::nuklear::NkStrAppendStrChar(::nuklear::NkStr^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_str_append_str_char(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkStrAppendTextUtf8(::nuklear::NkStr^ _0, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_str_append_text_utf8(__arg0, __arg1, _2);
    return ___ret;
}

int nuklear::nuklear::NkStrAppendStrUtf8(::nuklear::NkStr^ _0, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_str_append_str_utf8(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkStrAppendTextRunes(::nuklear::NkStr^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    nk_rune __arg1 = (::nk_rune)(::nk_uint)_1;
    auto ___ret = ::nk_str_append_text_runes(__arg0, &__arg1, _2);
    _1 = __arg1;
    return ___ret;
}

int nuklear::nuklear::NkStrAppendStrRunes(::nuklear::NkStr^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% _1)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    nk_rune __arg1 = (::nk_rune)(::nk_uint)_1;
    auto ___ret = ::nk_str_append_str_runes(__arg0, &__arg1);
    _1 = __arg1;
    return ___ret;
}

int nuklear::nuklear::NkStrInsertAtChar(::nuklear::NkStr^ _0, int pos, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_str_insert_at_char(__arg0, pos, __arg2, _2);
    return ___ret;
}

int nuklear::nuklear::NkStrInsertAtRune(::nuklear::NkStr^ _0, int pos, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_str_insert_at_rune(__arg0, pos, __arg2, _2);
    return ___ret;
}

int nuklear::nuklear::NkStrInsertTextChar(::nuklear::NkStr^ _0, int pos, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_str_insert_text_char(__arg0, pos, __arg2, _2);
    return ___ret;
}

int nuklear::nuklear::NkStrInsertStrChar(::nuklear::NkStr^ _0, int pos, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_str_insert_str_char(__arg0, pos, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkStrInsertTextUtf8(::nuklear::NkStr^ _0, int pos, ::System::String^ _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_str_insert_text_utf8(__arg0, pos, __arg2, _2);
    return ___ret;
}

int nuklear::nuklear::NkStrInsertStrUtf8(::nuklear::NkStr^ _0, int pos, ::System::String^ _1)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg2 = ___arg2.c_str();
    auto ___ret = ::nk_str_insert_str_utf8(__arg0, pos, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkStrInsertTextRunes(::nuklear::NkStr^ _0, int pos, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% _1, int _2)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    nk_rune __arg2 = (::nk_rune)(::nk_uint)_1;
    auto ___ret = ::nk_str_insert_text_runes(__arg0, pos, &__arg2, _2);
    _1 = __arg2;
    return ___ret;
}

int nuklear::nuklear::NkStrInsertStrRunes(::nuklear::NkStr^ _0, int pos, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% _1)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    nk_rune __arg2 = (::nk_rune)(::nk_uint)_1;
    auto ___ret = ::nk_str_insert_str_runes(__arg0, pos, &__arg2);
    _1 = __arg2;
    return ___ret;
}

void nuklear::nuklear::NkStrRemoveChars(::nuklear::NkStr^ _0, int len)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    ::nk_str_remove_chars(__arg0, len);
}

void nuklear::nuklear::NkStrRemoveRunes(::nuklear::NkStr^ str, int len)
{
    auto __arg0 = (struct ::nk_str*)str->NativePtr;
    ::nk_str_remove_runes(__arg0, len);
}

void nuklear::nuklear::NkStrDeleteChars(::nuklear::NkStr^ _0, int pos, int len)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    ::nk_str_delete_chars(__arg0, pos, len);
}

void nuklear::nuklear::NkStrDeleteRunes(::nuklear::NkStr^ _0, int pos, int len)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    ::nk_str_delete_runes(__arg0, pos, len);
}

char* nuklear::nuklear::NkStrAtChar(::nuklear::NkStr^ _0, int pos)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_at_char(__arg0, pos);
    return ___ret;
}

char* nuklear::nuklear::NkStrAtRune(::nuklear::NkStr^ _0, int pos, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% unicode, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% len)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    nk_rune __arg2 = (::nk_rune)(::nk_uint)unicode;
    int __arg3 = len;
    auto ___ret = ::nk_str_at_rune(__arg0, pos, &__arg2, &__arg3);
    unicode = __arg2;
    len = __arg3;
    return ___ret;
}

unsigned int nuklear::nuklear::NkStrRuneAt(::nuklear::NkStr^ _0, int pos)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_rune_at(__arg0, pos);
    return ___ret;
}

::System::String^ nuklear::nuklear::NkStrAtCharConst(::nuklear::NkStr^ _0, int pos)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_at_char_const(__arg0, pos);
    if (___ret == nullptr) return nullptr;
    return (___ret == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(___ret));
}

::System::String^ nuklear::nuklear::NkStrAtConst(::nuklear::NkStr^ _0, int pos, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] unsigned int% unicode, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] int% len)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    nk_rune __arg2 = (::nk_rune)(::nk_uint)unicode;
    int __arg3 = len;
    auto ___ret = ::nk_str_at_const(__arg0, pos, &__arg2, &__arg3);
    unicode = __arg2;
    len = __arg3;
    if (___ret == nullptr) return nullptr;
    return (___ret == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(___ret));
}

char* nuklear::nuklear::NkStrGet(::nuklear::NkStr^ _0)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_get(__arg0);
    return ___ret;
}

::System::String^ nuklear::nuklear::NkStrGetConst(::nuklear::NkStr^ _0)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_get_const(__arg0);
    if (___ret == nullptr) return nullptr;
    return (___ret == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(___ret));
}

int nuklear::nuklear::NkStrLen(::nuklear::NkStr^ _0)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_len(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkStrLenChar(::nuklear::NkStr^ _0)
{
    auto __arg0 = (struct ::nk_str*)_0->NativePtr;
    auto ___ret = ::nk_str_len_char(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkFilterDefault(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_default(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkFilterAscii(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_ascii(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkFilterFloat(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_float(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkFilterDecimal(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_decimal(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkFilterHex(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_hex(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkFilterOct(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_oct(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkFilterBinary(::nuklear::NkTextEdit^ _0, unsigned int unicode)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = unicode;
    auto ___ret = ::nk_filter_binary(__arg0, __arg1);
    return ___ret;
}

void nuklear::nuklear::NkTexteditInit(::nuklear::NkTextEdit^ _0, ::nuklear::NkAllocator^ _1, unsigned long long size)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = (struct ::nk_allocator*)_1->NativePtr;
    auto __arg2 = size;
    ::nk_textedit_init(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkTexteditInitFixed(::nuklear::NkTextEdit^ _0, ::System::IntPtr memory, unsigned long long size)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto __arg1 = (void*)memory;
    auto __arg2 = size;
    ::nk_textedit_init_fixed(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkTexteditFree(::nuklear::NkTextEdit^ _0)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    ::nk_textedit_free(__arg0);
}

void nuklear::nuklear::NkTexteditText(::nuklear::NkTextEdit^ _0, ::System::String^ _1, int total_len)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    ::nk_textedit_text(__arg0, __arg1, total_len);
}

void nuklear::nuklear::NkTexteditDelete(::nuklear::NkTextEdit^ _0, int where, int len)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    ::nk_textedit_delete(__arg0, where, len);
}

void nuklear::nuklear::NkTexteditDeleteSelection(::nuklear::NkTextEdit^ _0)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    ::nk_textedit_delete_selection(__arg0);
}

void nuklear::nuklear::NkTexteditSelectAll(::nuklear::NkTextEdit^ _0)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    ::nk_textedit_select_all(__arg0);
}

int nuklear::nuklear::NkTexteditCut(::nuklear::NkTextEdit^ _0)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto ___ret = ::nk_textedit_cut(__arg0);
    return ___ret;
}

int nuklear::nuklear::NkTexteditPaste(::nuklear::NkTextEdit^ _0, ::System::String^ _1, int len)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    auto ___arg1 = clix::marshalString<clix::E_UTF8>(_1);
    auto __arg1 = ___arg1.c_str();
    auto ___ret = ::nk_textedit_paste(__arg0, __arg1, len);
    return ___ret;
}

void nuklear::nuklear::NkTexteditUndo(::nuklear::NkTextEdit^ _0)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    ::nk_textedit_undo(__arg0);
}

void nuklear::nuklear::NkTexteditRedo(::nuklear::NkTextEdit^ _0)
{
    auto __arg0 = (struct ::nk_text_edit*)_0->NativePtr;
    ::nk_textedit_redo(__arg0);
}

void nuklear::nuklear::NkStrokeLine(::nuklear::NkCommandBuffer^ b, float x0, float y0, float x1, float y1, float line_thickness, ::nuklear::NkColor^ _0)
{
    auto __arg0 = (struct ::nk_command_buffer*)b->NativePtr;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_color*)_0->NativePtr;
    ::nk_stroke_line(__arg0, x0, y0, x1, y1, line_thickness, __arg6);
}

void nuklear::nuklear::NkStrokeCurve(::nuklear::NkCommandBuffer^ _0, float _1, float _2, float _3, float _4, float _5, float _6, float _7, float _8, float line_thickness, ::nuklear::NkColor^ _9)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_9, nullptr))
        throw gcnew ::System::ArgumentNullException("_9", "Cannot be null because it is passed by value.");
    auto __arg10 = *(struct ::nk_color*)_9->NativePtr;
    ::nk_stroke_curve(__arg0, _1, _2, _3, _4, _5, _6, _7, _8, line_thickness, __arg10);
}

void nuklear::nuklear::NkStrokeRect(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, float rounding, float line_thickness, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_stroke_rect(__arg0, __arg1, rounding, line_thickness, __arg4);
}

void nuklear::nuklear::NkStrokeCircle(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, float line_thickness, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_stroke_circle(__arg0, __arg1, line_thickness, __arg3);
}

void nuklear::nuklear::NkStrokeArc(::nuklear::NkCommandBuffer^ _0, float cx, float cy, float radius, float a_min, float a_max, float line_thickness, ::nuklear::NkColor^ _1)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg7 = *(struct ::nk_color*)_1->NativePtr;
    ::nk_stroke_arc(__arg0, cx, cy, radius, a_min, a_max, line_thickness, __arg7);
}

void nuklear::nuklear::NkStrokeTriangle(::nuklear::NkCommandBuffer^ _0, float _1, float _2, float _3, float _4, float _5, float _6, float line_thichness, ::nuklear::NkColor^ _7)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_7, nullptr))
        throw gcnew ::System::ArgumentNullException("_7", "Cannot be null because it is passed by value.");
    auto __arg8 = *(struct ::nk_color*)_7->NativePtr;
    ::nk_stroke_triangle(__arg0, _1, _2, _3, _4, _5, _6, line_thichness, __arg8);
}

void nuklear::nuklear::NkStrokePolyline(::nuklear::NkCommandBuffer^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% points, int point_count, float line_thickness, ::nuklear::NkColor^ col)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    float __arg1 = points;
    if (ReferenceEquals(col, nullptr))
        throw gcnew ::System::ArgumentNullException("col", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)col->NativePtr;
    ::nk_stroke_polyline(__arg0, &__arg1, point_count, line_thickness, __arg4);
    points = __arg1;
}

void nuklear::nuklear::NkStrokePolygon(::nuklear::NkCommandBuffer^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% _1, int point_count, float line_thickness, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    float __arg1 = _1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_stroke_polygon(__arg0, &__arg1, point_count, line_thickness, __arg4);
    _1 = __arg1;
}

void nuklear::nuklear::NkFillRect(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, float rounding, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_fill_rect(__arg0, __arg1, rounding, __arg3);
}

void nuklear::nuklear::NkFillRectMultiColor(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, ::nuklear::NkColor^ left, ::nuklear::NkColor^ top, ::nuklear::NkColor^ right, ::nuklear::NkColor^ bottom)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    if (ReferenceEquals(left, nullptr))
        throw gcnew ::System::ArgumentNullException("left", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)left->NativePtr;
    if (ReferenceEquals(top, nullptr))
        throw gcnew ::System::ArgumentNullException("top", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)top->NativePtr;
    if (ReferenceEquals(right, nullptr))
        throw gcnew ::System::ArgumentNullException("right", "Cannot be null because it is passed by value.");
    auto __arg4 = *(struct ::nk_color*)right->NativePtr;
    if (ReferenceEquals(bottom, nullptr))
        throw gcnew ::System::ArgumentNullException("bottom", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_color*)bottom->NativePtr;
    ::nk_fill_rect_multi_color(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
}

void nuklear::nuklear::NkFillCircle(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_fill_circle(__arg0, __arg1, __arg2);
}

void nuklear::nuklear::NkFillArc(::nuklear::NkCommandBuffer^ _0, float cx, float cy, float radius, float a_min, float a_max, ::nuklear::NkColor^ _1)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_color*)_1->NativePtr;
    ::nk_fill_arc(__arg0, cx, cy, radius, a_min, a_max, __arg6);
}

void nuklear::nuklear::NkFillTriangle(::nuklear::NkCommandBuffer^ _0, float x0, float y0, float x1, float y1, float x2, float y2, ::nuklear::NkColor^ _1)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg7 = *(struct ::nk_color*)_1->NativePtr;
    ::nk_fill_triangle(__arg0, x0, y0, x1, y1, x2, y2, __arg7);
}

void nuklear::nuklear::NkFillPolygon(::nuklear::NkCommandBuffer^ _0, [::System::Runtime::InteropServices::In, ::System::Runtime::InteropServices::Out] float% _1, int point_count, ::nuklear::NkColor^ _2)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    float __arg1 = _1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_2->NativePtr;
    ::nk_fill_polygon(__arg0, &__arg1, point_count, __arg3);
    _1 = __arg1;
}

void nuklear::nuklear::NkDrawImage(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, ::nuklear::NkImage^ _2, ::nuklear::NkColor^ _3)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto __arg2 = (struct ::nk_image*)_2->NativePtr;
    if (ReferenceEquals(_3, nullptr))
        throw gcnew ::System::ArgumentNullException("_3", "Cannot be null because it is passed by value.");
    auto __arg3 = *(struct ::nk_color*)_3->NativePtr;
    ::nk_draw_image(__arg0, __arg1, __arg2, __arg3);
}

void nuklear::nuklear::NkDrawText(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, ::System::String^ text, int len, ::nuklear::NkUserFont^ _2, ::nuklear::NkColor^ _3, ::nuklear::NkColor^ _4)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto ___arg2 = clix::marshalString<clix::E_UTF8>(text);
    auto __arg2 = ___arg2.c_str();
    auto __arg4 = (struct ::nk_user_font*)_2->NativePtr;
    if (ReferenceEquals(_3, nullptr))
        throw gcnew ::System::ArgumentNullException("_3", "Cannot be null because it is passed by value.");
    auto __arg5 = *(struct ::nk_color*)_3->NativePtr;
    if (ReferenceEquals(_4, nullptr))
        throw gcnew ::System::ArgumentNullException("_4", "Cannot be null because it is passed by value.");
    auto __arg6 = *(struct ::nk_color*)_4->NativePtr;
    ::nk_draw_text(__arg0, __arg1, __arg2, len, __arg4, __arg5, __arg6);
}

void nuklear::nuklear::NkPushScissor(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    ::nk_push_scissor(__arg0, __arg1);
}

void nuklear::nuklear::NkPushCustom(::nuklear::NkCommandBuffer^ _0, ::nuklear::NkRect^ _1, ::nuklear::NkCommandCustomCallback^ _2, ::nuklear::NkHandle usr)
{
    auto __arg0 = (struct ::nk_command_buffer*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto __arg2 = static_cast<::nk_command_custom_callback>(::System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(_2).ToPointer());
    auto _marshal3 = ::nk_handle();
    _marshal3.ptr = (void*)usr.Ptr;
    _marshal3.id = usr.Id;
    auto __arg3 = _marshal3;
    ::nk_push_custom(__arg0, __arg1, __arg2, __arg3);
}

int nuklear::nuklear::NkInputHasMouseClick(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    auto ___ret = ::nk_input_has_mouse_click(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputHasMouseClickInRect(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1, ::nuklear::NkRect^ _2)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)_2->NativePtr;
    auto ___ret = ::nk_input_has_mouse_click_in_rect(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkInputHasMouseClickDownInRect(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1, ::nuklear::NkRect^ _2, int down)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)_2->NativePtr;
    auto ___ret = ::nk_input_has_mouse_click_down_in_rect(__arg0, __arg1, __arg2, down);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMouseClickInRect(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1, ::nuklear::NkRect^ _2)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)_2->NativePtr;
    auto ___ret = ::nk_input_is_mouse_click_in_rect(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMouseClickDownInRect(::nuklear::NkInput^ i, ::nuklear::NkButtons id, ::nuklear::NkRect^ b, int down)
{
    auto __arg0 = (struct ::nk_input*)i->NativePtr;
    auto __arg1 = (enum ::nk_buttons)id;
    if (ReferenceEquals(b, nullptr))
        throw gcnew ::System::ArgumentNullException("b", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)b->NativePtr;
    auto ___ret = ::nk_input_is_mouse_click_down_in_rect(__arg0, __arg1, __arg2, down);
    return ___ret;
}

int nuklear::nuklear::NkInputAnyMouseClickInRect(::nuklear::NkInput^ _0, ::nuklear::NkRect^ _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto ___ret = ::nk_input_any_mouse_click_in_rect(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMousePrevHoveringRect(::nuklear::NkInput^ _0, ::nuklear::NkRect^ _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto ___ret = ::nk_input_is_mouse_prev_hovering_rect(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMouseHoveringRect(::nuklear::NkInput^ _0, ::nuklear::NkRect^ _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    if (ReferenceEquals(_1, nullptr))
        throw gcnew ::System::ArgumentNullException("_1", "Cannot be null because it is passed by value.");
    auto __arg1 = *(struct ::nk_rect*)_1->NativePtr;
    auto ___ret = ::nk_input_is_mouse_hovering_rect(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputMouseClicked(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1, ::nuklear::NkRect^ _2)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    if (ReferenceEquals(_2, nullptr))
        throw gcnew ::System::ArgumentNullException("_2", "Cannot be null because it is passed by value.");
    auto __arg2 = *(struct ::nk_rect*)_2->NativePtr;
    auto ___ret = ::nk_input_mouse_clicked(__arg0, __arg1, __arg2);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMouseDown(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    auto ___ret = ::nk_input_is_mouse_down(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMousePressed(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    auto ___ret = ::nk_input_is_mouse_pressed(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsMouseReleased(::nuklear::NkInput^ _0, ::nuklear::NkButtons _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_buttons)_1;
    auto ___ret = ::nk_input_is_mouse_released(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsKeyPressed(::nuklear::NkInput^ _0, ::nuklear::NkKeys _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_keys)_1;
    auto ___ret = ::nk_input_is_key_pressed(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsKeyReleased(::nuklear::NkInput^ _0, ::nuklear::NkKeys _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_keys)_1;
    auto ___ret = ::nk_input_is_key_released(__arg0, __arg1);
    return ___ret;
}

int nuklear::nuklear::NkInputIsKeyDown(::nuklear::NkInput^ _0, ::nuklear::NkKeys _1)
{
    auto __arg0 = (struct ::nk_input*)_0->NativePtr;
    auto __arg1 = (enum ::nk_keys)_1;
    auto ___ret = ::nk_input_is_key_down(__arg0, __arg1);
    return ___ret;
}

::nuklear::NkStyleItem^ nuklear::nuklear::NkStyleItemImage(::nuklear::NkImage^ img)
{
    if (ReferenceEquals(img, nullptr))
        throw gcnew ::System::ArgumentNullException("img", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_image*)img->NativePtr;
    auto ___ret = ::nk_style_item_image(__arg0);
    auto _____ret = new struct ::nk_style_item(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)_____ret, true);
}

::nuklear::NkStyleItem^ nuklear::nuklear::NkStyleItemColor(::nuklear::NkColor^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is passed by value.");
    auto __arg0 = *(struct ::nk_color*)_0->NativePtr;
    auto ___ret = ::nk_style_item_color(__arg0);
    auto _____ret = new struct ::nk_style_item(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)_____ret, true);
}

::nuklear::NkStyleItem^ nuklear::nuklear::NkStyleItemHide()
{
    auto ___ret = ::nk_style_item_hide();
    auto _____ret = new struct ::nk_style_item(___ret);
    return (_____ret == nullptr) ? nullptr : gcnew ::nuklear::NkStyleItem((struct ::nk_style_item*)_____ret, true);
}

::nuklear::NkContext^ nuklear::nuklear::NkCreateGlfwContext(long long* window, int max_vertex_buffer, int max_element_buffer) {
    nk_context* ctx = NuklearInternal::nk_glfw_init(window, NuklearInternal::NK_GLFW3_DEFAULT, max_vertex_buffer, max_element_buffer);

    return gcnew NkContext(ctx);
}

void nuklear::nuklear::NkBeginFontAtlas() {
    struct nk_font_atlas* atlas;
    NuklearInternal::nk_glfw_font_stash_begin(&atlas);
}

void nuklear::nuklear::NkFontAtlasAddFromFile(System::String^ path, int height) {
    nk_font_atlas_add_from_file(&NuklearInternal::glfw.atlas, str_to_char_ptr(path), height, 0);
}

void nuklear::nuklear::NkEndFontAtlas() {
    NuklearInternal::nk_glfw_font_stash_end();
}

void nuklear::nuklear::NkNewFrame() {
    NuklearInternal::nk_glfw_new_frame();
}

void nuklear::nuklear::NkRender(bool useAntiAliasing) {
    NuklearInternal::nk_glfw_render(static_cast<nk_anti_aliasing>((int)useAntiAliasing));
}

void nuklear::nuklear::NkShutdown() {
    NuklearInternal::nk_glfw_shutdown();
}