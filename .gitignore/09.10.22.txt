using System;
using System.Diagnostics.CodeAnalysis;

using Emission.IO;

namespace Emission
{
    public class Game
    {
        private static Game _instance;
        
        public Window Window;
        public Renderer Renderer;
        public Debug Debugger;
        public Data Data;

        private bool _isRunning;
        
        private Game()
        {
            _isRunning = false;
            
            EngineBehaviour.CreateDispatcher();
            Event.CreateEventDispatcher();
            
            Input.CreateInput();

            Event.AddDelegate(Event.Initialize, Initialize);
            Event.AddDelegate(Event.Start, Start);
            Event.AddDelegate(Event.Update, Update);
            Event.AddDelegate(Event.Render, Render);
            Event.AddDelegate<int>(Event.Stop, Exit);
        }

        private void Initialize()
        {
            Window ??= CreateWindow("Window");
            Renderer ??= CreateRenderer();
            Debugger ??= CreateDebugger("Emission Console");
            Data ??= new Data();
            
            Window.Initialize();
            EngineBehaviour.Call(Event.Initialize);
        }
        
        private void Start()
        {
            Window.Start();
            EngineBehaviour.Call(Event.Start);
            
            if (!_isRunning)
            {
                Loop();
            }
        }
        
        private void Loop()
        {
            _isRunning = true;
            double totalElapsedTime = 0, previousTime = Time.CurrentTime;
            int frameCount = 0;

            while (!Window.ShouldClose)
            {
                Time.SetDeltaTime(Time.CurrentTime - totalElapsedTime);
                totalElapsedTime = Time.CurrentTime;

                frameCount++;
                if (Time.CurrentTime - previousTime >= 1.0)
                {
                    Time.SetFps(frameCount);
                    frameCount = 0;
                    previousTime = Time.CurrentTime;
                }

                Window.Update();
                Event.Invoke(Event.Update);
                
                Window.Render();
                Event.Invoke(Event.Render);

                Window.Flush();
            }
            
            Exit(0);
        }

        private void Update()
        {
            EngineBehaviour.Call(Event.Update);
        }

        private void Render()
        {
            EngineBehaviour.Call(Event.Render);
        }
        
        private void Exit(int status)
        {
            // Call Stop Event
            EngineBehaviour.Call(Event.Stop);
            Window.Stop();

            // Dispose Observators
            Event.DisposeEventDispatcher();
            EngineBehaviour.RemoveDispatcher();
            
            Debug.Log($"[INFO] Application stopped with exit code: {status}!");
            
            // Exit Application
            Environment.Exit(status);
        }

        /* Fabricator Methods */
        public static Window CreateWindow([NotNull]WindowParameters parameters)
        {
            _instance.Window = new Window(parameters);
            return _instance.Window;
        }
        public static Window CreateWindow([NotNull]string name) => CreateWindow(WindowParameters.Default(name));
        public static Window CreateWindow([NotNull] string name, int width, int height) =>
            CreateWindow(WindowParameters.Default(name, width, height));

        public static Renderer CreateRenderer()
        {
            _instance.Renderer = new Renderer();
            return _instance.Renderer;
        }

        public static Debug CreateDebugger()
        {
            _instance.Debugger = new Debug();
            return _instance.Debugger;
        }
        
        public static Debug CreateDebugger(string title)
        {
            _instance.Debugger = new Debug(title);
            return _instance.Debugger;
        }
        
        public static Debug CreateDebugger(string title, int width, int height)
        {
            _instance.Debugger = new Debug(title, width, height);
            return _instance.Debugger;
        }

        /* Static methods */
        public static Game CreateApplication()
        {
            if (!HasCurrentInstance())
            {
                _instance = new Game();
            }
            
            return _instance;
        }

        public static bool HasCurrentInstance() => _instance != null;
        public static bool IsRunning() =>  HasCurrentInstance() && _instance._isRunning;
        public static Game GetCurrentApplication() 
            => HasCurrentInstance() ? _instance : CreateApplication();

        public static void StartApplication()
        {
            Event.Invoke(Event.Start);
        }

        public static void InitializeApplication()
        {
            Event.Invoke(Event.Initialize);
        }
        
        public static void Stop(int status)
        {
            Event.Invoke<int>(Event.Stop, status);
        }
    }
}
